<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Stationeers Server Manager - Configuration and Updates">
    <title>Manager - Stationeers Server Manager</title>
    
    <link rel="stylesheet" href="/static/ui-theme.css?v={{buildTime}}">
    <link rel="icon" href="/sdsm.png" type="image/png">
    
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    
    <script>
            (function(){
            // Lightweight header stats fetcher to keep hero-meta live
            function pollStats() {
                fetch('/api/stats', {
                    headers: { 'Accept': 'application/json' },
                    credentials: 'same-origin',
                    cache: 'no-store'
                })
                    .then((res) => res.ok ? res.json() : null)
                    .then((data) => {
                        if (!data) return;
                        try {
                            document.getElementById('header-total-servers').textContent = data.totalServers;
                            document.getElementById('header-total-servers-suffix').textContent = data.totalServers === 1 ? '' : 's';
                            document.getElementById('header-active-servers').textContent = data.activeServers;
                            document.getElementById('header-total-players').textContent = data.totalPlayers;
                            document.getElementById('last-refresh').textContent = new Date().toLocaleTimeString();
                        } catch(e) {
                            console.error("Error updating header stats:", e);
                        }
                    })
                    .catch(() => {});
            }

            document.addEventListener('DOMContentLoaded', () => {
                pollStats();
                setInterval(pollStats, 30000);
                // Trigger polling when user clicks the global refresh button
                document.body.addEventListener('htmx:afterRequest', function(evt) {
                    if (evt.detail.elt.getAttribute('hx-get') === '/api/refresh') {
                        pollStats();
                    }
                });
            });

            // Defer DOM queries and event bindings until the DOM is ready
            let pollTimer = null;

            // Toast helper for fetch-based requests
            function showToastFromHeaders(res) {
                try {
                    if (!window.showToast || !res || !res.headers) return;
                    const type = res.headers.get('X-Toast-Type');
                    const title = res.headers.get('X-Toast-Title');
                    const message = res.headers.get('X-Toast-Message');
                    if (message) {
                        window.showToast({ type: type || 'info', title: title || '', message });
                    }
                } catch (_) {
                    // ignore header parse failures
                }
            }

            function showButtonSpinner(btn, on) {
                if (!btn) return;
                btn.setAttribute('aria-busy', on ? 'true' : 'false');
                let sp = btn.querySelector('.btn-spinner');
                if (on) {
                    if (!sp) {
                        sp = document.createElement('span');
                        sp.className = 'btn-spinner';
                        sp.setAttribute('aria-hidden', 'true');
                        btn.appendChild(sp);
                    }
                } else if (sp) {
                    sp.remove();
                }
            }

            // Unified confirm wrapper using modal helper when available
            function askConfirm(options, fallbackMessage) {
                try {
                    if (window.openConfirm) {
                        return window.openConfirm(options);
                    }
                } catch(_) {}
                return Promise.resolve(window.confirm(fallbackMessage));
            }

            function showMessage(text, isError) {
                const messageEl = document.getElementById('updateMessage');
                if (!messageEl) return;
                if (!text) {
                    messageEl.classList.remove('active', 'error');
                    messageEl.textContent = '';
                    return;
                }
                messageEl.textContent = text;
                messageEl.classList.add('active');
                messageEl.classList.toggle('error', !!isError);
            }

            function setButtonsDisabled(disabled) {
                const btns = document.querySelectorAll('.update-trigger');
                btns.forEach((btn) => {
                    // Only toggle disabled if not currently running a spinner operation
                    if (!disabled) {
                        btn.disabled = false;
                        showButtonSpinner(btn, false);
                    } else {
                        btn.disabled = true;
                    }
                });
                // Also toggle config button
                const cfgBtn = document.getElementById('updateConfigBtn');
                if (cfgBtn) cfgBtn.disabled = disabled;
            }

            function selectProgressRow(key) {
                if (!key) return null;
                return document.querySelector('.progress-row[data-progress="' + key.toLowerCase() + '"]');
            }

            function formatBytes(bytes) {
                if (!bytes || bytes <= 0) return '0 B';
                const units = ['B', 'KB', 'MB', 'GB', 'TB'];
                let value = bytes; let index = 0;
                while (value >= 1024 && index < units.length - 1) { value /= 1024; index++; }
                const fixed = value < 10 && index > 0 ? value.toFixed(1) : Math.round(value).toString();
                return fixed + ' ' + units[index];
            }

            function updateProgressRow(component) {
                const row = selectProgressRow(component.key || component.component);
                if (!row) return;
                const fill = row.querySelector('.progress-fill');
                const text = row.querySelector('.progress-text');
                const active = component.running || component.percent > 0 || !!component.error;

                row.classList.toggle('active', active);
                row.classList.toggle('error', !!component.error);

                if (fill) {
                    if (component.total > 0) {
                        fill.style.width = Math.min(component.percent || 0, 100) + '%';
                        fill.classList.remove('indeterminate');
                    } else if (component.running) {
                        fill.style.width = '100%';
                        fill.classList.add('indeterminate');
                    } else {
                        fill.style.width = '0%';
                        fill.classList.remove('indeterminate');
                    }
                }

                if (text) {
                    // Safe renderer for status + optional trailing text, avoids injecting arbitrary HTML
                    const renderStatus = (kind, label, tail) => {
                        text.innerHTML = '';
                        const pill = document.createElement('span');
                        pill.className = 'status-pill status-' + kind;
                        const dot = document.createElement('span');
                        dot.className = 'dot';
                        dot.setAttribute('aria-hidden', 'true');
                        pill.appendChild(dot);
                        pill.appendChild(document.createTextNode(label));
                        text.appendChild(pill);
                        if (tail) {
                            text.appendChild(document.createTextNode(' ' + tail));
                        }
                    };

                    let status = (component.stage || '').trim();
                    if (component.error) {
                        renderStatus('error', 'Error', component.error);
                    } else if (component.running) {
                        let tail = '';
                        if (component.total > 0) {
                            tail = (status ? status + ' ' : '') + '(' + (component.percent || 0) + '% of ' + formatBytes(component.total) + ')';
                        } else {
                            tail = status || '';
                        }
                        renderStatus('running', 'Running', tail);
                    } else if (!component.running && (status === '' || /^(idle)$/i.test(status))) {
                        renderStatus('idle', 'Idle', '');
                    } else if (!component.running && component.percent >= 100 && !component.error) {
                        renderStatus('complete', 'Completed', status && !/^completed$/i.test(status) ? status : '');
                    } else {
                        text.textContent = status;
                    }
                }
            }

            let __prevUpdating = null;
            function handleProgressSnapshot(snapshot) {
                if (!snapshot || !Array.isArray(snapshot.components)) return;
                snapshot.components.forEach(updateProgressRow);
                setButtonsDisabled(snapshot.updating);
                // When an update run transitions from active -> idle, refresh the page
                if (__prevUpdating === true && snapshot.updating === false) {
                    // Small delay to let UI show Completed state
                    setTimeout(() => { window.location.reload(); }, 600);
                }
                __prevUpdating = !!snapshot.updating;
                if (!snapshot.updating && pollTimer) { clearInterval(pollTimer); pollTimer = null; }
            }

            function fetchProgress() {
                fetch('/update/progress', { headers: { 'Accept': 'application/json' }, credentials: 'same-origin' })
                    .then((res) => res.ok ? res.json() : null)
                    .then(handleProgressSnapshot)
                    .catch(() => {});
            }

            function ensurePolling() {
                if (!pollTimer) pollTimer = setInterval(fetchProgress, 2000);
            }

            // Async populate of versions table to speed initial paint
            let __versionsLoaded = false;
            function populateVersions(data){
                const map = [
                    ['ver-steamcmd-deployed','steamcmd_deployed'],
                    ['ver-steamcmd-latest','steamcmd_latest'],
                    ['ver-release-deployed','release_deployed'],
                    ['ver-release-latest','release_latest'],
                    ['ver-beta-deployed','beta_deployed'],
                    ['ver-beta-latest','beta_latest'],
                    ['ver-bepinex-deployed','bepinex_deployed'],
                    ['ver-bepinex-latest','bepinex_latest'],
                    ['ver-launchpad-deployed','launchpad_deployed'],
                    ['ver-launchpad-latest','launchpad_latest'],
                    ['ver-scon-deployed','scon_deployed'],
                    ['ver-scon-latest','scon_latest']
                ];
                                map.forEach(([id,key])=>{ const el=document.getElementById(id); if(el && key in data){ el.textContent = data[key] || ''; } });
                                // Provisional coloring before strict compare: default neutral
                                try {
                                        document.querySelectorAll('button.update-trigger[data-component]')
                                            .forEach(btn => { btn.classList.remove('btn-success','btn-danger'); if (!btn.classList.contains('btn-primary')) btn.classList.add('btn-neutral'); });
                                } catch(_) {}
                // Update button colors based on component-specific state logic, mirroring backend decisions
                function setBtnColor(name, deployedKey, latestKey){
                    const btn = document.querySelector('button[data-component="'+name+'"]');
                    if (!btn) return;
                    const rawDeployed = (data[deployedKey] || '').trim();
                    const rawLatest = (data[latestKey] || '').trim();
                    // Always start by clearing prior state
                    btn.classList.remove('btn-success','btn-danger');
                    // Remove secondary base so variant gradients are visible
                    if (btn.classList.contains('btn-secondary')) {
                        btn.classList.remove('btn-secondary');
                    }

                    // Classify special sentinel values
                    const isMissing = (s) => !s || /^(missing|unknown|error)$/i.test(s);
                    const isTimeout = (s) => /^(timeout)$/i.test(s);
                    const isInstalledOnly = (s) => /^installed$/i.test(s);

                    // Neutral when we don't have reliable data
                    if (isMissing(rawDeployed) || (name !== 'steamcmd' && isMissing(rawLatest))) {
                        if (name === 'steamcmd') {
                            // For SteamCMD, treat missing/unknown/error/timeout as needs attention (red)
                            btn.classList.add('btn-danger');
                            btn.title = 'Missing or unavailable';
                            return;
                        } else {
                            btn.classList.add('btn-neutral');
                            btn.title = 'Unavailable';
                            return;
                        }
                    }

                    // Component-specific comparison rules
                    let upToDate = false;
                    const d = rawDeployed;
                    const l = rawLatest;
                    switch (name) {
                        case 'bepinex':
                            // Deployed often 4-part vs latest 3-part; treat prefix match as up-to-date
                            if (isInstalledOnly(d)) {
                                upToDate = false; // cannot assert; leave as not up-to-date
                            } else {
                                upToDate = d.startsWith(l);
                            }
                            break;
                        case 'launchpad':
                            // Accept exact or prefix (case-insensitive). Deployed may be 'Installed' or include extra metadata.
                            if (isInstalledOnly(d)) {
                                upToDate = false;
                            } else {
                                upToDate = d.toLowerCase() === l.toLowerCase() || d.toLowerCase().startsWith(l.toLowerCase());
                            }
                            break;
                        case 'scon':
                            // Compare lowercased equality (latest may include leading 'v').
                            upToDate = d.toLowerCase() === l.toLowerCase();
                            break;
                        case 'steamcmd':
                            // SteamCMD lacks an external latest; color green if installed and responsive, red if missing/error/timeout.
                            if (isMissing(d) || isTimeout(d)) {
                                btn.classList.add('btn-danger');
                                btn.title = 'Missing or unavailable';
                            } else {
                                btn.classList.add('btn-success');
                                btn.title = 'Installed';
                            }
                            return;
                        default:
                            // release/beta by buildid exact equality
                            upToDate = d === l;
                    }

                    if (upToDate) {
                        btn.classList.add('btn-success');
                        btn.title = 'Up to date';
                    } else {
                        btn.classList.add('btn-danger');
                        btn.title = 'Update available';
                    }
                }
                setBtnColor('steamcmd','steamcmd_deployed','steamcmd_latest');
                setBtnColor('release','release_deployed','release_latest');
                setBtnColor('beta','beta_deployed','beta_latest');
                setBtnColor('bepinex','bepinex_deployed','bepinex_latest');
                setBtnColor('launchpad','launchpad_deployed','launchpad_latest');
                setBtnColor('scon','scon_deployed','scon_latest');
                __versionsLoaded = true;
                try { window.__versionsPrimaryLoaded = true; } catch(_) {}
                try { console.debug('[SDSM] Versions loaded (primary).'); } catch(_) {}
            }
            function fetchVersions(retryCount){
                const tries = typeof retryCount === 'number' ? retryCount : 0;
                fetch('/api/manager/versions', { headers:{'Accept':'application/json'}, credentials:'same-origin', cache:'no-store' })
                  .then(r=> r.ok ? r.json() : Promise.reject(new Error('bad status '+r.status)))
                  .then(populateVersions)
                  .catch((err)=>{
                      try { console.error('[SDSM] Versions fetch failed (primary)', err); } catch(_) {}
                      if (window && typeof window.showToast === 'function' && tries >= 2) {
                          window.showToast({ type: 'error', title: 'Version Load Failed', message: 'Could not fetch component versions.' });
                      }
                      if (tries < 3) {
                          setTimeout(()=>fetchVersions(tries+1), 500 * (tries+1));
                      } else {
                          // Final fallback: mark cells as unavailable
                          const ids = ['ver-steamcmd-deployed','ver-steamcmd-latest','ver-release-deployed','ver-release-latest','ver-beta-deployed','ver-beta-latest','ver-bepinex-deployed','ver-bepinex-latest','ver-launchpad-deployed','ver-launchpad-latest','ver-scon-deployed','ver-scon-latest'];
                          ids.forEach(id=>{ const el=document.getElementById(id); if(el && (el.textContent==='Loading…' || el.textContent==='Loading...')){ el.textContent='Unavailable'; }});
                      }
                  });
            }

            // Manager-level Language removed; languages are configured per server.

            document.addEventListener('DOMContentLoaded', () => {
                const buttons = Array.from(document.querySelectorAll('.update-trigger'));
                const configForm = document.getElementById('configForm');
                const configBtn = document.getElementById('updateConfigBtn');
                const shutdownBtn = document.getElementById('shutdownBtn');
                const restartBtn = document.getElementById('restartBtn');
                // Safety net: ensure all .btn elements have a color variant. If none present, default to secondary.
                (function enforceButtonVariants(){
                    try {
                        const btns = document.querySelectorAll('.btn');
                        btns.forEach((b)=>{
                            const hasVariant = b.classList.contains('btn-primary') || b.classList.contains('btn-secondary') || b.classList.contains('btn-danger') || b.classList.contains('btn-success') || b.classList.contains('btn-warning') || b.classList.contains('btn-control') || b.classList.contains('btn-storm') || b.classList.contains('btn-info') || b.classList.contains('btn-neutral') || b.classList.contains('btn-ghost') || b.classList.contains('btn-outline');
                            if (!hasVariant) b.classList.add('btn-neutral');
                        });
                    } catch(_) {}
                })();
                // If an update was already in progress when the page rendered (template .updating == true),
                // begin polling progress immediately so the UI will auto-refresh when it completes.
                const initialUpdating = {{if .updating}}true{{else}}false{{end}};
                if (initialUpdating) {
                    try { __prevUpdating = true; } catch(_) {}
                    fetchProgress();
                    ensurePolling();
                }
                const stopAllBtn = document.getElementById('stopAllBtn');
                


                // Kick off async versions fetch shortly after paint (primary path)
                try { setTimeout(() => { fetchVersions(0); }, 60); } catch(_) {}

                // Wire up update buttons
                buttons.forEach((btn) => {
                    btn.addEventListener('click', (event) => {
                        event.preventDefault();
                        if (btn.disabled) return;

                        const target = btn.dataset.updateTarget;
                        if (!target) return;

                        const params = new URLSearchParams();
                        params.append(target, '1');

                        setButtonsDisabled(true);
                        showButtonSpinner(btn, true);
                        showMessage('Starting update...', false);

                        fetch('/update', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/x-www-form-urlencoded',
                                'X-Requested-With': 'XMLHttpRequest',
                                'Accept': 'application/json'
                            },
                            credentials: 'same-origin',
                            body: params.toString()
                        })
                            .then((res) => { showToastFromHeaders(res); if (!res.ok) { return res.json().then((data) => Promise.reject(data)); } return res.json(); })
                            .then((data) => {
                                if (data && data.status === 'started') {
                                    const label = btn.closest('tr')?.querySelector('.component-title')?.textContent?.trim() || 'Update';
                                    showMessage(label + ' started...', false);
                                    fetchProgress();
                                    ensurePolling();
                                } else if (data && data.status === 'ok') {
                                    showMessage('Configuration updated.', false);
                                    setButtonsDisabled(false);
                                } else {
                                    showMessage('', false);
                                    setButtonsDisabled(false);
                                }
                            })
                            .catch((err) => {
                                const errorText = err && err.error ? err.error : 'Unable to start update. Please try again.';
                                showMessage(errorText, true);
                                setButtonsDisabled(false);
                                fetchProgress();
                            });
                    });
                });

            // Async submit for Configuration form with inline spinner
            if (configForm && configBtn) {
                configForm.addEventListener('submit', async (event) => {
                    event.preventDefault();
                    const submitter = event.submitter;
                    // Special-case: Generate self-signed certificate should ONLY send its own flag
                    if (submitter && submitter.name === 'generate_tls_self_signed') {
                        const genBtn = submitter;
                        if (genBtn.disabled) return;
                        // If TLS already enabled, confirm regeneration (rotation)
                        if (genBtn.getAttribute('data-tls-enabled') === 'true') {
                            // Synchronous confirm path falls back if modal system absent
                            const regenMsg = 'Replace existing certificate with a new self-signed one? Current HTTPS clients will need to trust the new cert again.';
                            const proceed = window.openConfirm ? await window.openConfirm({ title:'Regenerate Certificate', message: regenMsg, confirmText:'Regenerate', cancelText:'Cancel', danger:true }) : window.confirm(regenMsg);
                            if (!proceed) { return; }
                        }
                        genBtn.disabled = true;
                        showButtonSpinner(genBtn, true);
                        showMessage('Generating TLS certificate…', false);
                        const params = new URLSearchParams();
                        params.append('generate_tls_self_signed', '1');
                        fetch('/update', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/x-www-form-urlencoded',
                                'X-Requested-With': 'XMLHttpRequest',
                                'Accept': 'application/json'
                            },
                            credentials: 'same-origin',
                            body: params.toString()
                        })
                        .then((res) => { showToastFromHeaders(res); if (!res.ok) { return res.json().then((data) => Promise.reject(data)); } return res.json().catch(() => ({})); })
                        .then(() => {
                            // Backend persists TLSEnabled=true and relative cert/key paths.
                            showMessage('TLS certificate created. HTTPS requires a restart to take effect.', false);
                            try { sessionStorage.setItem('sdsm:pending-https','1'); } catch(_) {}
                            // Offer restart prompt
                            askConfirm({ title:'Restart Required', message:'Restart SDSM now to apply HTTPS and switch to a secure connection?', confirmText:'Restart Now', cancelText:'Later', danger:true }, 'Restart SDSM now to apply HTTPS?')
                              .then((ok) => {
                                  if (!ok) { return; }
                                  // Issue restart request
                                  showMessage('Restarting to apply HTTPS…', false);
                                  const rParams = new URLSearchParams(); rParams.append('restart','1');
                                  fetch('/update', {
                                      method:'POST',
                                      headers:{
                                          'Content-Type':'application/x-www-form-urlencoded',
                                          'X-Requested-With':'XMLHttpRequest',
                                          'Accept':'application/json'
                                      },
                                      credentials:'same-origin',
                                      body: rParams.toString()
                                  })
                                  .then(r => { showToastFromHeaders(r); /* ignore body parse errors */ return r.json().catch(()=>({})); })
                                  .then(()=>{
                                      showMessage('Restart initiated. Waiting for HTTPS availability…', false);
                                      // Attempt automatic HTTPS switch with polling.
                                      attemptHttpsRedirect();
                                  })
                                  .catch(()=>{ showMessage('Restart request failed. Please restart manually.', true); });
                              });
                            // Helper: poll HTTPS health until reachable then redirect.
                            function attemptHttpsRedirect(){
                                const target = location.href.replace(/^http:/,'https:');
                                const healthUrl = 'https://' + location.host + '/healthz';
                                const start = Date.now();
                                let tries = 0;
                                const maxMs = 60000; // 1 minute ceiling
                                const interval = 2500;
                                // Hard fallback: navigate even if health check cannot succeed (e.g., self-signed cert interstitial)
                                const hardFallbackTimer = setTimeout(() => {
                                    try { console.warn('[SDSM][TLS] Navigating to HTTPS without health confirmation.'); } catch(_) {}
                                    window.location.href = target;
                                }, 12000);
                                function tryFetch(){
                                    tries++;
                                    fetch(healthUrl, { cache:'no-store' })
                                      .then(r => { if (r.ok) { showMessage('HTTPS available. Switching…', false); setTimeout(()=>{ window.location.href = target; }, 400); return; }
                                          throw new Error('bad status'); })
                                      .catch(()=>{
                                          if (Date.now() - start > maxMs) {
                                              showMessage('HTTPS not reachable yet. You may need to manually reload via '+healthUrl, true);
                                              if (window.showToast) window.showToast({ type:'warning', title:'Manual Step', message:'Open '+target+' after restart (trust the certificate if prompted).' });
                                              return;
                                          }
                                          setTimeout(tryFetch, interval);
                                      });
                                }
                                // Initial delay to allow process shutdown/start
                                setTimeout(tryFetch, 3000);
                                try { console.warn('[SDSM][TLS] Polling for HTTPS availability…'); } catch(_) {}
                            }
                        })
                        .catch((err) => {
                            const errorText = err && err.error ? err.error : 'Unable to generate certificate. Please try again.';
                            showMessage(errorText, true);
                            if (window.showToast) window.showToast({ type: 'error', title: 'Generation Failed', message: errorText });
                        })
                        .finally(() => {
                            showButtonSpinner(genBtn, false);
                            genBtn.disabled = false; // In case reload doesn’t happen
                        });
                        return;
                    }

                    // Default path: Update Config
                    if (configBtn.disabled) return;
                    const fd = new FormData(configForm);
                    const params = new URLSearchParams();
                    for (const [key, value] of fd.entries()) {
                        params.append(key, typeof value === 'string' ? value : String(value));
                    }
                    if (!params.has('update_config')) params.append('update_config', '1');

                    configBtn.disabled = true;
                    showButtonSpinner(configBtn, true);
                    showMessage('Saving configuration…', false);

                    fetch('/update', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                            'X-Requested-With': 'XMLHttpRequest',
                            'Accept': 'application/json'
                        },
                        credentials: 'same-origin',
                        body: params.toString()
                    })
                        .then((res) => { showToastFromHeaders(res); if (!res.ok) { return res.json().then((data) => Promise.reject(data)); } return res.json(); })
                        .then((data) => {
                            if (data && (data.status === 'ok' || data.status === 'updated')) {
                                showMessage('Configuration updated.', false);
                                // Refresh versions table if placeholders present or after config change
                                try { if (typeof fetchVersions === 'function') fetchVersions(); } catch(_) {}
                            } else {
                                showMessage('Configuration updated.', false);
                                try { if (typeof fetchVersions === 'function') fetchVersions(); } catch(_) {}
                            }
                        })
                        .catch((err) => {
                            const errorText = err && err.error ? err.error : 'Unable to save configuration. Please try again.';
                            showMessage(errorText, true);
                            if (window.showToast) window.showToast({ type: 'error', title: 'Save Failed', message: errorText });
                        })
                        .finally(() => {
                            configBtn.disabled = false;
                            showButtonSpinner(configBtn, false);
                        });
                });
            }

            // Footer actions: Shutdown / Restart with async POSTs and spinners
            function disableFooterButtons(disabled) {
                if (shutdownBtn) shutdownBtn.disabled = disabled;
                if (restartBtn) restartBtn.disabled = disabled;
                if (!disabled) {
                    if (shutdownBtn) showButtonSpinner(shutdownBtn, false);
                    if (restartBtn) showButtonSpinner(restartBtn, false);
                }
            }

            function postFooterAction(kind, btn, confirmingText, startedText, successText, errorText) {
                if (!btn) return;

                const danger = (kind === 'shutdown' || kind === 'restart');
                askConfirm({ title: 'Confirm', message: confirmingText, confirmText: 'Confirm', cancelText: 'Cancel', danger }, confirmingText)
                    .then((ok) => {
                        if (!ok) return;

                        const params = new URLSearchParams();
                        params.append(kind, '1');

                        disableFooterButtons(true);
                        showButtonSpinner(btn, true);
                        showMessage(startedText, false);

                        fetch('/update', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/x-www-form-urlencoded',
                                'X-Requested-With': 'XMLHttpRequest',
                                'Accept': 'application/json'
                            },
                            credentials: 'same-origin',
                            body: params.toString()
                        })
                            .then((res) => { showToastFromHeaders(res); if (!res.ok) { return res.json().then((data) => Promise.reject(data)); } return res.json().catch(() => ({})); })
                            .then(() => {
                                showMessage(successText, false);
                                setTimeout(() => disableFooterButtons(false), 3000);
                            })
                            .catch((err) => {
                                const e = err && err.error ? err.error : errorText;
                                showMessage(e, true);
                                if (window.showToast) window.showToast({ type: 'error', title: 'Request Failed', message: e });
                                disableFooterButtons(false);
                            });
                    });
            }

            if (shutdownBtn) {
                shutdownBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    // If detached servers is enabled and any server is running, prompt the user
                    const detachedEnabled = document.body.getAttribute('data-detached') === 'true';
                    const runningCountEl = document.getElementById('server-count-running');
                    const runningCount = runningCountEl ? parseInt(runningCountEl.textContent || '0', 10) : 0;
                    if (detachedEnabled && runningCount > 0) {
                        askConfirm({ title: 'Shutdown', message: 'Servers are running and detached mode is enabled. Stop all servers as well?', confirmText: 'Stop Servers', cancelText: 'Do Not Stop', danger: true }, 'Servers are running and detached mode is enabled. Stop all servers as well?')
                          .then((alsoStop) => {
                              const params = new URLSearchParams();
                              params.append('shutdown', '1');
                              params.append('stop_servers', alsoStop ? '1' : '0');
                              disableFooterButtons(true);
                              showButtonSpinner(shutdownBtn, true);
                              showMessage('Shutting down SDSM…', false);
                              fetch('/shutdown', {
                                  method: 'POST',
                                  headers: {
                                      'Content-Type': 'application/x-www-form-urlencoded',
                                      'X-Requested-With': 'XMLHttpRequest',
                                      'Accept': 'application/json'
                                  },
                                  credentials: 'same-origin',
                                  body: params.toString()
                              }).then((res) => { showToastFromHeaders(res); if (!res.ok) { return res.json().then((d)=>Promise.reject(d)); } return res.json().catch(()=>({})); })
                              .then(()=>{ showMessage('Shutdown initiated. The UI may go offline shortly.', false); setTimeout(()=>disableFooterButtons(false), 3000); })
                              .catch((err)=>{ const e = err && err.error ? err.error : 'Unable to shutdown SDSM. Please try again.'; showMessage(e, true); if (window.showToast) window.showToast({type:'error', title:'Request Failed', message:e}); disableFooterButtons(false); });
                          });
                        return;
                    }
                    postFooterAction(
                        'shutdown',
                        shutdownBtn,
                        (detachedEnabled
                            ? 'Are you sure you want to shutdown SDSM? Detached mode is enabled; no servers will be stopped.'
                            : 'Are you sure you want to shutdown SDSM? All servers will be stopped.'),
                        'Shutting down SDSM…',
                        'Shutdown initiated. The UI may go offline shortly.',
                        'Unable to shutdown SDSM. Please try again.'
                    );
                });
            }

            if (restartBtn) {
                restartBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    postFooterAction(
                        'restart',
                        restartBtn,
                        'Are you sure you want to restart SDSM? All servers will be temporarily stopped.',
                        'Restarting SDSM…',
                        'Restart initiated. The UI will reconnect when available.',
                        'Unable to restart SDSM. Please try again.'
                    );
                });
            }

            // Stop All Servers (bulk stop) with dynamic enable/disable
            if (stopAllBtn) {
                function updateStopAllDisabled() {
                    const runningCountEl = document.getElementById('server-count-running');
                    const currentRunning = runningCountEl ? parseInt(runningCountEl.textContent || '0', 10) : 0;
                    // Disabled if none running or an update is in progress
                    const anyUpdateDisabled = !!document.querySelector('.update-trigger[disabled]');
                    stopAllBtn.disabled = currentRunning === 0 || anyUpdateDisabled;
                }
                function pollActiveServers(){
                    fetch('/api/stats', { headers:{'Accept':'application/json'}, credentials:'same-origin', cache:'no-store' })
                      .then(r => r.ok ? r.json() : null)
                      .then(data => { if (data && typeof data.activeServers === 'number') {
                          const el = document.getElementById('server-count-running');
                          if (el) el.textContent = String(data.activeServers);
                          updateStopAllDisabled();
                      }}).catch(()=>{});
                }
                // Initial state
                updateStopAllDisabled();
                // Poll every 15s
                setInterval(pollActiveServers, 15000);
                stopAllBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    if (stopAllBtn.disabled) return;
                    const runningCountEl = document.getElementById('server-count-running');
                    const currentRunning = runningCountEl ? parseInt(runningCountEl.textContent || '0', 10) : 0;
                    if (currentRunning === 0) {
                        if (window.showToast) window.showToast({ type: 'info', title: 'No Servers', message: 'There are no running servers to stop.' });
                        return;
                    }
                    askConfirm({ title: 'Stop All Servers', message: 'Stop ALL running servers? Active processes will be terminated.', confirmText: 'Stop All', cancelText: 'Cancel', danger: true }, 'Stop ALL running servers? Active processes will be terminated.')
                      .then((ok) => {
                        if (!ok) return;
                        stopAllBtn.disabled = true;
                    showButtonSpinner(stopAllBtn, true);
                    fetch('/api/servers/stop-all', {
                        method: 'POST',
                        headers: { 'Accept': 'application/json' },
                        credentials: 'same-origin'
                    })
                    .then(res => { showToastFromHeaders(res); if (!res.ok) { return res.json().then(d => Promise.reject(d)); } return res.json(); })
                    .then(data => {
                        const stopped = data && typeof data.stopped === 'number' ? data.stopped : currentRunning;
                        if (runningCountEl) runningCountEl.textContent = '0';
                        if (window.showToast && stopped >= 0) window.showToast({ type: 'success', title: 'Stopped', message: 'Stopped ' + stopped + ' servers.' });
                        updateStopAllDisabled();
                    })
                    .catch(err => {
                        const msg = err && err.error ? err.error : 'Failed to stop servers.';
                        if (window.showToast) window.showToast({ type: 'error', title: 'Stop Failed', message: msg });
                    })
                    .finally(() => {
                        updateStopAllDisabled();
                        showButtonSpinner(stopAllBtn, false);
                        });
                      });
                });
            }

            // (Removed duplicate User Management collapsible toggle to avoid conflicts)

            // User Management logic
            (function(){
                // Guard: if another bootstrapper already initialized, skip this one
                try {
                    var __card = document.getElementById('userMgmtCard');
                    if (!__card) return;
                    if (__card.dataset.umInit === '1') {
                        try { console.debug('[SDSM][UM] Skipping primary bootstrap (already initialized)'); } catch(_) {}
                        return;
                    }
                    __card.dataset.umInit = '1';
                } catch(_) {}
                const tbody = document.getElementById('um_table_body');
                const userCount = document.getElementById('userMgmtCount');
                const userToggleBtn = document.getElementById('userMgmtToggle');
                const userContent = document.getElementById('userMgmtContent');
                const addBtn = document.getElementById('um_add_btn');
                const newUser = document.getElementById('um_new_username');
                const newPass = document.getElementById('um_new_password');
                const newRole = document.getElementById('um_new_role');
                const accessBtn = document.getElementById('um_access_btn');
                const accessDrop = document.getElementById('um_access_dropdown');
                const accessAll = document.getElementById('um_access_all');
                const accessList = document.getElementById('um_access_list');
                const accessSave = document.getElementById('um_access_save');
                const accessClose = document.getElementById('um_access_close');
                if(!tbody) return;

                let listBusy = false;
                let serversCache = null;
                let usersData = [];
                let sortState = { key: 'username', dir: 'asc' };
                let newAssignAll = false;
                let newAssignServers = new Set();

                // Inline SVG icon constants (avoid template injection inside JS literals)
                const ICON_KEY = '<svg class="icon-inline" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true"><circle cx="7" cy="12" r="3"/><path d="M10 12h11l-2 2 2 2-2 2"/></svg>';
                const ICON_TRASH = '<svg class="icon-inline" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true"><polyline points="3 6 5 6 21 6"/><path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"/><path d="M10 11v6M14 11v6"/><path d="M9 6V4a2 2 0 0 1 2-2h2a2 2 0 0 1 2 2v2"/></svg>';

                function ensureServersCache(){
                    if (serversCache) {
                        try { console.debug('[SDSM][UM] serversCache reused (len='+serversCache.length+")", serversCache); } catch(_) {}
                        return Promise.resolve(serversCache);
                    }
                    const t0 = performance.now();
                    return fetch('/api/servers', {headers:{'Accept':'application/json'}, credentials:'same-origin'})
                        .then(r => {
                            if (!r.ok) {
                                try { console.error('[SDSM][UM] /api/servers status', r.status); } catch(_) {}
                                return Promise.reject(new Error('status '+r.status));
                            }
                            return r.json().catch(err=>{ try { console.error('[SDSM][UM] /api/servers JSON parse failed', err); } catch(_) {}; throw err; });
                        })
                        .then(data => {
                            serversCache = Array.isArray(data.servers) ? data.servers : [];
                            try {
                                console.debug('[SDSM][UM] /api/servers fetched '+serversCache.length+' servers in '+(performance.now()-t0).toFixed(1)+'ms', serversCache);
                                window.__sdsmServersCache = serversCache;
                            } catch(_) {}
                            return serversCache;
                        })
                        .catch(err => {
                            serversCache = [];
                            try { console.error('[SDSM][UM] /api/servers failed; dropdown will show empty state', err); } catch(_) {}
                            return serversCache;
                        });
                }

                function openAssignPanel(username){
                    const row = Array.from(tbody.querySelectorAll('tr')).find(tr => tr.firstChild && tr.firstChild.textContent === username);
                    if (!row) return;
                    let panelRow = row.nextElementSibling;
                    const isPanel = panelRow && panelRow.classList && panelRow.classList.contains('um-assign-panel');
                    if (!isPanel) {
                        panelRow = document.createElement('tr');
                        panelRow.className = 'um-assign-panel';
                        const td = document.createElement('td'); td.colSpan = 4; td.className = 'assign-panel-cell';
                        td.innerHTML = '<div><strong>Server Access</strong><div class="form-group mt-2"><label class="inline-flex items-center gap-2"><input type="checkbox" id="assign_all_'+username+'"> All servers</label></div><div id="assign_list_'+username+'" class="assign-list mt-2"></div><div class="mt-2"><button class="btn btn-primary" id="assign_save_'+username+'">Save</button> <button class="btn btn-ghost" id="assign_close_'+username+'">Close</button></div></div>';
                        panelRow.appendChild(td);
                        row.insertAdjacentElement('afterend', panelRow);
                    }

                    panelRow.style.display = panelRow.style.display === 'none' ? '' : '';

                    ensureServersCache().then(() => {
                        // Populate server checkboxes
                        const list = panelRow.querySelector('#assign_list_'+CSS.escape(username)+'' );
                        const chkAll = panelRow.querySelector('#assign_all_'+CSS.escape(username)+'' );
                        const btnSave = panelRow.querySelector('#assign_save_'+CSS.escape(username)+'' );
                        const btnClose = panelRow.querySelector('#assign_close_'+CSS.escape(username)+'' );
                        if (!list || !chkAll || !btnSave || !btnClose) return;

                        list.innerHTML = '';
                        serversCache.forEach(s => {
                            const lbl = document.createElement('label'); lbl.className = 'assign-chip';
                            const cb = document.createElement('input'); cb.type='checkbox'; cb.value=String(s.id); cb.className='assign-cb';
                            const span = document.createElement('span'); span.textContent = s.name + ' (#'+s.id+')';
                            lbl.appendChild(cb); lbl.appendChild(span);
                            list.appendChild(lbl);
                        });

                        function setListEnabled(enabled){
                            list.querySelectorAll('.assign-cb').forEach((el)=>{ el.disabled = !enabled; });
                        }

                        // Load current assignments
                        fetch('/api/users/'+encodeURIComponent(username)+'/assignments', {headers:{'Accept':'application/json'}, credentials:'same-origin'})
                          .then(r=> r.ok ? r.json() : { all:false, servers:[] })
                          .then(data => {
                              const all = !!data.all; const servers = Array.isArray(data.servers) ? data.servers.map(Number) : [];
                              chkAll.checked = all;
                              setListEnabled(!all);
                              list.querySelectorAll('.assign-cb').forEach((cb)=>{ const id = Number(cb.value); cb.checked = servers.includes(id); });
                          });

                        chkAll.addEventListener('change', ()=> setListEnabled(!chkAll.checked));
                        btnClose.addEventListener('click', ()=> { panelRow.style.display='none'; });
                        btnSave.addEventListener('click', ()=>{
                            const all = chkAll.checked;
                            const selected = Array.from(list.querySelectorAll('.assign-cb')).filter(cb=>cb.checked).map(cb=>Number(cb.value));
                            fetch('/api/users/'+encodeURIComponent(username)+'/assignments', { method:'POST', credentials:'same-origin', headers:{'Content-Type':'application/json','Accept':'application/json'}, body: JSON.stringify({ all, servers: selected }) })
                              .then(r=> r.ok ? r.json() : r.json().then(Promise.reject))
                              .then(()=>{ if(window.showToast) window.showToast({type:'success', title:'Assignments Saved', message:'Updated access for '+username}); })
                              .catch(err=>{ if(window.showToast) window.showToast({type:'error', title:'Save Failed', message:(err&&err.error)||'Unable to save assignments'}); });
                        });
                    });
                }

                function positionDropdown(anchor, panel){
                    if (!anchor || !panel) return;
                    panel.style.visibility = 'hidden';
                    panel.style.display = 'block';
                    const rect = anchor.getBoundingClientRect();
                    // If width cannot be measured yet, fall back to declared width or a sane default
                    let menuWidth = panel.offsetWidth;
                    if (!menuWidth || menuWidth === 0) {
                        const declared = parseInt(getComputedStyle(panel).width || '0', 10);
                        menuWidth = declared > 0 ? declared : 320;
                    }
                    const padding = 6;
                    // Align to the right edge of the button
                    let left = Math.round(rect.right - menuWidth);
                    let top = Math.round(rect.bottom + padding);
                    const vw = window.innerWidth; const vh = window.innerHeight;
                    if (left + menuWidth > vw - 8) left = Math.max(8, vw - menuWidth - 8);
                    if (left < 8) left = 8;
                    const menuHeight = panel.offsetHeight || 0;
                    if (top > vh - 8) top = Math.max(8, rect.top - (menuHeight || 0) - padding);
                    panel.style.left = left + 'px';
                    panel.style.top = top + 'px';
                    panel.style.visibility = 'visible';
                    try { console.debug('[SDSM][UM] Dropdown positioned', { left, top, menuWidth, menuHeight, vw, vh }); } catch(_) {}
                }

                function openAccessDropdown(){
                    if (!accessDrop) return;
                    // Ensure overlay is not constrained by any parent stacking contexts
                    try {
                        if (accessDrop.parentElement !== document.body) {
                            document.body.appendChild(accessDrop);
                        }
                        accessDrop.style.position = 'fixed';
                    } catch(_) {}
                    ensureServersCache().then(() => {
                        accessList.innerHTML = '';
                        if (!serversCache || serversCache.length === 0) {
                            const msg = document.createElement('div');
                            msg.className = 'text-tertiary text-sm';
                            msg.textContent = 'No servers available '+ (newAssignAll ? '(all selected by default).' : '(create a server first).');
                            accessList.appendChild(msg);
                            try { console.warn('[SDSM][UM] No servers returned for access dropdown'); } catch(_) {}
                        } else {
                            serversCache.forEach(s => {
                                const lbl = document.createElement('label'); lbl.className='assign-chip';
                                const cb = document.createElement('input'); cb.type='checkbox'; cb.value=String(s.id); cb.checked = newAssignServers.has(Number(s.id)); cb.disabled = newAssignAll; cb.className='um-new-assign-cb';
                                cb.addEventListener('change', ()=>{ const id = Number(cb.value); if (cb.checked) newAssignServers.add(id); else newAssignServers.delete(id); });
                                const span = document.createElement('span'); span.textContent = s.name + ' (#'+s.id+')';
                                lbl.appendChild(cb); lbl.appendChild(span);
                                accessList.appendChild(lbl);
                            });
                            try { console.debug('[SDSM][UM] Populated access dropdown with '+serversCache.length+' servers'); } catch(_) {}
                        }
                        if (accessAll) {
                            accessAll.checked = newAssignAll;
                            accessAll.onchange = () => {
                                newAssignAll = accessAll.checked;
                                accessList.querySelectorAll('.um-new-assign-cb').forEach(el => { el.disabled = newAssignAll; });
                            };
                        }
                        // Show dropdown with active class for CSS transitions
                        accessDrop.classList.remove('hidden');
                        accessDrop.classList.add('active');
                        try { accessBtn.setAttribute('aria-expanded','true'); } catch(_) {}
                        positionDropdown(accessBtn, accessDrop);
                        function onDocClick(evt){
                            if (!accessDrop.contains(evt.target) && evt.target !== accessBtn && !accessBtn.contains(evt.target)) {
                                closeAccessDropdown();
                                document.removeEventListener('mousedown', onDocClick);
                                window.removeEventListener('resize', onResize);
                                window.removeEventListener('scroll', onResize, { passive: true });
                            }
                        }
                        function onResize(){ positionDropdown(accessBtn, accessDrop); }
                        document.addEventListener('mousedown', onDocClick);
                        window.addEventListener('resize', onResize);
                        window.addEventListener('scroll', onResize, { passive: true });
                    });
                }

                function closeAccessDropdown(){
                    if (!accessDrop) return;
                    // Hide and reset display so CSS can control visibility
                    accessDrop.classList.remove('active');
                    accessDrop.classList.add('hidden');
                    try { accessBtn.setAttribute('aria-expanded','false'); } catch(_) {}
                    try { accessDrop.style.display = 'none'; accessDrop.style.visibility = ''; } catch(_) {}
                }

                if (accessBtn) accessBtn.addEventListener('click', () => { if (!accessDrop.classList.contains('hidden')) closeAccessDropdown(); else openAccessDropdown(); });
                if (accessClose) accessClose.addEventListener('click', closeAccessDropdown);
                if (accessSave) accessSave.addEventListener('click', () => { closeAccessDropdown(); });

                function sortUsers(arr){
                    const k = sortState.key; const dir = sortState.dir === 'asc' ? 1 : -1;
                    const copy = arr.slice();
                    copy.sort((a,b)=>{
                        const av = (a[k] ?? '').toString().toLowerCase();
                        const bv = (b[k] ?? '').toString().toLowerCase();
                        if (av < bv) return -1*dir; if (av > bv) return 1*dir; return 0;
                    });
                    return copy;
                }

                function setCountBadge(n){ if (userCount) userCount.textContent = String(n); }

                function ensureVisibleOnFirstLoad(users){
                    if (!userToggleBtn || !userContent) return;
                    let hasPref = false; let pref = null;
                    try { pref = sessionStorage.getItem('sdsm:manager:user-mgmt:expanded'); hasPref = pref !== null; } catch(_) {}
                    if (!hasPref && Array.isArray(users) && users.length > 0) {
                        // Expand by default on first visit when we have data
                        userToggleBtn.setAttribute('aria-expanded','true');
                        userContent.classList.remove('hidden');
                        userContent.setAttribute('aria-hidden','false');
                        try { sessionStorage.setItem('sdsm:manager:user-mgmt:expanded','1'); } catch(_) {}
                    }
                }

                function renderUsers(users){
                    tbody.innerHTML = '';
                    if(!Array.isArray(users) || users.length === 0){
                        const tr = document.createElement('tr');
                        const td = document.createElement('td');
                        td.colSpan = 4;
                        td.textContent = 'No users found.';
                        tr.appendChild(td); tbody.appendChild(tr);
                        setCountBadge(0);
                        return;
                    }
                    setCountBadge(users.length);
                    sortUsers(users).forEach(u => {
                        const tr = document.createElement('tr');
                        const tdU = document.createElement('td'); tdU.textContent = u.username; tr.appendChild(tdU);
                        const tdR = document.createElement('td');
                        const sel = document.createElement('select'); sel.className='form-input-inline w-140';
                        ['admin','operator'].forEach(r => {
                            const opt = document.createElement('option'); opt.value=r; opt.textContent=r.charAt(0).toUpperCase()+r.slice(1);
                            if(String(u.role).toLowerCase()===r) opt.selected=true; sel.appendChild(opt);
                        });
                        sel.addEventListener('change', () => updateRole(u.username, sel.value));
                        tdR.appendChild(sel); tr.appendChild(tdR);
                        const tdC = document.createElement('td'); tdC.textContent = (u.created_at ? new Date(u.created_at).toLocaleString() : ''); tr.appendChild(tdC);
                        const tdA = document.createElement('td');
                        // Reset password button
                        const btnPw = document.createElement('button'); btnPw.className='btn btn-info';
                        btnPw.innerHTML = ICON_KEY + '<span class="ml-4">Set Password</span>';
                        btnPw.addEventListener('click', () => {
                            const p = prompt('Enter new password for '+u.username+':');
                            if(p && p.length>=8){ resetPassword(u.username, p); }
                            else if(p!==null){ if(window.showToast) window.showToast({type:'error', title:'Invalid', message:'Password must be at least 8 characters.'}); }
                        });
                        tdA.appendChild(btnPw);
                        // Delete button
                        const btnDel = document.createElement('button'); btnDel.className='btn btn-danger ml-2';
                        btnDel.innerHTML = ICON_TRASH + '<span class="ml-4">Delete</span>';
                                                btnDel.addEventListener('click', () => {
                                                        askConfirm({ title: 'Delete User', message: 'Delete user '+u.username+'?', confirmText: 'Delete', cancelText: 'Cancel', danger: true }, 'Delete user '+u.username+'?')
                                                            .then((ok) => { if (ok) deleteUser(u.username); });
                                                });
                        tdA.appendChild(btnDel);
                        // Assignments button (operators only)
                        const isOperator = String(u.role).toLowerCase() === 'operator';
                        if (isOperator) {
                            const btnAssign = document.createElement('button'); btnAssign.className='btn btn-info ml-2'; btnAssign.textContent='Assign Servers'; btnAssign.title='Manage server access for this operator';
                            btnAssign.addEventListener('click', () => openAssignPanel(u.username));
                            tdA.appendChild(btnAssign);
                        }
                        tr.appendChild(tdA);
                        tbody.appendChild(tr);
                    });
                }

                function fetchUsers(){
                    if(listBusy) return; listBusy = true;
                    const url = '/api/users';
                    if (tbody) {
                        tbody.innerHTML = '';
                        const tr = document.createElement('tr');
                        const td = document.createElement('td');
                        td.colSpan = 4; td.textContent = 'Loading…';
                        tr.appendChild(td); tbody.appendChild(tr);
                    }
                    fetch(url, {headers:{'Accept':'application/json'}, credentials:'same-origin'})
                        .then(r => r.ok ? r.json() : r.json().catch(()=>({error:'Request failed'})).then((d)=>Promise.reject(d)))
                        .then(data => { usersData = Array.isArray(data.users)? data.users : []; ensureVisibleOnFirstLoad(usersData); renderUsers(usersData); })
                        .catch((err)=>{
                            try { console.error('[SDSM] Failed to load users', err); } catch(_) {}
                            if (tbody) {
                                tbody.innerHTML = '';
                                const tr = document.createElement('tr');
                                const td = document.createElement('td');
                                td.colSpan = 4; td.textContent = 'Failed to load users.';
                                tr.appendChild(td); tbody.appendChild(tr);
                            }
                            if (window.showToast) window.showToast({ type:'error', title:'Load Failed', message: (err && err.error) || 'Unable to load users' });
                            setCountBadge(0);
                        })
                        .finally(()=>{ listBusy=false; });
                }

                function updateRole(username, role){
                    fetch('/api/users/'+encodeURIComponent(username)+'/role', {
                        method:'PATCH', credentials:'same-origin', headers:{'Content-Type':'application/json','Accept':'application/json'},
                        body: JSON.stringify({role})
                    }).then(r => r.ok ? r.json() : r.json().then(Promise.reject))
                      .then(()=>{ if(window.showToast) window.showToast({type:'success', title:'Role Updated', message: username+" → "+role}); fetchUsers(); })
                      .catch(err=>{ if(window.showToast) window.showToast({type:'error', title:'Update Failed', message: (err&&err.error)||'Unable to update role'}); fetchUsers(); });
                }

                function resetPassword(username, password){
                    fetch('/api/users/'+encodeURIComponent(username)+'/reset-password', {
                        method:'POST', credentials:'same-origin', headers:{'Content-Type':'application/json','Accept':'application/json'},
                        body: JSON.stringify({password})
                    }).then(r => r.ok ? r.json() : r.json().then(Promise.reject))
                      .then(()=>{ if(window.showToast) window.showToast({type:'success', title:'Password Set', message: 'Password updated for '+username}); })
                      .catch(err=>{ if(window.showToast) window.showToast({type:'error', title:'Set Failed', message: (err&&err.error)||'Unable to set password'}); });
                }

                function deleteUser(username){
                    fetch('/api/users/'+encodeURIComponent(username), { method:'DELETE', credentials:'same-origin', headers:{'Accept':'application/json'} })
                      .then(r => r.ok ? r.json() : r.json().then(Promise.reject))
                      .then(()=>{ if(window.showToast) window.showToast({type:'success', title:'User Deleted', message: username}); fetchUsers(); })
                      .catch(err=>{ if(window.showToast) window.showToast({type:'error', title:'Delete Failed', message: (err&&err.error)||'Unable to delete user'}); fetchUsers(); });
                }

                const addForm = document.getElementById('um_add_form');
                if(addForm && addBtn && newUser && newPass && newRole){
                    const handleSubmit = (evt) => {
                        evt.preventDefault();
                        const u = newUser.value.trim(); const p = newPass.value; const r = newRole.value;
                        if(u.length < 3){ if(window.showToast) window.showToast({type:'error', title:'Invalid', message:'Username must be at least 3 characters.'}); return; }
                        if(p.length < 8){ if(window.showToast) window.showToast({type:'error', title:'Invalid', message:'Password must be at least 8 characters.'}); return; }
                        addBtn.disabled = true;
                        fetch('/api/users', {
                            method:'POST', credentials:'same-origin', headers:{'Content-Type':'application/json','Accept':'application/json'},
                            body: JSON.stringify({username:u, password:p, role:r})
                        }).then(r => r.ok ? r.json() : r.json().then(Promise.reject))
                          .then(()=>{
                              const doAssign = (r === 'operator');
                              const payload = { all: newAssignAll, servers: Array.from(newAssignServers) };
                              const assign = doAssign ? fetch('/api/users/'+encodeURIComponent(u)+'/assignments', { method:'POST', credentials:'same-origin', headers:{'Content-Type':'application/json','Accept':'application/json'}, body: JSON.stringify(payload) }) : Promise.resolve();
                              return assign.then(() => {
                                  if(window.showToast) window.showToast({type:'success', title:'User Added', message: u});
                                  newUser.value=''; newPass.value=''; newRole.value='operator';
                                  newAssignAll = false; newAssignServers.clear(); closeAccessDropdown();
                                  fetchUsers();
                              });
                          })
                          .catch(err=>{ if(window.showToast) window.showToast({type:'error', title:'Add Failed', message: (err&&err.error)||'Unable to add user'}); })
                          .finally(()=>{ addBtn.disabled = false; });
                    };
                    addForm.addEventListener('submit', handleSubmit);
                    // Fallback: retain click handler if someone triggers button programmatically
                    addBtn.addEventListener('click', (e)=>{ if(addBtn.type !== 'submit'){ handleSubmit(e); } });
                }
                // Toggle server access control visibility by role (optional UX)
                if (newRole && accessBtn) {
                    const updateAccessVisibility = () => {
                        const isOp = newRole.value === 'operator';
                        accessBtn.classList.toggle('hidden', !isOp);
                        if (!isOp) closeAccessDropdown();
                    };
                    newRole.addEventListener('change', updateAccessVisibility);
                    updateAccessVisibility();
                }

                // Sorting handlers
                document.querySelectorAll('th.um-sort').forEach(th => {
                    th.addEventListener('click', () => {
                        const key = th.dataset.key;
                        if (sortState.key === key) sortState.dir = (sortState.dir === 'asc') ? 'desc' : 'asc';
                        else { sortState.key = key; sortState.dir = 'asc'; }
                        renderUsers(usersData);
                    });
                });
                // Initial load
                if (tbody && !tbody.innerHTML.trim()) {
                    const tr = document.createElement('tr');
                    const td = document.createElement('td');
                    td.colSpan = 4; td.textContent = 'Loading…';
                    tr.appendChild(td); tbody.appendChild(tr);
                }
                fetchUsers();
            })();

            // Initial progress fetch
            fetchProgress();
            ensurePolling();
            // Manager Port Forwarding status UI
            (function(){
                try {
                    const pfToggle = document.getElementById('auto_port_forward_manager');
                    const extras = document.getElementById('mgr_pf_extras');
                    const statusEl = document.getElementById('mgr_pf_status');
                    const ipEl = document.getElementById('mgr_external_ip');
                    const testBtn = document.getElementById('mgr_test_port');
                    function setStatus(kind, label){
                        if (!statusEl) return;
                        statusEl.className = 'status-pill ' + (kind==='active'?'status-success':kind==='error'?'status-error':kind==='pending'?'status-warning':'status-secondary');
                        statusEl.innerHTML = '<span class="dot" aria-hidden="true"></span>' + (label||'');
                    }
                    function refreshMgrStatus(){
                        fetch('/api/manager/status', { headers:{'Accept':'application/json'}, credentials:'same-origin', cache:'no-store' })
                          .then(r=> r.ok ? r.json() : null)
                          .then(data => {
                              if (!data) return;
                              if (pfToggle) pfToggle.checked = !!data.auto_port_forward_manager;
                              const enabled = !!data.auto_port_forward_manager;
                              if (extras) extras.style.display = enabled ? '' : 'none';
                              if (ipEl && data.external_ip) ipEl.textContent = data.external_ip || '--';
                              if (enabled) {
                                  if (data.manager_port_forward_active) {
                                      const ext = data.manager_port_forward_external_port || '';
                                      setStatus('active', 'Active' + (ext?(' ('+ext+')'):''));
                                  } else if (data.manager_port_forward_last_error) {
                                      setStatus('error', 'Error');
                                  } else {
                                      setStatus('pending', 'Pending');
                                  }
                              } else {
                                  setStatus('secondary', 'Disabled');
                              }
                          })
                          .catch(()=>{});
                    }
                    refreshMgrStatus();
                    setInterval(refreshMgrStatus, 15000);
                    if (testBtn) {
                        testBtn.addEventListener('click', ()=>{
                            testBtn.disabled = true;
                            fetch('/api/manager/test-port', { headers:{'Accept':'application/json'}, credentials:'same-origin' })
                              .then(r=>{ if(window.showToast) { try { const t=r.headers.get('X-Toast-Type'); const title=r.headers.get('X-Toast-Title'); const msg=r.headers.get('X-Toast-Message'); if(msg) window.showToast({type:t||'info', title:title||'', message:msg}); } catch(_){} } return r.json().catch(()=>({})); })
                              .then(()=> refreshMgrStatus())
                              .finally(()=>{ testBtn.disabled = false; });
                        });
                    }
                } catch(_) {}
            })();
            }); // DOMContentLoaded end
        })();
    </script>
</head>

<body class="page-shell" data-detached="{{if .detached}}true{{else}}false{{end}}">
    <div id="connectionBanner" class="connection-banner" role="status" aria-live="polite">
        <span id="connectionBannerText">Connection lost. Attempting to reconnect...</span>
        <button type="button" id="connectionBannerAction">Reload</button>
    </div>
    
    <div class="container">
    <header class="hero-card">
        <div class="hero-main">
            <img src="/sdsm.png" alt="SDSM logo" class="hero-logo" width="72" height="72">
            <div class="hero-heading">
                <h1 class="hero-title">Server Manager</h1>
                <p class="hero-subtitle">Configure and update your Stationeers servers.</p>
            </div>
        </div>
        <div class="hero-meta">
            <div class="hero-meta-title">Fleet Overview</div>
            <p class="hero-meta-text">
                <span id="header-total-servers">--</span> server<span id="header-total-servers-suffix">s</span> tracked •
                <span id="header-active-servers">--</span> active •
                <span id="header-total-players">--</span> players
            </p>
            <span class="pill">Last refresh: <span id="last-refresh">just now</span></span>
        </div>
        <div class="hero-actions flex-col items-end">
            <div class="row wrap">
            <button class="theme-toggle" onclick="toggleTheme()" aria-label="Toggle theme">
                <span id="theme-icon">🌙</span>
            </button>
            <button type="button" id="bugReportBtn" class="btn btn-info" title="Report a bug to SDSM">Report Bug</button>
            <button
                class="btn btn-primary"
                hx-get="/api/refresh"
                hx-trigger="click"
                hx-indicator="#manager-refresh-indicator"
                hx-swap="none"
            >
                <svg class="icon-inline" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                    <polyline points="23 4 23 10 17 10"></polyline>
                    <polyline points="1 20 1 14 7 14"></polyline>
                    <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10"></path>
                    <path d="M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
                </svg>
                <span id="manager-refresh-indicator" class="hidden">⟳</span>
                Refresh
            </button>
            <a href="/dashboard" class="btn btn-primary" title="Go to Dashboard">
                {{ template "icon_dashboard" . }}
                Dashboard
            </a>
            {{ template "user_menu" . }}
            </div>
            <span class="build-meta">{{buildTime}}</span>
        </div>
    </header>
    </div>

    <main class="container">
        {{ if .game_data_warnings }}
        {{ if gt (len .game_data_warnings) 0 }}
        <div class="alert alert-warning mb-4" role="status" aria-live="polite">
            <div class="alert-icon" aria-hidden="true">
                <svg class="icon-inline" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"></circle>
                    <line x1="12" y1="8" x2="12" y2="12"></line>
                    <line x1="12" y1="16" x2="12" y2="16"></line>
                </svg>
            </div>
            <div class="alert-content">
                <div class="alert-title">Game data missing</div>
                <ul class="alert-message m-0 pl-5">{{range .game_data_warnings}}<li>{{.}}</li>{{end}}</ul>
            </div>
        </div>
        {{ end }}
        {{ end }}
        <div class="manager-content">
            <div class="manager-grid">
                <div class="glass-card">
                    <h3>Configuration</h3>
                    <form id="configForm" class="config-form" action="/update" method="POST">
                        <div class="form-group">
                            <label for="steam_id">Steam ID</label>
                            <input type="text" id="steam_id" name="steam_id" value="{{ .steam_id }}" required>
                        </div>
                        <div class="form-group">
                            <label for="port">Port</label>
                            <input type="text" id="port" name="port" value="{{ .port }}" required>
                        </div>
                        <div class="form-group">
                            <label for="discord_default_webhook">Discord Notifications Webhook</label>
                            <input type="text" id="discord_default_webhook" name="discord_default_webhook" value="{{ .discord_default_webhook }}" placeholder="https://discord.com/api/webhooks/...">
                        </div>
                        <div class="form-group">
                            <label for="discord_bug_report_webhook">SDSM Bug Report Webhook</label>
                            <input type="text" id="discord_bug_report_webhook" name="discord_bug_report_webhook" value="{{ .discord_bug_report_webhook }}" placeholder="https://discord.com/api/webhooks/...">
                        </div>
                        <div class="form-group top-align">
                            <label for="auto_port_forward_manager">Port Forward (Manager)</label>
                            <div class="field-inline items-start gap-2">
                                <input type="checkbox" id="auto_port_forward_manager" name="auto_port_forward_manager" class="form-checkbox" {{if .auto_port_forward_manager}}checked{{end}}>
                                <span class="text-secondary text-sm flex-1" aria-live="polite">
                                    <span class="pill pill-sm" title="Forwarding behavior is adaptive">Adaptive</span>
                                    Attempt automatic router port forwarding (TCP) for the manager's web port via UPnP/NAT-PMP.
                                    <br><strong class="text-danger">WARNING:</strong> Exposing the management UI to the internet can be risky — enable only if you understand the implications.
                                </span>
                            </div>
                        </div>
                        <div class="form-group top-align" id="mgr_pf_extras" style="display:none;">
                            <label>External Access</label>
                            <div class="field-inline items-start gap-2">
                                <span class="status-pill" id="mgr_pf_status"><span class="dot" aria-hidden="true"></span>Status</span>
                                <span class="text-secondary text-sm">External IP: <span id="mgr_external_ip">--</span></span>
                                <button type="button" id="mgr_test_port" class="btn btn-info btn-min-sm">Test Port</button>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="root_path">Root Path</label>
                            <input type="text" id="root_path" name="root_path" value="{{ .root_path }}" required>
                        </div>
                        <div class="form-group">
                            <label for="auto_update">Auto Update Time</label>
                            <input type="text" id="auto_update" name="auto_update" value="{{ .auto_update }}" required>
                        </div>
                        <div class="form-group top-align">
                            <label for="start_update">Update at Start</label>
                            <div class="field-inline items-start gap-2">
                                <input type="checkbox" id="start_update" name="start_update" class="form-checkbox" {{if .start_update}}checked{{end}}>
                                <span class="text-secondary text-sm flex-1" aria-live="polite">
                                    When enabled, SDSM will check and apply updates automatically on startup.
                                </span>
                            </div>
                        </div>
                        <div class="form-group top-align">
                            <label for="tls_enabled">HTTPS (TLS)</label>
                            <div class="field-inline items-start gap-2">
                                <input type="checkbox" id="tls_enabled" name="tls_enabled" class="form-checkbox" {{if .tls_enabled}}checked{{end}}>
                                <span class="text-secondary text-sm flex-1" aria-live="polite">
                                    Enable HTTPS using managed certificate assets under <code>certs/</code> (restart required).
                                </span>
                            </div>
                        </div>
                        <div class="form-group top-align">
                            <label>HTTPS Status</label>
                            <div class="field-inline items-start gap-2">
                                <span class="status-pill status-{{if .tls_enabled}}success{{else}}secondary{{end}}"><span class="dot" aria-hidden="true"></span>{{if .tls_enabled}}Enabled{{else}}Disabled{{end}}</span>
                                {{ if .tls_enabled }}
                                <span class="text-secondary text-sm" aria-live="polite">Using <code>certs/sdsm.crt</code> and <code>certs/sdsm.key</code></span>
                                {{ else }}
                                <span class="text-secondary text-sm" aria-live="polite">Provide certificate + key sources below and check Enable to activate.</span>
                                {{ end }}
                            </div>
                        </div>
                        <div class="form-group top-align">
                            <label for="generate_tls_self_signed">Advanced TLS</label>
                            <div class="flex-col gap-3">
                                <button id="generate_tls_self_signed" type="submit" name="generate_tls_self_signed" class="btn btn-info mb-2" data-tls-enabled="{{if .tls_enabled}}true{{else}}false{{end}}" title="{{if .tls_enabled}}Regenerate and replace the existing certificate{{else}}Generate a new self-signed certificate{{end}}">
                                    <svg class="icon-inline" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                                        <path d="M12 17a2 2 0 1 0 0-4 2 2 0 0 0 0 4Z"></path>
                                        <path d="M19 11a7 7 0 1 0-14 0v2H5a2 2 0 0 0-2 2v3a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-3a2 2 0 0 0-2-2h0v-2Z"></path>
                                    </svg>
                                    {{if .tls_enabled}}Regenerate Cert{{else}}Generate Cert{{end}}
                                </button>
                                <details class="w-full">
                                    <summary class="cursor-pointer text-secondary">Source Paths</summary>
                                    <div class="mt-2">
                                        <label for="tls_cert" class="text-secondary text-sm">Certificate Source</label>
                                        <input type="text" id="tls_cert" name="tls_cert" value="{{ .tls_cert }}" placeholder="C:\\path\\to\\cert.pem" class="mt-1 mb-3">
                                        <label for="tls_key" class="text-secondary text-sm">Private Key Source</label>
                                        <input type="text" id="tls_key" name="tls_key" value="{{ .tls_key }}" placeholder="C:\\path\\to\\key.pem" class="mt-1">
                                        <p class="text-secondary text-xs mt-3">Paths are treated as sources and copied into <code>certs/</code> as <code>sdsm.crt</code> / <code>sdsm.key</code>. Files must be valid PEM.</p>
                                    </div>
                                </details>
                            </div>
                        </div>
                        {{ if .tls_generated }}
                        <div class="alert alert-success" role="status" aria-live="polite">
                            <div class="alert-icon" aria-hidden="true">
                                <svg class="icon-inline" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <polyline points="20 6 9 17 4 12"></polyline>
                                </svg>
                            </div>
                            <div class="alert-content">
                                <div class="alert-title">TLS certificate created</div>
                                <div class="alert-message">Paths updated and HTTPS enabled. Restart SDSM to serve over HTTPS.</div>
                            </div>
                        </div>
                        {{ end }}
                        <div class="form-group top-align">
                            <label for="detached_servers">Detached Servers (keep running if SDSM exits)</label>
                            <div class="field-inline items-start gap-2">
                                <input type="checkbox" id="detached_servers" name="detached_servers" class="form-checkbox" {{if .detached}}checked{{end}}>
                                <span class="text-secondary text-sm flex-1" aria-live="polite">
                                    When enabled, servers are started in a separate process group and will continue running if SDSM is stopped.
                                </span>
                            </div>
                        </div>
                        <div class="form-group top-align">
                            <label for="tray_enabled">Windows Tray Icon</label>
                            <div class="field-inline items-start gap-2">
                                <input type="checkbox" id="tray_enabled" name="tray_enabled" class="form-checkbox" {{if .tray_enabled}}checked{{end}}>
                                <span class="text-secondary text-sm flex-1" aria-live="polite">
                                    When enabled (Windows only), SDSM runs with a system tray icon for quick access and background operation.
                                </span>
                            </div>
                        </div>
                        <div class="form-group form-row-full">
                            <button id="updateConfigBtn" type="submit" name="update_config" class="btn btn-primary" {{if .updating}}disabled{{end}}>
                                <svg class="icon-inline" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
                                    <polyline points="17 21 17 13 7 13 7 21"></polyline>
                                    <polyline points="7 3 7 8 15 8"></polyline>
                                </svg>
                                Update Config
                            </button>
                        </div>
                    </form>
                    <div class="note">
                        <strong>Note:</strong> After updating the configuration, SDSM may restart so changes can take effect.
                    </div>
                </div>

                <div class="glass-card">
                    {{/* Always render versions section; rely on dynamic polling instead of full hide to keep buttons re-enabled post-load. */}}
                    {{/* If updating, we'll disable buttons but keep table visible for user feedback. */}}
                    <div id="versions" data-initial-updating="{{if .updating}}true{{else}}false{{end}}">
                        {{/* Legacy conditional wrapper removed (was: if not .updating) */}}
                        <h3>Software Versions</h3>
                        <form action="/update" method="POST" id="updateForm">
                            <div class="table-container">
                                <table>
                                    <thead>
                                        <tr>
                                            <th>Component</th>
                                            <th>Deployed</th>
                                            <th>Latest</th>
                                            <th>Action</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        
                                        <tr>
                                            <td>
                                                <div class="component-title">steamcmd</div>
                                                <div class="progress-row" data-progress="steamcmd">
                                                    <div class="progress-bar"><div class="progress-fill"></div></div>
                                                    <div class="progress-text"></div>
                                                </div>
                                            </td>
                                            <td id="ver-steamcmd-deployed">Loading…</td>
                                            <td id="ver-steamcmd-latest">Loading…</td>
                                            <td>
                                                <button type="submit" name="update_steamcmd" data-update-target="update_steamcmd" data-component="steamcmd" class="btn btn-neutral update-trigger" {{if .updating}}disabled{{end}}>
                                                    <svg class="icon-inline" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                                        <path d="M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8"></path>
                                                        <path d="M21 3v5h-5"></path>
                                                    </svg>
                                                    Update
                                                </button>
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>
                                                <div class="component-title">rocketstation_DedicatedServer Release</div>
                                                <div class="progress-row" data-progress="release">
                                                    <div class="progress-bar"><div class="progress-fill"></div></div>
                                                    <div class="progress-text"></div>
                                                </div>
                                            </td>
                                            <td id="ver-release-deployed">Loading…</td>
                                            <td id="ver-release-latest">Loading…</td>
                                            <td>
                                                <button type="submit" name="update_release" data-update-target="update_release" data-component="release" class="btn btn-neutral update-trigger" {{if .updating}}disabled{{end}}>
                                                    <svg class="icon-inline" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                                        <path d="M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8"></path>
                                                        <path d="M21 3v5h-5"></path>
                                                    </svg>
                                                    Update
                                                </button>
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>
                                                <div class="component-title">rocketstation_DedicatedServer Beta</div>
                                                <div class="progress-row" data-progress="beta">
                                                    <div class="progress-bar"><div class="progress-fill"></div></div>
                                                    <div class="progress-text"></div>
                                                </div>
                                            </td>
                                            <td id="ver-beta-deployed">Loading…</td>
                                            <td id="ver-beta-latest">Loading…</td>
                                            <td>
                                                <button type="submit" name="update_beta" data-update-target="update_beta" data-component="beta" class="btn btn-neutral update-trigger" {{if .updating}}disabled{{end}}>
                                                    <svg class="icon-inline" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                                        <path d="M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8"></path>
                                                        <path d="M21 3v5h-5"></path>
                                                    </svg>
                                                    Update
                                                </button>
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>
                                                <div class="component-title">BEPINEX</div>
                                                <div class="progress-row" data-progress="bepinex">
                                                    <div class="progress-bar"><div class="progress-fill"></div></div>
                                                    <div class="progress-text"></div>
                                                </div>
                                            </td>
                                            <td id="ver-bepinex-deployed">Loading…</td>
                                            <td id="ver-bepinex-latest">Loading…</td>
                                            <td>
                                                <button type="submit" name="update_bepinex" data-update-target="update_bepinex" data-component="bepinex" class="btn btn-neutral update-trigger" {{if .updating}}disabled{{end}}>
                                                    <svg class="icon-inline" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                                        <path d="M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8"></path>
                                                        <path d="M21 3v5h-5"></path>
                                                    </svg>
                                                    Update
                                                </button>
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>
                                                <div class="component-title">Stationeers LaunchPad</div>
                                                <div class="progress-row" data-progress="launchpad">
                                                    <div class="progress-bar"><div class="progress-fill"></div></div>
                                                    <div class="progress-text"></div>
                                                </div>
                                            </td>
                                            <td id="ver-launchpad-deployed">Loading…</td>
                                            <td id="ver-launchpad-latest">Loading…</td>
                                            <td>
                                                <button type="submit" name="update_launchpad" data-update-target="update_launchpad" data-component="launchpad" class="btn btn-neutral update-trigger" {{if .updating}}disabled{{end}}>
                                                    <svg class="icon-inline" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                                        <path d="M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8"></path>
                                                        <path d="M21 3v5h-5"></path>
                                                    </svg>
                                                    Update
                                                </button>
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>
                                                <div class="component-title">SCON</div>
                                                <div class="progress-row" data-progress="scon">
                                                    <div class="progress-bar"><div class="progress-fill"></div></div>
                                                    <div class="progress-text"></div>
                                                </div>
                                            </td>
                                            <td id="ver-scon-deployed">Loading…</td>
                                            <td id="ver-scon-latest">Loading…</td>
                                            <td>
                                                <button type="submit" name="update_scon" data-update-target="update_scon" data-component="scon" class="btn btn-neutral update-trigger" {{if .updating}}disabled{{end}}>
                                                    <svg class="icon-inline" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                                        <path d="M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8"></path>
                                                        <path d="M21 3v5h-5"></path>
                                                    </svg>
                                                    Update
                                                </button>
                                            </td>
                                        </tr>
                                        <tr>
                                            <td colspan="3"></td>
                                            <td>
                                                <button type="submit" name="update_all" data-update-target="update_all" data-component="all" class="btn btn-primary update-trigger" {{if .updating}}disabled{{end}}>
                                                    Update All
                                                </button>
                                                <div id="updateMessage" class="update-message" role="status" aria-live="polite"></div>
                                            </td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </form>
                    </div>
                </div>
            </div>
            
            <div class="glass-card" id="userMgmtCard">
                <div class="card-header">
                    <h3 class="card-title m-0">User Management</h3>
                    <div class="status-badges">
                        <span class="pill" title="Total users">Users: <span id="userMgmtCount">--</span></span>
                    </div>
                    <button type="button" id="userMgmtToggle" class="btn btn-ghost btn-min-sm" aria-expanded="false" aria-controls="userMgmtContent" title="Expand">
                        <svg id="userMgmtChevron" class="icon-inline" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        <span id="userMgmtToggleLabel" class="ml-6">More</span>
                    </button>
                </div>
                <div id="userMgmtContent" class="card-body hidden" aria-hidden="true">
                    <div class="form-grid-compact mb-3">
                        <div class="form-group">
                            <label>Add User</label>
                            <form id="um_add_form" class="inline-controls" autocomplete="on">
                                <input id="um_new_username" name="username" type="text" class="form-input-inline" placeholder="username" minlength="3" required autocomplete="username" />
                                <input id="um_new_password" name="password" type="password" class="form-input-inline" placeholder="password (min 8)" minlength="8" required autocomplete="new-password" />
                                <select id="um_new_role" name="role" class="form-input-inline w-120 min-w-120">
                                    <option value="admin">Admin</option>
                                    <option value="operator" selected>Operator</option>
                                </select>
                                <button type="button" id="um_access_btn" class="btn btn-info min-w-120 nowrap" title="Choose servers for this operator">Servers ▾</button>
                                <button type="submit" id="um_add_btn" class="btn btn-primary">{{ template "icon_add" . }} <span class="ml-4">Add</span></button>
                            </form>
                            <div id="um_access_dropdown" class="glass-card dropdown-panel hidden w-340">
                                <div class="row justify-between mb-2">
                                    <strong>Server Access</strong>
                                    <button type="button" id="um_access_close" class="btn btn-min-sm btn-ghost">Close</button>
                                </div>
                                <div class="form-group mb-2">
                                    <label class="inline-flex items-center gap-2"><input type="checkbox" id="um_access_all"> All servers</label>
                                </div>
                                <div id="um_access_list" class="assign-list"></div>
                                <div class="row justify-end mt-2 gap-2">
                                    <button type="button" id="um_access_save" class="btn btn-primary">Save</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="table-container">
                        <table>
                            <thead>
                                <tr>
                                    <th class="um-sort cursor-pointer" data-key="username">Username</th>
                                    <th class="um-sort cursor-pointer" data-key="role">Role</th>
                                    <th class="um-sort cursor-pointer" data-key="created_at">Created</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody id="um_table_body"></tbody>
                        </table>
                    </div>
                </div>
            </div>
            <script>
                // Robust, localized toggle for User Management card
                (function(){
                    try {
                        const btn = document.getElementById('userMgmtToggle');
                        const body = document.getElementById('userMgmtContent');
                        const chevron = document.getElementById('userMgmtChevron');
                        const label = document.getElementById('userMgmtToggleLabel');
                        if (!btn || !body) return;
                        const setState = (expanded) => {
                            btn.setAttribute('aria-expanded', expanded ? 'true' : 'false');
                            body.classList.toggle('hidden', !expanded);
                            body.setAttribute('aria-hidden', expanded ? 'false' : 'true');
                            if (label) label.textContent = expanded ? 'Less' : 'More';
                            if (chevron) chevron.innerHTML = expanded ? '<polyline points="6 15 12 9 18 15"></polyline>' : '<polyline points="6 9 12 15 18 9"></polyline>';
                            try { sessionStorage.setItem('sdsm:manager:user-mgmt:expanded', expanded ? '1' : '0'); } catch(_) {}
                        };
                        let initial = '1'; // default to expanded on first visit
                        try { const stored = sessionStorage.getItem('sdsm:manager:user-mgmt:expanded'); if (stored !== null) initial = stored; } catch(_) {}
                        setState(initial === '1');
                        btn.addEventListener('click', function(){
                            const expanded = btn.getAttribute('aria-expanded') === 'true';
                            setState(!expanded);
                        });
                    } catch(_) {}
                })();
            </script>

            <div class="glass-card" id="manageLogsCard">
                <div class="card-header">
                    <h3 class="card-title m-0">Manage Logs</h3>
                    <button type="button" id="manageLogsToggle" class="btn btn-ghost btn-min-sm" aria-expanded="true" aria-controls="manageLogsContent" title="Collapse">
                        <svg id="manageLogsChevron" class="icon-inline" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><polyline points="6 15 12 9 18 15"></polyline></svg>
                        <span id="manageLogsToggleLabel" class="ml-6">Less</span>
                    </button>
                </div>
                <div id="manageLogsContent" class="card-body" aria-hidden="false">
                    <div class="control-actions mb-3">
                        <div class="button-group">
                            <button type="button" id="ml-refresh" class="btn btn-info">
                                <svg class="icon-inline" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                                    <path d="M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8"/>
                                    <path d="M21 3v5h-5"/>
                                </svg>
                                <span class="ml-6">Refresh</span>
                            </button>
                            <button type="button" id="ml-download" class="btn btn-info">
                                <svg class="icon-inline" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                                    <polyline points="7 10 12 15 17 10"/>
                                    <line x1="12" y1="15" x2="12" y2="3"/>
                                </svg>
                                <span class="ml-6">Download</span>
                            </button>
                            <button type="button" id="ml-clear" class="btn btn-danger">
                                <svg class="icon-inline" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                                    <polyline points="3 6 5 6 21 6"/>
                                    <path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"/>
                                    <path d="M10 11v6"/>
                                    <path d="M14 11v6"/>
                                    <path d="M9 6V4a2 2 0 0 1 2-2h2a2 2 0 0 1 2 2v2"/>
                                </svg>
                                <span class="ml-6">Clear</span>
                            </button>
                        </div>
                    </div>
                    <div class="logs-grid">
                        <div class="log-viewer" id="manager-log-viewer" aria-live="polite" aria-label="Manager log output" role="region"></div>
                        <div class="log-tabs" id="manager-log-tabs" aria-label="Log files">
                            <div class="empty-state" id="manager-log-tabs-empty">No log files found</div>
                        </div>
                    </div>
                </div>
            </div>

            
            <div class="glass-card">
                <p>There are <strong id="server-count-running">{{.server_count_active}}</strong> servers currently running.</p>
                <div class="button-group centered gap-3 mt-4">
                    <form id="footerActionsForm" action="/update" method="POST" class="display-contents">
                        <button id="shutdownBtn" type="submit" name="shutdown" value="1" class="btn btn-danger" {{if .updating}}disabled{{end}}>
                            <svg class="icon-inline" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M18.36 6.64a9 9 0 1 1-12.73 0"></path>
                                <line x1="12" y1="2" x2="12" y2="12"></line>
                            </svg>
                            Shutdown SDSM
                        </button>
                        <button id="restartBtn" type="submit" name="restart" value="1" class="btn btn-primary" {{if .updating}}disabled{{end}}>
                            <svg class="icon-inline" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="23 4 23 10 17 10"></polyline>
                                <polyline points="1 20 1 14 7 14"></polyline>
                                <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
                            </svg>
                            Restart SDSM
                        </button>
                        <button id="stopAllBtn" type="button" class="btn btn-warning" {{if or .updating (eq .server_count_active 0)}}disabled{{end}} title="Stop all running servers">
                            <svg class="icon-inline" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                                <line x1="9" y1="9" x2="15" y2="9"></line>
                                <line x1="9" y1="15" x2="15" y2="15"></line>
                            </svg>
                            Stop All Servers
                        </button>
                    </form>
                    <!-- View Log button removed; replaced by Manage Logs card -->
                </div>
            </div>
        </div>
    </main>

    <script>
        (function () {
            const HEALTH_ENDPOINT = '/healthz';
            const HEALTH_TIMEOUT = 4000; // base timeout per request
            const INTERVAL_OK = 15000;   // cadence when healthy
            const INTERVAL_LOST = 5000;  // cadence when unhealthy
            const INITIAL_GRACE_MS = 3500; // time after page load before we allow banner display
            const FAILURE_THRESHOLD = 2;   // consecutive failures required (after grace) before showing banner
            const FIRST_TIMEOUT_FACTOR = 1.75; // extend first timeout to reduce false aborts under load

            let healthTimer = null;
            let connectionLost = false;
            let consecutiveFailures = 0;
            let firstCheck = true;
            let startTs = Date.now();
            let attempts = 0;

            function setBanner(active, message) {
                const banner = document.getElementById('connectionBanner');
                const text = document.getElementById('connectionBannerText');
                if (!banner) {
                    return;
                }
                if (active) {
                    banner.classList.add('active');
                    if (text && message) {
                        text.textContent = message;
                    }
                    document.body.style.paddingTop = '4rem';
                } else {
                    banner.classList.remove('active');
                    document.body.style.paddingTop = '';
                }
            }

            function scheduleNext(delay) {
                // Query locally; avoid relying on other script scopes
                const stopAllBtn = document.getElementById('stopAllBtn');
                if (stopAllBtn) {
                    // Initialize disabled state based on current running count
                    try {
                        const rcEl = document.getElementById('server-count-running');
                        const rc = rcEl ? parseInt(rcEl.textContent || '0', 10) : 0;
                        if (rc === 0) stopAllBtn.disabled = true;
                    } catch(_) {}
                    clearTimeout(healthTimer);
                }
                healthTimer = setTimeout(runHealthCheck, delay);
            }

            function runHealthCheck() {
                attempts++;
                const controller = new AbortController();
                // Extend timeout for the very first attempt (server might still be warming caches / IO)
                const effectiveTimeout = firstCheck ? Math.round(HEALTH_TIMEOUT * FIRST_TIMEOUT_FACTOR) : HEALTH_TIMEOUT;
                const timeoutId = setTimeout(() => controller.abort(), effectiveTimeout);

                fetch(HEALTH_ENDPOINT, {
                    cache: 'no-store',
                    credentials: 'same-origin',
                    signal: controller.signal
                })
                    .then((response) => {
                        clearTimeout(timeoutId);
                        if (!response.ok) {
                            throw new Error('Health check failed');
                        }
                        if (connectionLost) {
                            connectionLost = false;
                            // With zero running, keep button disabled post-success
                            const btn = document.getElementById('stopAllBtn');
                            if (btn) {
                                const rcEl = document.getElementById('server-count-running');
                                const rc = rcEl ? parseInt(rcEl.textContent || '0', 10) : 0;
                                btn.disabled = (rc === 0);
                            }
                            setBanner(true, 'Connection restored. Reloading...');
                            setTimeout(() => {
                                setBanner(false);
                                window.location.reload();
                            }, 1200);
                            return;
                        }
                        // Healthy: reset failure counters
                        consecutiveFailures = 0;
                        firstCheck = false;
                        // If still servers running, re-enable; otherwise remains disabled
                        const stopAllBtn = document.getElementById('stopAllBtn');
                        const rcEl2 = document.getElementById('server-count-running');
                        const rc2 = rcEl2 ? parseInt(rcEl2.textContent || '0', 10) : 0;
                        if (stopAllBtn) stopAllBtn.disabled = (rc2 === 0);
                    })
                    .catch(() => {
                        clearTimeout(timeoutId);
                        consecutiveFailures++;
                        const elapsed = Date.now() - startTs;
                        // Determine if we should surface the banner yet
                        const withinGrace = elapsed < INITIAL_GRACE_MS;
                        const belowThreshold = consecutiveFailures < FAILURE_THRESHOLD;
                        if (!connectionLost) {
                            if (!withinGrace && !belowThreshold) {
                                connectionLost = true;
                                setBanner(true, 'Connection lost. Attempting to reconnect...');
                            } else {
                                // Still treat as lost internally for scheduling (short cadence) but do not show banner
                                // Keep connectionLost false so recovery logic doesn't auto-reload prematurely
                                // Optionally could add subtle console info
                                try { console.debug('[SDSM][Health] Suppressing banner (fail '+consecutiveFailures+', grace='+withinGrace+')'); } catch(_) {}
                            }
                        }
                        firstCheck = false;
                    })
                    .finally(() => {
                        scheduleNext(connectionLost ? INTERVAL_LOST : INTERVAL_OK);
                    });
            }

            document.addEventListener('DOMContentLoaded', () => {
                const reloadButton = document.getElementById('connectionBannerAction');
                if (reloadButton) {
                    reloadButton.addEventListener('click', () => window.location.reload());
                }
                // Slight delay before first health check to allow parallel initial fetches to settle
                setTimeout(runHealthCheck, 600);
                // Kick off async versions fetch shortly after paint (secondary guard: no-op if primary already scheduled)
                setTimeout(() => { try { if (typeof fetchVersions === 'function') fetchVersions(0); } catch(_) {} }, 80);
            });
        })();
    </script>
    
    <script>
        // Theme management
        function getStoredTheme() {
            return localStorage.getItem('theme') || 'light';
        }
        
        function setTheme(theme) {
            document.documentElement.setAttribute('data-theme', theme);
            localStorage.setItem('theme', theme);
            const icon = document.getElementById('theme-icon');
            icon.textContent = theme === 'dark' ? '☀️' : '🌙';
        }
        
        function toggleTheme() {
            const currentTheme = getStoredTheme();
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            setTheme(newTheme);
        }
        
        // Initialize theme
        setTheme(getStoredTheme());
    </script>
    <script>
        // -------- Manage Logs (global manager logs) --------
        (function(){
            const tabs = document.getElementById('manager-log-tabs');
            const empty = document.getElementById('manager-log-tabs-empty');
            const viewer = document.getElementById('manager-log-viewer');
            const toggle = document.getElementById('manageLogsToggle');
            const content = document.getElementById('manageLogsContent');
            const chevron = document.getElementById('manageLogsChevron');
            const toggleLabel = document.getElementById('manageLogsToggleLabel');
            const btnRefresh = document.getElementById('ml-refresh');
            const btnDownload = document.getElementById('ml-download');
            const btnClear = document.getElementById('ml-clear');
            if (!tabs || !viewer) return;
            let files = []; let selected=''; let tailOffset=-1; let tailTimer=null; let listTimer=null; let pausedByScroll=false;
            let tailIntervalMs = 2000; let rateLimitedUntil = 0; let rateLimited = false; let resumeTimer = null;
            const TAIL_BACK=8192, TAIL_MAX=65536;
            function isAtBottom(t){ const tol = typeof t==='number'?t:4; return viewer && (viewer.scrollTop+viewer.clientHeight)>= (viewer.scrollHeight - tol); }
            function scrollToBottom(){ if(viewer) viewer.scrollTop=viewer.scrollHeight; }
            function renderTabs(){ if(!tabs) return; tabs.innerHTML=''; const has=Array.isArray(files)&&files.length>0; if(empty) empty.style.display=has?'none':''; if(!has) return; files.forEach((name,i)=>{ const btn=document.createElement('button'); btn.type='button'; btn.className='log-tab'; btn.setAttribute('role','tab'); btn.dataset.name=name; btn.setAttribute('aria-selected', selected===name?'true':'false'); const label=document.createElement('span'); label.className='filename'; label.textContent=name; btn.appendChild(label); btn.addEventListener('click',()=>{ if(selected===name) return; selected=name; tailOffset=-1; pausedByScroll=false; if(viewer) viewer.textContent=''; tabs.querySelectorAll('.log-tab').forEach(t=>t.setAttribute('aria-selected', t===btn?'true':'false')); fetchTail(); }); tabs.appendChild(btn); if(!selected && i===0){ selected=name; btn.setAttribute('aria-selected','true'); } }); }
            function fetchList(){ fetch('/api/manager/logs',{headers:{'Accept':'application/json'},credentials:'same-origin'}).then(r=>r.ok?r.json():null).then(data=>{ if(!data||!Array.isArray(data.files)) return; const prev=selected; files=data.files; renderTabs(); if(prev && !files.includes(prev)){ selected=files[0]||''; tailOffset=-1; if(viewer) viewer.textContent=''; } if(selected && !tailTimer){ fetchTail(); startTail(); } updateButtonsState(); }).catch(()=>{}); }
            function fetchTail(){
                if(!selected||!viewer) return;
                // Respect rate limit cooldown
                const now = Date.now();
                if (rateLimited && now < rateLimitedUntil) return;
                const params=new URLSearchParams({name:selected, offset:String(tailOffset), back:String(TAIL_BACK), max:String(TAIL_MAX)});
                fetch('/api/manager/log/tail?'+params.toString(),{credentials:'same-origin'})
                  .then(r=>{
                      if (r.status === 429) {
                          try { console.warn('[SDSM][Logs] Rate limited on tail; backing off.'); } catch(_) {}
                          rateLimited = true;
                          const prev = tailIntervalMs;
                          tailIntervalMs = Math.min(prev * 2, 30000);
                          rateLimitedUntil = Date.now() + tailIntervalMs;
                          stopTail();
                          if (resumeTimer) clearTimeout(resumeTimer);
                          resumeTimer = setTimeout(()=>{ rateLimited=false; startTail(); }, tailIntervalMs);
                          return null;
                      }
                      return r.ok ? r.json() : null;
                  })
                  .then(data=>{
                      if(!data) return;
                      if(data.reset){ viewer.textContent=''; }
                      const chunk=typeof data.data==='string'?data.data:'';
                      if(chunk){ const stick=!pausedByScroll && isAtBottom(); viewer.textContent+=chunk; if(stick) scrollToBottom(); }
                      if(typeof data.offset==='number') tailOffset=data.offset; updateButtonsState();
                  })
                  .catch(()=>{});
            }
            function startTail(){ if(!tailTimer) tailTimer=setInterval(fetchTail, tailIntervalMs); }
            function stopTail(){ if(tailTimer){ clearInterval(tailTimer); tailTimer=null; } }
            function initScrollPause(){ if(!viewer) return; viewer.addEventListener('scroll',()=>{ if(isAtBottom()){ if(pausedByScroll){ pausedByScroll=false; startTail(); } } else { if(!pausedByScroll){ pausedByScroll=true; stopTail(); } } }); }
            function initToggle(){
                if(!toggle||!content) return;
                const key = 'sdsm:manager:logs:expanded';
                try {
                    const saved = localStorage.getItem(key);
                    const expanded = saved === null ? true : (saved === '1');
                    content.classList.toggle('hidden', !expanded);
                    content.setAttribute('aria-hidden', expanded ? 'false' : 'true');
                    toggle.setAttribute('aria-expanded', expanded ? 'true' : 'false');
                    if(toggleLabel) toggleLabel.textContent = expanded ? 'Less' : 'More';
                    if(chevron) chevron.innerHTML = expanded ? '<polyline points="6 15 12 9 18 15"></polyline>' : '<polyline points="6 9 12 15 18 9"></polyline>';
                } catch(_) {}
                toggle.addEventListener('click',()=>{
                    const nowExpanded = content.classList.toggle('hidden') ? false : true;
                    content.setAttribute('aria-hidden', nowExpanded?'false':'true');
                    toggle.setAttribute('aria-expanded', nowExpanded?'true':'false');
                    if(toggleLabel) toggleLabel.textContent = nowExpanded ? 'Less' : 'More';
                    if(chevron){ chevron.innerHTML = nowExpanded ? '<polyline points="6 15 12 9 18 15"></polyline>' : '<polyline points="6 9 12 15 18 9"></polyline>'; }
                    try { localStorage.setItem('sdsm:manager:logs:expanded', nowExpanded ? '1' : '0'); } catch(_) {}
                });
            }

            function updateButtonsState(){ const hasSel = !!selected; if(btnRefresh) btnRefresh.disabled = !hasSel; if(btnDownload) btnDownload.disabled = !hasSel; if(btnClear) btnClear.disabled = !hasSel; }
            function initButtons(){
                if(btnRefresh) btnRefresh.addEventListener('click', ()=>{ if(selected){ tailOffset=-1; viewer.textContent=''; fetchTail(); } });
                if(btnDownload) btnDownload.addEventListener('click', ()=>{ if(selected){ window.location = '/api/manager/log/download?name='+encodeURIComponent(selected); } });
                if(btnClear) btnClear.addEventListener('click', ()=>{ if(!selected) return; btnClear.disabled=true; fetch('/api/manager/log/clear', { method:'POST', headers:{'Content-Type':'application/x-www-form-urlencoded','Accept':'application/json'}, credentials:'same-origin', body:'name='+encodeURIComponent(selected) })
                    .then(r=>{ if(r.ok){ tailOffset=-1; viewer.textContent=''; fetchTail(); } return r.json().catch(()=>({})); })
                    .finally(()=>{ btnClear.disabled=false; }); });
                updateButtonsState();
            }
            initScrollPause(); initToggle(); initButtons(); fetchList(); if(!listTimer) listTimer=setInterval(fetchList,30000);
        })();
    </script>
    
    
    {{ template "modal_templates" . }}
    {{ template "modal_scripts" . }}
        <template id="tpl-modal-bugreport">
            <div class="confirm-modal" role="dialog" aria-modal="true" aria-labelledby="bugReportTitle" aria-describedby="bugReportBody">
                <div class="modal-card">
                    <header class="modal-header">
                        <span class="icon">🪲</span>
                        <h3 id="bugReportTitle" class="modal-title">Report a Bug</h3>
                        <button type="button" class="modal-close" data-close aria-label="Close">×</button>
                    </header>
                    <div id="bugReportBody" class="modal-body">
                        <div class="form-group">
                            <label class="form-label" for="bug_title">Title</label>
                            <input id="bug_title" type="text" class="input" maxlength="120" placeholder="Short summary" />
                        </div>
                        <div class="form-group">
                            <label class="form-label" for="bug_desc">Description</label>
                            <textarea id="bug_desc" class="input" rows="6" placeholder="Steps to reproduce, expected vs actual"></textarea>
                        </div>
                        <div class="form-group">
                            <label class="inline-flex items-center gap-2"><input id="bug_inc_mgr" type="checkbox" checked /> Include manager log tail</label>
                            <label class="inline-flex items-center gap-2"><input id="bug_inc_upd" type="checkbox" checked /> Include update log tail</label>
                            <label class="inline-flex items-center gap-2"><input id="bug_inc_env" type="checkbox" checked /> Include environment info</label>
                        </div>
                    </div>
                    <div class="modal-actions">
                        <button type="button" class="btn btn-ghost" data-cancel>Cancel</button>
                        <button type="button" class="btn btn-primary" data-submit>Submit</button>
                    </div>
                </div>
            </div>
        </template>
        <script>
            function openBugReportModal(){
                const tpl = document.getElementById('tpl-modal-bugreport');
                if(!tpl || !tpl.content) return;
                const modal = tpl.content.cloneNode(true).querySelector('.confirm-modal');
                document.body.appendChild(modal);
                const closeBtn = modal.querySelector('[data-close]');
                const cancelBtn = modal.querySelector('[data-cancel]');
                const submitBtn = modal.querySelector('[data-submit]');
                function finish(){ if(modal && modal.parentNode) modal.parentNode.removeChild(modal); }
                function activate(){ modal.classList.add('active'); modal.setAttribute('aria-hidden','false'); try { modal.querySelector('#bug_title').focus(); } catch(_){} }
                closeBtn && closeBtn.addEventListener('click', finish);
                cancelBtn && cancelBtn.addEventListener('click', finish);
                submitBtn && submitBtn.addEventListener('click', ()=>{
                    const title = (modal.querySelector('#bug_title')?.value||'').trim();
                    const desc = (modal.querySelector('#bug_desc')?.value||'').trim();
                    const incMgr = !!modal.querySelector('#bug_inc_mgr')?.checked;
                    const incUpd = !!modal.querySelector('#bug_inc_upd')?.checked;
                    const incEnv = !!modal.querySelector('#bug_inc_env')?.checked;
                    if(!title){ try { modal.querySelector('#bug_title').focus(); } catch(_){} return; }
                    fetch('/api/bug-report', { method:'POST', headers:{'Content-Type':'application/json','Accept':'application/json'}, credentials:'same-origin', body: JSON.stringify({ title, description: desc, include_manager_log: incMgr, include_update_log: incUpd, include_environment: incEnv }) })
                        .then(r=> r.ok ? r.json() : r.json().then(Promise.reject))
                        .then(()=> { if(window.showToast) window.showToast({type:'success', title:'Thanks!', message:'Bug report submitted'}); finish(); })
                        .catch((e)=> { if(window.showToast) window.showToast({type:'error', title:'Submit Failed', message:(e&&e.error)||'Unable to submit'}); });
                });
                modal.addEventListener('click', (e)=>{ if(e.target===modal) finish(); });
                activate();
            }
        </script>

        <script>
            // Wire Report Bug button to modal (with a simple fallback)
            (function(){
                function attach(){
                    var btn = document.getElementById('bugReportBtn');
                    if (!btn) return;
                    if (btn.__bugInit) return; btn.__bugInit = true;
                    btn.addEventListener('click', function(e){
                        e.preventDefault();
                        if (typeof openBugReportModal === 'function') {
                            openBugReportModal();
                            return;
                        }
                        // Fallback: quick prompts
                        var title = prompt('Bug title:');
                        if (!title) return;
                        var desc = prompt('Describe the issue (optional):') || '';
                        fetch('/api/bug-report', {
                            method: 'POST', credentials: 'same-origin',
                            headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
                            body: JSON.stringify({ title: title, description: desc, include_manager_log: true, include_update_log: true, include_environment: true })
                        }).then(function(r){ return r.json().catch(function(){ return {}; }); })
                          .then(function(){ if (window.showToast) window.showToast({ type:'success', title:'Thanks!', message:'Bug report submitted' }); })
                          .catch(function(){ if (window.showToast) window.showToast({ type:'error', title:'Submit Failed', message:'Unable to submit' }); });
                    });
                }
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', attach);
                } else { attach(); }
            })();
        </script>

    {{ template "toast.html" . }}
    {{ template "footer" . }}
</body>

</html>
<!-- Fallback loader: populate versions even if main script fails; logs errors and respects primary flag -->
<script>
(function(){
    function setText(id, val){ var el = document.getElementById(id); if(el){ el.textContent = val || ''; } }
    function setBtn(name, equal){
        var btn = document.querySelector('button[data-component="'+name+'"]');
        if (!btn) return;
        btn.classList.remove('btn-success','btn-danger');
        if (btn.classList.contains('btn-secondary')) {
            btn.classList.remove('btn-secondary');
        }
        btn.classList.add(equal ? 'btn-success' : 'btn-danger');
    }
    function apply(data){
        if (window.__versionsPrimaryLoaded) { return; }
        setText('ver-steamcmd-deployed', data.steamcmd_deployed);
        setText('ver-steamcmd-latest', data.steamcmd_latest);
        setText('ver-release-deployed', data.release_deployed);
        setText('ver-release-latest', data.release_latest);
        setText('ver-beta-deployed', data.beta_deployed);
        setText('ver-beta-latest', data.beta_latest);
        setText('ver-bepinex-deployed', data.bepinex_deployed);
        setText('ver-bepinex-latest', data.bepinex_latest);
        setText('ver-launchpad-deployed', data.launchpad_deployed);
        setText('ver-launchpad-latest', data.launchpad_latest);
        setText('ver-scon-deployed', data.scon_deployed);
        setText('ver-scon-latest', data.scon_latest);
        // SteamCMD: green if installed/known, red if missing/unknown/error/timeout
        (function(){
            var d = (data.steamcmd_deployed||'').trim();
            var bad = !d || /^(missing|unknown|error|timeout)$/i.test(d);
            setBtn('steamcmd', !bad);
        })();
        setBtn('release', (data.release_deployed||'')===(data.release_latest||''));
        setBtn('beta', (data.beta_deployed||'')===(data.beta_latest||''));
        setBtn('bepinex', (data.bepinex_deployed||'')===(data.bepinex_latest||''));
        setBtn('launchpad', (data.launchpad_deployed||'')===(data.launchpad_latest||''));
        setBtn('scon', (data.scon_deployed||'')===(data.scon_latest||''));
        try { console.warn('[SDSM] Versions loaded via fallback.'); window.__versionsFallbackUsed = true; } catch(_) {}
    }
    function markUnavailable(){
        if (window.__versionsPrimaryLoaded) { return; }
        var ids=['ver-steamcmd-deployed','ver-steamcmd-latest','ver-release-deployed','ver-release-latest','ver-beta-deployed','ver-beta-latest','ver-bepinex-deployed','ver-bepinex-latest','ver-launchpad-deployed','ver-launchpad-latest','ver-scon-deployed','ver-scon-latest'];
        for (var i=0;i<ids.length;i++){ var el=document.getElementById(ids[i]); if (el && (el.textContent==='Loading…' || el.textContent==='Loading...')) el.textContent='Unavailable'; }
        try {
            console.error('[SDSM] Fallback failed to load versions after retries.');
            if (window && typeof window.showToast === 'function') {
                window.showToast({ type: 'error', title: 'Version Load Failed', message: 'Fallback could not load component versions.' });
            }
        } catch(_) {}
    }
    function load(retry){
        if (window.__versionsPrimaryLoaded) { return; }
        var tries = typeof retry==='number' ? retry : 0;
        try {
            var xhr = new XMLHttpRequest();
            xhr.open('GET','/api/manager/versions', true);
            xhr.setRequestHeader('Accept','application/json');
            xhr.onreadystatechange = function(){
                if (xhr.readyState !== 4) return;
                if (window.__versionsPrimaryLoaded) { return; }
                if (xhr.status>=200 && xhr.status<300){
                    try { var data = JSON.parse(xhr.responseText||'{}'); apply(data); }
                    catch(e){ console.error('[SDSM] Fallback parse error', e); markUnavailable(); }
                } else {
                    if (tries < 3) {
                        try { console.warn('[SDSM] Fallback versions fetch retry', tries+1, '(status', xhr.status, ')'); } catch(_) {}
                        var base = (xhr.status === 429) ? 3000 : 500;
                        setTimeout(function(){ load(tries+1); }, base*(tries+1));
                    } else {
                        markUnavailable();
                    }
                }
            };
            xhr.onerror = function(){
                if (tries < 3) { setTimeout(function(){ load(tries+1); }, 800*(tries+1)); }
                else { markUnavailable(); }
            };
            xhr.send();
        } catch(e){ if (tries < 3) { setTimeout(function(){ load(tries+1); }, 500*(tries+1)); } else { markUnavailable(); } }
    }
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', function(){ setTimeout(function(){ load(0); }, 200); });
    } else {
        setTimeout(function(){ load(0); }, 200);
    }
})();
</script>