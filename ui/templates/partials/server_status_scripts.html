<script>
    // Global guard to prevent ReferenceError if handlers run before DOMContentLoaded sets locals
    window.__sdsmPendingSubmit = window.__sdsmPendingSubmit || false;
    function openLogPopup(serverId) {
        const popup = document.getElementById('logPopup');
        const body = document.getElementById('logPopupBody');
        popup.classList.add('active');
        body.textContent = 'Loading log...';
        
        // Fetch server log via server route
        fetch(`/server/${serverId}/log`, { credentials: 'same-origin' })
            .then(r => r.text())
            .then(log => {
                body.textContent = log || 'No log data available';
                // Auto-scroll to bottom
                body.scrollTop = body.scrollHeight;
            })
            .catch(err => {
                body.textContent = 'Error loading log: ' + err.message;
            });
    }

    function closeLogPopup() {
        document.getElementById('logPopup').classList.remove('active');
    }

    // Close popup when clicking outside
    document.getElementById('logPopup').addEventListener('click', function(e) {
        if (e.target === this) {
            closeLogPopup();
        }
    });

    function getStoredTheme() {
        return localStorage.getItem('theme') || 'dark';
    }

    function setTheme(theme) {
        const html = document.documentElement;
        html.setAttribute('data-theme', theme);
        localStorage.setItem('theme', theme);
        const icon = document.getElementById('theme-icon');
        if (icon) {
            icon.textContent = theme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
        }
    }

    function toggleTheme() {
        const current = document.documentElement.getAttribute('data-theme') || getStoredTheme();
        const next = current === 'dark' ? 'light' : 'dark';
        setTheme(next);
    }

    // Initialize theme
    setTheme(getStoredTheme());
    const rootEl = document.body;
    const statusIndicator = document.getElementById('status-dot-indicator');
    const statusText = document.getElementById('status-dot-text');
    const statusContainer = document.getElementById('status-pill-container');
    const startedValueEl = document.getElementById('server-started-value');
    const savedValueEl = document.getElementById('server-saved-value');
    const lastLogLineEl = document.getElementById('last-log-line');
    const playersLiveTable = document.getElementById('players-live-table');
    const playersLiveBody = document.getElementById('players-live-body');
    const playersLiveEmpty = document.getElementById('players-live-empty');
    const playersLiveCount = document.getElementById('players-live-count');
    const playersHistoryTable = document.getElementById('players-history-table');
    const playersHistoryBody = document.getElementById('players-history-body');
    const playersHistoryEmpty = document.getElementById('players-history-empty');
    const startButton = document.getElementById('btn-start');
    const stopButton = document.getElementById('btn-stop');
    const restartButton = document.getElementById('btn-restart');
    const pauseButton = document.getElementById('btn-pause');
    const saveButton = document.getElementById('btn-save');
    const stormButton = document.getElementById('btn-storm');
    const cleanupDeadButton = document.getElementById('btn-cleanup-dead');
    const cleanupDiscButton = document.getElementById('btn-cleanup-disconnected');
    const cleanupAllButton = document.getElementById('btn-cleanup-all');
    const deleteButton = document.getElementById('btn-delete');
    const connectionBanner = document.getElementById('connection-banner');
    const connectionBannerText = document.getElementById('connection-banner-text');
    const chatMessagesContainer = document.getElementById('chat-messages');
    const chatEmptyState = document.getElementById('chat-empty');
    const playersBannedTable = document.getElementById('players-banned-table');
    const playersBannedBody = document.getElementById('players-banned-body');
    const playersBannedEmpty = document.getElementById('players-banned-empty');
    const errorBanner = document.getElementById('server-error-banner');
    const errorTextEl = document.getElementById('server-error-text');
    const errorTimeEl = document.getElementById('server-error-time');
    let bannedSteamSet = new Set();
    const worldThumb = document.querySelector('.world-thumb');
    // Server logs UI elements
    const logTabs = document.getElementById('log-tabs');
    const logTabsEmpty = document.getElementById('log-tabs-empty');
    const logViewer = document.getElementById('log-viewer');
    let logFiles = [];
    let selectedLog = '';
    let logTimer = null;
    let logListTimer = null;
    let logTailOffset = -1; // -1 means from end
    let logPausedByScroll = false; // pause tailing when user scrolls off bottom
    const LOG_TAIL_BACK = 8192; // fetch last 8KB on first load / rotation
    const LOG_TAIL_MAX = 65536; // cap per-poll payload

    let serverIsRunning = rootEl.dataset.serverRunning === "true";
    let serverIsPaused = rootEl.dataset.serverPaused === "true";
    let serverIsStarting = rootEl.dataset.serverStarting === "true";
    let updateButton = null;
    let progressContainer = null;
    let progressFill = null;
    let progressText = null;
    let progressTimer = null;
    let statusTimer = null;
    let progressActive = false;
    let connectionLost = false;
    let statusFailureCount = 0;
    let reconnectTimer = null;
    let setUpdateButtonDisabled = function() {};
    let stopProgressPolling = function() {};
    let startProgressPolling = function() {};
    let refreshUpdateButtonState = function() {};
    let updateServerStatusUI = function() {};
    let fetchProgress = function() {};
    let fetchStatus = function() {};
    let stopStatusUpdates = function() {};
    let startStatusUpdates = function() {};

    let serverIsStorming = false;
    let knownLiveSteam = new Set();
    let playerSavesToggle = null;

    // Saves UI elements
    const savesTabs = document.getElementById('saves-tabs');
    const savesList = document.getElementById('saves-list');
    const savesEmpty = document.getElementById('saves-empty');

    updateControlButtons({ running: serverIsRunning, paused: serverIsPaused, starting: serverIsStarting });

    function pad2(value) {
        return String(value).padStart(2, '0');
    }

    function formatDateTimeDisplay(value, fallback) {
        if (!value) {
            return fallback;
        }
        const dt = new Date(value);
        if (Number.isNaN(dt.getTime())) {
            return fallback;
        }
        return `${pad2(dt.getMonth() + 1)}/${pad2(dt.getDate())}/${dt.getFullYear()} ${pad2(dt.getHours())}:${pad2(dt.getMinutes())}:${pad2(dt.getSeconds())}`;
    }

    // Autosave display format: DDD dd-MMM-yy hh:mm:ss (e.g., Mon 03-Nov-25 11:48:35)
    function formatAutosaveDate(dt) {
        if (!(dt instanceof Date) || Number.isNaN(dt.getTime())) return '‚Äî';
        const days = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
        const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
        const ddd = days[dt.getDay()];
        const dd = pad2(dt.getDate());
        const mmm = months[dt.getMonth()];
        const yy = String(dt.getFullYear()).slice(-2);
        const hh = pad2(dt.getHours());
        const mm = pad2(dt.getMinutes());
        const ss = pad2(dt.getSeconds());
        return `${ddd} ${dd}-${mmm}-${yy} ${hh}:${mm}:${ss}`;
    }

    function renderSaves(items) {
        if (!savesList) return;
        savesList.textContent = '';
        if (!Array.isArray(items) || items.length === 0) {
            showElement(savesList, false);
            showElement(savesEmpty, true);
            return;
        }
        // Build a simple table (without headers as requested)
        const table = document.createElement('table');
        table.className = 'table';
        const tbody = document.createElement('tbody');
        items.forEach(it => {
            const tr = document.createElement('tr');
            const name = document.createElement('td');
            // Add extra space between the name and the datetime/action cells
            name.style.paddingRight = '24px';
            // Name cell with stopwatch icon for autosaves
            const nameWrap = document.createElement('span');
            nameWrap.style.display = 'inline-flex';
            nameWrap.style.alignItems = 'center';
            nameWrap.style.gap = '6px';
            const icon = document.createElement('span');
            icon.innerHTML = '<svg class="icon-inline" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" title="Autosave"><circle cx="12" cy="13" r="8"></circle><line x1="12" y1="5" x2="12" y2="2"></line><line x1="9" y1="2" x2="15" y2="2"></line><line x1="12" y1="13" x2="16" y2="13"></line></svg>';
            const label = document.createElement('span');
            const rawName = (it && it.name) ? String(it.name) : '';
            const displayName = rawName && rawName.toLowerCase() !== 'auto' ? rawName : 'Autosave';
            label.textContent = displayName;
            nameWrap.appendChild(icon);
            nameWrap.appendChild(label);
            name.appendChild(nameWrap);
            const dt = document.createElement('td');
            const d = it && it.datetime ? new Date(it.datetime) : null;
            // Lay out time on the left and actions on the right with comfortable spacing
            dt.style.display = 'flex';
            dt.style.alignItems = 'center';
            dt.style.justifyContent = 'space-between';
            dt.style.flexWrap = 'nowrap';
            dt.style.gap = '10px';
            const timeSpan = document.createElement('span');
            timeSpan.textContent = d && !Number.isNaN(d.getTime()) ? formatAutosaveDate(d) : '‚Äî';
            const actions = document.createElement('span');
            actions.style.whiteSpace = 'nowrap';
            actions.style.marginLeft = '12px';
            // Load button
            const btnLoad = document.createElement('button');
            btnLoad.type = 'button';
            btnLoad.className = 'btn btn-primary btn-icon btn-sm btn-load-save';
            btnLoad.title = 'Load this save';
            btnLoad.setAttribute('aria-label', 'Load save');
            btnLoad.dataset.filename = it && it.filename ? it.filename : '';
            btnLoad.dataset.path = it && it.path ? it.path : '';
            btnLoad.dataset.type = 'auto';
            btnLoad.innerHTML = '<svg class="icon-inline" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>';
            // Delete button
            const btnDel = document.createElement('button');
            btnDel.type = 'button';
            btnDel.className = 'btn btn-danger btn-icon btn-sm btn-delete-save';
            btnDel.title = 'Delete this save';
            btnDel.setAttribute('aria-label', 'Delete save');
            btnDel.dataset.filename = it && it.filename ? it.filename : '';
            btnDel.dataset.type = 'auto';
            btnDel.style.marginLeft = '6px';
            btnDel.innerHTML = '<svg class="icon-inline" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><polyline points="3 6 5 6 21 6"/><path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"/><path d="M10 11v6"/><path d="M14 11v6"/><path d="M9 6V4a2 2 0 0 1 2-2h2a2 2 0 0 1 2 2v2"/></svg>';
            actions.appendChild(btnLoad);
            actions.appendChild(btnDel);
            dt.appendChild(timeSpan);
            dt.appendChild(actions);
            tr.appendChild(name); tr.appendChild(dt);
            tbody.appendChild(tr);
        });
        table.appendChild(tbody);
        savesList.appendChild(table);
        showElement(savesEmpty, false);
        showElement(savesList, true, 'block');
    }

    function fetchAutoSaves() {
        const serverId = rootEl.dataset.serverId;
        if (!serverId) return;
        fetch(`/api/servers/${serverId}/saves?type=auto`, {
            credentials: 'same-origin',
            cache: 'no-store',
            headers: { 'Accept': 'application/json' }
        })
            .then(r => r.ok ? r.json() : Promise.reject(new Error('Failed to load saves')))
            .then(data => {
                renderSaves((data && data.items) || []);
            })
            .catch(() => {
                renderSaves([]);
            });
    }

    // Bind saves tab interactions (first pass: Auto only)
    if (savesTabs) {
        savesTabs.addEventListener('click', (e) => {
            const btn = e.target.closest('.tab');
            if (!btn) return;
            e.preventDefault();
            savesTabs.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            btn.classList.add('active');
            const filter = btn.getAttribute('data-save-filter');
            if (filter === 'auto' || filter === 'all') {
                fetchAutoSaves();
            } else {
                // Not implemented yet; show empty state
                renderSaves([]);
            }
        });
        // If Auto tab is already active on load, fetch immediately
        try {
            const activeTab = savesTabs.querySelector('.tab.active');
            const activeFilter = activeTab ? activeTab.getAttribute('data-save-filter') : '';
            if (activeFilter === 'auto' || activeFilter === 'all') {
                fetchAutoSaves();
            }
        } catch(_) {}
    }

    // Delegated handlers for Load/Delete in saves list
    if (savesList) {
        savesList.addEventListener('click', function(e){
            const loadBtn = e.target.closest && e.target.closest('.btn-load-save');
            const delBtn = e.target.closest && e.target.closest('.btn-delete-save');
            const serverId = Number(rootEl.dataset.serverId || '0');
            if (!serverId) return;
            if (loadBtn) {
                e.preventDefault();
                const path = (loadBtn.dataset.path || '').trim();
                const name = (loadBtn.dataset.filename || '').trim();
                if (!path && !name) return;
                const target = path || name;
                const confirmed = window.confirm('Load this save? The current world state will be replaced.');
                if (!confirmed) return;
                loadBtn.disabled = true;
                fetch(`/api/servers/${serverId}/command`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
                    credentials: 'same-origin',
                    body: JSON.stringify({ type: 'console', payload: 'FILE load ' + target })
                }).then((res) => {
                    try {
                        if (typeof window.showToast === 'function') {
                            const type = res.headers.get('X-Toast-Type');
                            const title = res.headers.get('X-Toast-Title');
                            const message = res.headers.get('X-Toast-Message');
                            if (message) window.showToast({ type: type || 'info', title: title || '', message });
                        }
                    } catch(_) {}
                }).catch(() => {
                    // no-op
                }).finally(() => { loadBtn.disabled = false; });
                return;
            }
            if (delBtn) {
                e.preventDefault();
                const name = (delBtn.dataset.filename || '').trim();
                const type = (delBtn.dataset.type || 'auto');
                if (!name) return;
                const confirmed = window.confirm('Delete this save file permanently?');
                if (!confirmed) return;
                delBtn.disabled = true;
                const url = new URL(window.location.origin + `/api/servers/${serverId}/saves`);
                url.searchParams.set('type', type);
                url.searchParams.set('name', name);
                fetch(url.toString(), {
                    method: 'DELETE',
                    credentials: 'same-origin',
                    headers: { 'Accept': 'application/json' }
                }).then((res) => {
                    try {
                        if (typeof window.showToast === 'function') {
                            const typeH = res.headers.get('X-Toast-Type');
                            const title = res.headers.get('X-Toast-Title');
                            const message = res.headers.get('X-Toast-Message');
                            if (message) window.showToast({ type: typeH || 'success', title: title || '', message });
                        }
                    } catch(_) {}
                    // Refresh autosaves list after deletion
                    fetchAutoSaves();
                }).catch(() => {
                    // no-op
                }).finally(() => { delBtn.disabled = false; });
            }
        });
    }

    function formatTimeDisplay(value, fallback) {
        if (!value) {
            return fallback;
        }
        const dt = new Date(value);
        if (Number.isNaN(dt.getTime())) {
            return fallback;
        }
        return `${pad2(dt.getHours())}:${pad2(dt.getMinutes())}`;
    }

    function setTextContent(el, text) {
        if (el) {
            el.textContent = text;
        }
    }

    function showElement(el, shouldShow, displayValue) {
        if (!el) {
            return;
        }
        // Also toggle a generic 'hidden' class if present to avoid CSS overriding inline display
        try {
            if (shouldShow) {
                el.classList.remove('hidden');
            } else {
                el.classList.add('hidden');
            }
        } catch(_) {}
        if (shouldShow) {
            if (displayValue) {
                el.style.display = displayValue;
            } else {
                // Set to initial to override any stylesheet default without relying on removal
                el.style.display = '';
            }
        } else {
            el.style.display = 'none';
        }
    }

    function setButtonDisabled(btn, disabled) {
        if (!btn) {
            return;
        }
        const isDisabled = !!disabled;
        btn.disabled = isDisabled;
        if (isDisabled) {
            btn.setAttribute('aria-disabled', 'true');
        } else {
            btn.removeAttribute('aria-disabled');
        }
    }

    function toggleButtonSpinner(btn, on) {
        if (!btn) return;
        btn.setAttribute('aria-busy', on ? 'true' : 'false');
        let sp = btn.querySelector('.btn-spinner');
        if (on) {
            if (!sp) {
                sp = document.createElement('span');
                sp.className = 'btn-spinner';
                sp.setAttribute('aria-hidden', 'true');
                btn.appendChild(sp);
            }
        } else if (sp) {
            sp.remove();
        }
    }

    function updateLiveCount(count) {
        if (!playersLiveCount) {
            return;
        }
        const value = Number(count) || 0;
        playersLiveCount.textContent = value === 1 ? '1 online' : `${value} online`;
    }

    function createTextCell(text) {
        const td = document.createElement('td');
        td.textContent = text;
        return td;
    }

    function createPlayerNameCell(player, opts) {
        const td = document.createElement('td');
        const wrapper = document.createElement('span');
        wrapper.className = 'player-name';

        if (player && player.is_admin) {
            const badge = document.createElement('span');
            badge.className = 'player-admin-icon';
            badge.title = 'Admin';
            badge.setAttribute('aria-label', 'Admin');
            badge.textContent = 'üõ°Ô∏è';
            wrapper.appendChild(badge);
        }

        // Optional banned indicator when requested (used on History tab)
        if (opts && opts.banned) {
            const bannedIcon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            bannedIcon.setAttribute('class', 'icon-inline player-banned-icon');
            bannedIcon.setAttribute('width', '14');
            bannedIcon.setAttribute('height', '14');
            bannedIcon.setAttribute('viewBox', '0 0 24 24');
            bannedIcon.setAttribute('fill', 'none');
            bannedIcon.setAttribute('stroke', 'currentColor');
            bannedIcon.setAttribute('stroke-width', '2');
            bannedIcon.setAttribute('aria-hidden', 'true');
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', '12');
            circle.setAttribute('cy', '12');
            circle.setAttribute('r', '9');
            const slash = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            slash.setAttribute('x1', '5');
            slash.setAttribute('y1', '19');
            slash.setAttribute('x2', '19');
            slash.setAttribute('y2', '5');
            bannedIcon.appendChild(circle);
            bannedIcon.appendChild(slash);
            bannedIcon.setAttribute('title', 'Banned');
            wrapper.appendChild(bannedIcon);
        }

        const nameSpan = document.createElement('span');
        nameSpan.textContent = player && player.name ? player.name : 'Unknown';
        wrapper.appendChild(nameSpan);

        td.appendChild(wrapper);
        return td;
    }

    function createActionCell(playerName, action) {
        const td = document.createElement('td');
        const form = document.createElement('form');
        form.method = 'POST';
        form.style.display = 'inline';

        const button = document.createElement('button');
        button.type = 'submit';
        button.name = action;
        button.value = playerName || '';
        // Assign color by action: ban=red, unban=green, kick=amber
        if (action === 'ban') {
            button.className = 'btn btn-danger btn-icon';
            button.title = 'Ban Steam ID';
            button.setAttribute('aria-label', 'Ban player');
        } else if (action === 'unban') {
            button.className = 'btn btn-success btn-icon';
            button.title = 'Unban Steam ID';
            button.setAttribute('aria-label', 'Unban player');
        } else if (action === 'kick') {
            button.className = 'btn btn-warning btn-icon';
            button.title = 'Kick player';
            button.setAttribute('aria-label', 'Kick player');
        } else {
            button.className = 'btn btn-secondary btn-icon';
            const label = action.charAt(0).toUpperCase() + action.slice(1);
            button.title = label;
            button.setAttribute('aria-label', label);
        }
        if (action === 'ban') {
            button.innerHTML = '<svg class="icon-inline" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><circle cx="12" cy="12" r="9"></circle><line x1="5" y1="19" x2="19" y2="5"></line></svg>';
        } else if (action === 'unban') {
            button.innerHTML = '<svg class="icon-inline" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><circle cx="12" cy="12" r="9"></circle><polyline points="9 12 12 15 17 10"></polyline></svg>';
        } else if (action === 'kick') {
            button.innerHTML = '<svg class="icon-inline" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><circle cx="12" cy="12" r="9"></circle><line x1="8" y1="12" x2="16" y2="12"></line></svg>';
        } else {
            button.textContent = action.charAt(0).toUpperCase() + action.slice(1);
        }

        form.appendChild(button);
        td.appendChild(form);
        return td;
    }

    function renderLivePlayers(players) {
        if (!playersLiveBody) {
            return;
        }
        playersLiveBody.textContent = '';

        if (!Array.isArray(players) || players.length === 0) {
            showElement(playersLiveTable, false);
            showElement(playersLiveEmpty, true);
            updateLiveCount(0);
            return;
        }

        showElement(playersLiveTable, true, 'table');
        showElement(playersLiveEmpty, false);

        players.forEach(player => {
            const row = document.createElement('tr');
            row.appendChild(createPlayerNameCell(player));
            row.appendChild(createTextCell(player.steam_id || ''));
            row.appendChild(createTextCell(formatDateTimeDisplay(player.connected_at, '‚Äî')));
            row.appendChild(createActionCell(player.name || '', 'kick'));
            row.appendChild(createActionCell(player.steam_id || '', 'ban'));
            playersLiveBody.appendChild(row);
        });

        updateLiveCount(players.length);
    }

    function renderHistoryPlayers(history) {
        if (!playersHistoryBody) {
            return;
        }
        playersHistoryBody.textContent = '';

        if (!Array.isArray(history) || history.length === 0) {
            showElement(playersHistoryTable, false);
            showElement(playersHistoryEmpty, true);
            return;
        }

        showElement(playersHistoryTable, true, 'table');
        showElement(playersHistoryEmpty, false);

        history.forEach(entry => {
            const row = document.createElement('tr');
            const isBanned = !!(entry && entry.steam_id && bannedSteamSet && bannedSteamSet.has(entry.steam_id));
            if (isBanned) {
                row.classList.add('row-banned');
            }
            row.appendChild(createPlayerNameCell(entry, { banned: isBanned }));
            row.appendChild(createTextCell(entry.steam_id || ''));
            row.appendChild(createTextCell(formatDateTimeDisplay(entry.connected_at, '‚Äî')));
            row.appendChild(createTextCell(entry.session_length || '‚Äî'));
            row.appendChild(createActionCell(entry.steam_id || '', isBanned ? 'unban' : 'ban'));
            playersHistoryBody.appendChild(row);
        });
    }

    function renderChatMessages(messages) {
        if (!chatMessagesContainer || !chatEmptyState) {
            return;
        }

        chatMessagesContainer.textContent = '';

        if (!Array.isArray(messages) || messages.length === 0) {
            chatEmptyState.style.removeProperty('display');
            return;
        }

        chatEmptyState.style.display = 'none';

        messages.forEach((entry) => {
            if (!entry) {
                return;
            }
            const row = document.createElement('div');
            row.className = 'chat-message';

            const timeSpan = document.createElement('span');
            timeSpan.className = 'chat-time';
            timeSpan.textContent = formatTimeDisplay(entry.time, '--:--');

            const playerSpan = document.createElement('span');
            playerSpan.className = 'chat-player';
            playerSpan.textContent = `${entry.player || 'Unknown'}:`;

            const messageSpan = document.createElement('span');
            messageSpan.className = 'chat-text';
            messageSpan.textContent = entry.message || '';

            row.appendChild(timeSpan);
            row.appendChild(playerSpan);
            row.appendChild(messageSpan);

            chatMessagesContainer.appendChild(row);
        });

        chatMessagesContainer.scrollTop = chatMessagesContainer.scrollHeight;
    }

    function renderBanned(list) {
        if (!playersBannedBody) {
            return;
        }
        playersBannedBody.textContent = '';

        if (!Array.isArray(list) || list.length === 0) {
            showElement(playersBannedTable, false);
            showElement(playersBannedEmpty, true);
            return;
        }

        showElement(playersBannedTable, true, 'table');
        showElement(playersBannedEmpty, false);

        list.forEach(entry => {
            const row = document.createElement('tr');
            const nameTd = document.createElement('td');
            nameTd.textContent = (entry && entry.name) ? entry.name : '‚Äî';
            const idTd = document.createElement('td');
            idTd.textContent = entry && entry.steam_id ? entry.steam_id : '';
            const actionTd = document.createElement('td');
            const form = document.createElement('form');
            form.method = 'POST';
            form.style.display = 'inline';
            const btn = document.createElement('button');
            btn.type = 'submit';
            btn.name = 'unban';
            btn.value = (entry && entry.steam_id) ? entry.steam_id : '';
            btn.className = 'btn btn-success btn-icon';
            btn.setAttribute('aria-label', 'Unban player');
            btn.title = 'Unban Steam ID';
            btn.innerHTML = '<svg class="icon-inline" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><circle cx="12" cy="12" r="9"></circle><polyline points="9 12 12 15 17 10"></polyline></svg>';
            form.appendChild(btn);
            actionTd.appendChild(form);
            row.appendChild(nameTd);
            row.appendChild(idTd);
            row.appendChild(actionTd);
            playersBannedBody.appendChild(row);
        });
    }

    function setConnectionBanner(active, message) {
        // If this page is inside the main frame, use the top-level banner instead
        if (window.top && window.top !== window && typeof window.top.setConnectionBanner === 'function') {
            window.top.setConnectionBanner(!!active, message || '');
            return;
        }
        if (!connectionBanner) {
            return;
        }
        if (active) {
            connectionBanner.classList.add('active');
            if (connectionBannerText && message) {
                connectionBannerText.textContent = message;
            }
            document.body.style.paddingTop = '3rem';
        } else {
            connectionBanner.classList.remove('active');
            document.body.style.paddingTop = '';
        }
    }

    // Reload button
    (function(){
        const reloadBtn = document.getElementById('connection-banner-action');
        if (reloadBtn) {
            reloadBtn.addEventListener('click', () => window.location.reload());
        }
    })();

    function clearReconnectTimer() {
        if (reconnectTimer) {
            clearInterval(reconnectTimer);
            reconnectTimer = null;
        }
    }

    function handleConnectionLost() {
        if (connectionLost) {
            return;
        }
        connectionLost = true;
        setConnectionBanner(true, 'Connection lost. Attempting to reconnect...');
        stopStatusUpdates();
        stopProgressPolling();
        stopLogTail();
        setUpdateButtonDisabled(true);
        updateControlButtons();
        if (!reconnectTimer) {
            reconnectTimer = setInterval(attemptReconnect, 5000);
        }
        attemptReconnect();
    }

    function handleConnectionRestored() {
        if (!connectionLost) {
            return;
        }
        connectionLost = false;
        clearReconnectTimer();
        setConnectionBanner(false);
        refreshUpdateButtonState();
        updateControlButtons();
        startStatusUpdates();
        if (progressActive) {
            startProgressPolling();
        }
        startLogTail();
    }

    function attemptReconnect() {
        const serverId = rootEl.dataset.serverId;
        if (!serverId) {
            return;
        }
        fetch(`/server/${serverId}/status.json`, {
            credentials: 'same-origin',
            headers: {
                'Accept': 'application/json'
            }
        })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Server unavailable');
                }
                return response.json();
            })
            .then(data => {
                statusFailureCount = 0;
                handleConnectionRestored();
                updateServerStatusUI(data);
                fetchProgress();
            })
            .catch(() => {
                // Keep retrying until server responds again
            });
    }

    function updateControlButtons(status) {
        const statusObj = status || {};
        const running = typeof statusObj.running === 'boolean' ? statusObj.running : serverIsRunning;
        const paused = typeof statusObj.paused === 'boolean' ? statusObj.paused : serverIsPaused;
        const starting = typeof statusObj.starting === 'boolean' ? statusObj.starting : serverIsStarting;

        if (connectionLost) {
            setButtonDisabled(startButton, true);
            setButtonDisabled(stopButton, true);
            setButtonDisabled(restartButton, true);
            setButtonDisabled(pauseButton, true);
            setButtonDisabled(saveButton, true);
            setButtonDisabled(deleteButton, true);
            serverIsRunning = running;
            serverIsPaused = paused;
            serverIsStarting = starting;
            return;
        }

        if (startButton) {
            showElement(startButton, !running);
            setButtonDisabled(startButton, running || progressActive);
        }

        if (stopButton) {
            showElement(stopButton, running);
            setButtonDisabled(stopButton, !running || progressActive);
        }

        if (restartButton) {
            setButtonDisabled(restartButton, progressActive || starting);
        }

        if (pauseButton) {
            pauseButton.textContent = paused ? 'Resume' : 'Pause';
            setButtonDisabled(pauseButton, !running || progressActive || starting);
        }

        if (saveButton) {
            setButtonDisabled(saveButton, !running || progressActive || starting);
        }

        if (stormButton) {
            setButtonDisabled(stormButton, !running || progressActive || starting);
        }

        if (cleanupDeadButton) {
            setButtonDisabled(cleanupDeadButton, !running || progressActive || starting);
        }
        if (cleanupDiscButton) {
            setButtonDisabled(cleanupDiscButton, !running || progressActive || starting);
        }
        if (cleanupAllButton) {
            setButtonDisabled(cleanupAllButton, !running || progressActive || starting);
        }

        if (deleteButton) {
            setButtonDisabled(deleteButton, running || starting);
        }

        serverIsRunning = running;
        serverIsPaused = paused;
        serverIsStarting = starting;
    }

    // Worlds and data keyed by stable world IDs; names are localized for display
    let worldsByVersion = {"release": [], "beta": []};
    let worldDataByVersion = {"release": {}, "beta": {}};

    {{ if and .worlds .worldData }}
    {{ $worlds := .worlds }}
    {{ $worldData := .worldData }}
    worldsByVersion = {
        "release": [
            {{ $release := index $worlds "release" }}
            {{ range $idx, $w := $release }}
            {{ if $idx}}, {{ end }}
            {"id": '{{js (index $w "id")}}', "name": '{{js (index $w "name")}}'}
            {{ end }}
        ],
        "beta": [
            {{ $beta := index $worlds "beta" }}
            {{ range $idx, $w := $beta }}
            {{ if $idx}}, {{ end }}
            {"id": '{{js (index $w "id")}}', "name": '{{js (index $w "name")}}'}
            {{ end }}
        ]
    };

    worldDataByVersion = {
        "release": {
            {{ $releaseData := index $worldData "release" }}
            {{ $releaseWorlds := index $worlds "release" }}
            {{ range $idx, $w := $releaseWorlds }}
            {{ if $idx}}, {{ end }}
            "{{js (index $w "id")}}": {
                "locations": [
                    {{ with index $releaseData (index $w "id") }}
                    {{ range $locIdx, $loc := index . "locations" }}
                    {{ if $locIdx}}, {{ end }}
                    {"ID": "{{js $loc.ID}}", "Name": "{{js $loc.Name}}", "Description": "{{js $loc.Description}}"}
                    {{ end }}
                    {{ end }}
                ],
                "conditions": [
                    {{ with index $releaseData (index $w "id") }}
                    {{ range $condIdx, $cond := index . "conditions" }}
                    {{ if $condIdx}}, {{ end }}
                    {"ID": "{{js $cond.ID}}", "Name": "{{js $cond.Name}}", "Description": "{{js $cond.Description}}"}
                    {{ end }}
                    {{ end }}
                ]
            }
            {{ end }}
        },
        "beta": {
            {{ $betaData := index $worldData "beta" }}
            {{ $betaWorlds := index $worlds "beta" }}
            {{ range $idx, $w := $betaWorlds }}
            {{ if $idx}}, {{ end }}
            "{{js (index $w "id")}}": {
                "locations": [
                    {{ with index $betaData (index $w "id") }}
                    {{ range $locIdx, $loc := index . "locations" }}
                    {{ if $locIdx}}, {{ end }}
                    {"ID": "{{js $loc.ID}}", "Name": "{{js $loc.Name}}", "Description": "{{js $loc.Description}}"}
                    {{ end }}
                    {{ end }}
                ],
                "conditions": [
                    {{ with index $betaData (index $w "id") }}
                    {{ range $condIdx, $cond := index . "conditions" }}
                    {{ if $condIdx}}, {{ end }}
                    {"ID": "{{js $cond.ID}}", "Name": "{{js $cond.Name}}", "Description": "{{js $cond.Description}}"}
                    {{ end }}
                    {{ end }}
                ]
            }
            {{ end }}
        }
    };
    {{ end }}

    // Difficulties per version from server payload
    const releaseDifficulties = [
        {{- range $idx, $d := .release_difficulties -}}
        {{- if $idx}}, {{- end -}}
        "{{ js $d }}"
        {{- end -}}
    ];
    const betaDifficulties = [
        {{- range $idx, $d := .beta_difficulties -}}
        {{- if $idx}}, {{- end -}}
        "{{ js $d }}"
        {{- end -}}
    ];

    // Languages per version from server payload
    const releaseLanguages = [
        {{- range $idx, $l := .release_languages -}}
        {{- if $idx}}, {{- end -}}
        "{{ js $l }}"
        {{- end -}}
    ];
    const betaLanguages = [
        {{- range $idx, $l := .beta_languages -}}
        {{- if $idx}}, {{- end -}}
        "{{ js $l }}"
        {{- end -}}
    ];

    const initialVersionKey = {{if .server.Beta}}"beta"{{else}}"release"{{end}};
    const __resolvedWorldId = "{{js .resolved_world_id}}";
    const __serverWorldId = "{{js .server.WorldID}}";
    const initialWorldID = (__resolvedWorldId && __resolvedWorldId.trim()) || (__serverWorldId && __serverWorldId.trim()) || "";
    const initialStartLocation = {{if .server.StartLocation}}"{{js .server.StartLocation}}"{{else}}""{{end}};
    const initialStartCondition = {{if .server.StartCondition}}"{{js .server.StartCondition}}"{{else}}""{{end}};
    const initialDifficulty = {{if .server.Difficulty}}"{{js .server.Difficulty}}"{{else}}""{{end}};
    const initialLanguage = {{if .server.Language}}"{{js .server.Language}}"{{else}}""{{end}};

    const versionState = {
        release: {
            world: initialVersionKey === 'release' ? initialWorldID : '',
            startLocation: initialVersionKey === 'release' ? initialStartLocation : '',
            startCondition: initialVersionKey === 'release' ? initialStartCondition : ''
        },
        beta: {
            world: initialVersionKey === 'beta' ? initialWorldID : '',
            startLocation: initialVersionKey === 'beta' ? initialStartLocation : '',
            startCondition: initialVersionKey === 'beta' ? initialStartCondition : ''
        }
    };

    function currentVersionKey() {
        const checked = document.querySelector('input[name="beta"]:checked');
        return checked && checked.value === "true" ? "beta" : "release";
    }

    // Validation helpers: do not create fallback options. Instead, flag errors.
    function markInvalid(select, message) {
        if (!select) return;
        select.setAttribute('aria-invalid', 'true');
        // Inline highlight to avoid theme dependency
        select.style.outline = '2px solid var(--danger, #d93025)';
        if (message) select.title = message;
    }

    function clearInvalid(select) {
        if (!select) return;
        select.removeAttribute('aria-invalid');
        select.style.removeProperty('outline');
        select.title = '';
    }

    function notifyError(msg) {
        try {
            if (typeof window.showToast === 'function') {
                window.showToast({ type: 'error', title: 'Invalid configuration', message: msg });
            }
        } catch(_) {}
    }

    function updateParamsValidity() {
        const worldSelect = document.getElementById('world');
        const locSelect = document.getElementById('start_location');
        const condSelect = document.getElementById('start_condition');
        const updateBtn = document.getElementById('btn-update-params');
        let invalid = false;
        if (worldSelect && !worldSelect.value) invalid = true;
        if (locSelect && locSelect.getAttribute('aria-invalid') === 'true') invalid = true;
        if (condSelect && condSelect.getAttribute('aria-invalid') === 'true') invalid = true;
        if (updateBtn) {
            updateBtn.disabled = invalid || updateBtn.hasAttribute('aria-disabled');
            if (invalid) updateBtn.setAttribute('aria-disabled', 'true');
            else updateBtn.removeAttribute('aria-disabled');
        }
        return !invalid;
    }

    function populateWorldOptions() {
        const worldSelect = document.getElementById('world');
        playerSavesToggle = document.getElementById('player-saves-toggle');
        const playerSavesKey = `sdsm:server:${rootEl.dataset.serverId}:player-saves`;
        if (playerSavesToggle) {
            try {
                const saved = localStorage.getItem(playerSavesKey);
                if (saved === null || saved === undefined) {
                    // Default to persisted config value from dataset when no client preference exists
                    const defaultPS = String(rootEl.dataset.playerSaves || '').toLowerCase() === 'true';
                    playerSavesToggle.checked = defaultPS;
                    try { localStorage.setItem(playerSavesKey, defaultPS ? '1' : '0'); } catch(_) {}
                } else {
                    playerSavesToggle.checked = saved === '1';
                }
            } catch(_) {}
            playerSavesToggle.addEventListener('change', function(){
                const checked = !!this.checked;
                try { localStorage.setItem(playerSavesKey, checked ? '1' : '0'); } catch(_) {}
                // Persist to server config asynchronously
                const sid = Number(rootEl && rootEl.dataset && rootEl.dataset.serverId || '0');
                if (!sid) return;
                fetch(window.location.pathname, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                        'X-Requested-With': 'XMLHttpRequest',
                        'Accept': 'application/json'
                    },
                    body: 'set_player_saves=' + (checked ? '1' : '0'),
                    credentials: 'same-origin'
                }).then((res) => {
                    try {
                        if (typeof window.showToast === 'function') {
                            const type = res.headers.get('X-Toast-Type');
                            const title = res.headers.get('X-Toast-Title');
                            const message = res.headers.get('X-Toast-Message');
                            if (message) window.showToast({ type: type || 'success', title: title || '', message });
                        }
                    } catch(_) {}
                }).catch(() => {});
            });
        }
        const versionKey = currentVersionKey();
        const worlds = worldsByVersion[versionKey] || [];
        const state = versionState[versionKey];

        worldSelect.innerHTML = '';

        if (!worlds.length) {
            worldSelect.innerHTML = '<option value="">No worlds available</option>';
            // No fallback: force empty and error
            if (state.world) {
                notifyError('Configured world \'' + state.world + '\' is not available for this language/channel. Please choose a valid world.');
            }
            worldSelect.value = '';
            markInvalid(worldSelect, 'World not available for this language/channel');
            updateWorldOptions();
            updateWorldThumb();
            updateParamsValidity();
            return;
        }

        // If current configured world is not available, do not fallback; require user selection
        const worldIDs = new Set(worlds.map(w => w.id));
        if (state.world && !worldIDs.has(state.world)) {
            notifyError('Configured world \'' + state.world + '\' is not available for this language/channel. Please choose a valid world.');
            state.world = '';
            state.startLocation = '';
            state.startCondition = '';
        }

        worlds.forEach(w => {
            const option = document.createElement('option');
            option.value = w.id;
            option.textContent = w.name || w.id;
            worldSelect.appendChild(option);
        });

        // Select current value only if valid; otherwise leave empty and mark invalid
        if (state.world && worldIDs.has(state.world)) {
            worldSelect.value = state.world;
            clearInvalid(worldSelect);
        } else {
            worldSelect.value = '';
            if (!worldSelect.value) {
                markInvalid(worldSelect, 'World not available for this language/channel');
            }
        }
        state.world = worldSelect.value;

        updateWorldOptions();
        updateWorldThumb();
        updateParamsValidity();
    }

    function updateWorldOptions() {
        const worldSelect = document.getElementById('world');
        const locSelect = document.getElementById('start_location');
        const condSelect = document.getElementById('start_condition');
        const versionKey = currentVersionKey();
        const world = worldSelect.value; // world ID
        const worldData = (worldDataByVersion[versionKey] || {})[world];
        const state = versionState[versionKey];

        locSelect.innerHTML = '<option value="">-- Select Start Location --</option>';
        condSelect.innerHTML = '<option value="">-- Select Start Condition --</option>';

        if (worldData) {
            (worldData.locations || []).forEach(loc => {
            const option = document.createElement('option');
            option.value = loc.ID;
            option.textContent = loc.Name || loc.ID;
            if (loc.Description) {
                option.title = loc.Description;
            }
            locSelect.appendChild(option);
        });

            (worldData.conditions || []).forEach(cond => {
            const option = document.createElement('option');
            option.value = cond.ID;
            option.textContent = cond.Name || cond.ID;
            if (cond.Description) {
                option.title = cond.Description;
            }
            condSelect.appendChild(option);
        });
        }
        // Validate selections without fallbacks
        const locIDs = new Set(Array.from(locSelect.options).map(o => o.value).filter(v => v));
        const condIDs = new Set(Array.from(condSelect.options).map(o => o.value).filter(v => v));
        clearInvalid(locSelect);
        clearInvalid(condSelect);
        if (state.startLocation) {
            if (locIDs.has(state.startLocation)) {
                locSelect.value = state.startLocation;
            } else {
                locSelect.value = '';
                markInvalid(locSelect, 'Start Location not available for this world/language');
                notifyError('Configured Start Location is not available for this world/language. Please choose a valid location.');
            }
        } else {
            locSelect.value = '';
        }
        if (state.startCondition) {
            if (condIDs.has(state.startCondition)) {
                condSelect.value = state.startCondition;
            } else {
                condSelect.value = '';
                markInvalid(condSelect, 'Start Condition not available for this world/language');
                notifyError('Configured Start Condition is not available for this world/language. Please choose a valid condition.');
            }
        } else {
            condSelect.value = '';
        }
        updateParamsValidity();
    }

    function updateWorldThumb() {
        try {
            if (!worldThumb) return;
            const worldSelect = document.getElementById('world');
            const world = worldSelect ? (worldSelect.value || '').trim() : '';
            const serverId = Number(rootEl.dataset.serverId || '0');
            if (!serverId || !world) {
                worldThumb.style.display = 'none';
                return;
            }
            // Reset display in case a previous error hid the image
            worldThumb.style.removeProperty('display');
            const betaFlag = currentVersionKey() === 'beta';
            const v = encodeURIComponent((betaFlag ? 'beta' : 'release') + '-' + world);
            // Send world ID; server resolves IDs directly
            const url = `/server/${serverId}/world-image?world=${encodeURIComponent(world)}&beta=${betaFlag}&v=${v}`;
            // Force reload if src is same string
            if (worldThumb.src !== window.location.origin + url) {
                worldThumb.src = url;
            } else {
                // Append a tiny nonce to bust cache if the same URL is set
                worldThumb.src = url + `&t=${Date.now()}`;
            }
        } catch (_) { /* no-op */ }
    }

    function populateDifficultyOptions() {
        const diffSelect = document.getElementById('difficulty');
        const versionKey = currentVersionKey();
        const diffs = versionKey === 'beta' ? betaDifficulties : releaseDifficulties;
        const previous = diffSelect ? diffSelect.value : '';
        if (!diffSelect) return;
        diffSelect.innerHTML = '';
        if (!diffs || !diffs.length) {
            const opt = document.createElement('option');
            opt.value = '';
            opt.textContent = 'No difficulties';
            diffSelect.appendChild(opt);
            return;
        }
        diffs.forEach((d) => {
            const opt = document.createElement('option');
            opt.value = d;
            opt.textContent = d;
            diffSelect.appendChild(opt);
        });
        const desired = diffs.includes(initialDifficulty) ? initialDifficulty : (diffs.includes(previous) ? previous : diffs[0]);
        diffSelect.value = desired;
    }

    function populateLanguageOptions() {
        const langSelect = document.getElementById('language');
        if (!langSelect) return;
        const versionKey = currentVersionKey();
        const langs = versionKey === 'beta' ? betaLanguages : releaseLanguages;
        const previous = langSelect.value;
        langSelect.innerHTML = '';
        if (!langs || !langs.length) {
            const opt = document.createElement('option');
            opt.value = '';
            opt.textContent = 'No languages';
            langSelect.appendChild(opt);
            return;
        }
        langs.forEach((l) => {
            const opt = document.createElement('option');
            opt.value = l;
            opt.textContent = l;
            langSelect.appendChild(opt);
        });
        const desired = langs.includes(initialLanguage) ? initialLanguage : (langs.includes(previous) ? previous : langs[0]);
        langSelect.value = desired;
    }

    document.addEventListener('DOMContentLoaded', () => {
        const worldSelect = document.getElementById('world');
        const locSelect = document.getElementById('start_location');
        const condSelect = document.getElementById('start_condition');
        const difficultySelect = document.getElementById('difficulty');
        const languageSelect = document.getElementById('language');
        const langBtn = document.getElementById('btn-language');
        const langMenu = document.getElementById('language-menu');
        const currLangLabel = document.getElementById('current-language');
        const versionRadios = document.querySelectorAll('input[name="beta"]');
        const paramsForm = document.getElementById('startup-params-form');
        const updateParamsBtn = document.getElementById('btn-update-params');
        const modal = document.getElementById('paramChangeModal');
        const modalConfirm = document.getElementById('paramChangeConfirm');
        const modalCancel = document.getElementById('paramChangeCancel');
        const confirmFlag = document.getElementById('confirm-reset-saves-flag');
        // More/Less toggle for Server Control card
        const controlCard = document.querySelector('.card.card-control');
        const moreToggle = document.getElementById('control-more-toggle');
        const moreSection = document.getElementById('server-more-section');
        if (controlCard && moreToggle && moreSection) {
            try {
                const key = `sdsm:server:${rootEl.dataset.serverId}:control:more`;
                const savedState = sessionStorage.getItem(key);
                const initiallyExpanded = savedState === '1';

                const chevronDown = '<svg class="icon-inline" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><polyline points="6 9 12 15 18 9"></polyline></svg>';
                const chevronUp = '<svg class="icon-inline" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><polyline points="18 15 12 9 6 15"></polyline></svg>';

                function renderMoreToggle(expanded) {
                    if (!moreToggle) return;
                    moreToggle.setAttribute('aria-expanded', expanded ? 'true' : 'false');
                    moreToggle.innerHTML = (expanded ? chevronUp : chevronDown) + '<span style="margin-left:6px;">' + (expanded ? 'Less' : 'More') + '</span>';
                    // Match User Management toggle semantics: title reflects Collapse/Expand
                    moreToggle.title = expanded ? 'Collapse' : 'Expand';
                }

                if (initiallyExpanded) {
                    controlCard.classList.add('expanded');
                    renderMoreToggle(true);
                    moreSection.setAttribute('aria-hidden', 'false');
                } else {
                    renderMoreToggle(false);
                }
                moreToggle.addEventListener('click', function(){
                    const expanded = controlCard.classList.toggle('expanded');
                    renderMoreToggle(expanded);
                    moreSection.setAttribute('aria-hidden', expanded ? 'false' : 'true');
                    try { sessionStorage.setItem(key, expanded ? '1' : '0'); } catch(_) {}
                });
            } catch(_) { /* non-fatal */ }
        }

        populateWorldOptions();
        populateDifficultyOptions();
        // Language is no longer a startup parameter; dropdown remains for backward compatibility only if present
        populateLanguageOptions();
        updateWorldThumb();
        // Apply Player Saves preference from URL on first load after creation
        (function(){
            try {
                const params = new URLSearchParams(window.location.search || '');
                const ps = params.get('player_saves') || params.get('ps');
                const sid = Number(rootEl && rootEl.dataset && rootEl.dataset.serverId || '0');
                if (sid && ps !== null) {
                    const key = `sdsm:server:${sid}:player-saves`;
                    const val = (ps === '1' || ps === 'true') ? '1' : '0';
                    try { localStorage.setItem(key, val); } catch(_) {}
                    if (playerSavesToggle) {
                        playerSavesToggle.checked = (val === '1');
                    }
                    // Clean the URL so the param doesn't persist on reloads
                    const url = new URL(window.location.href);
                    url.searchParams.delete('player_saves');
                    url.searchParams.delete('ps');
                    window.history.replaceState({}, document.title, url.toString());
                }
            } catch(_) { /* no-op */ }
        })();


        const tabButtons = document.querySelectorAll('.tab-set .tab-btn');
        const tabContents = document.querySelectorAll('.tab-panel');
        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                tabButtons.forEach(b => b.classList.remove('active'));
                tabContents.forEach(content => content.classList.remove('active'));
                button.classList.add('active');
                const targetId = button.getAttribute('data-target');
                const target = targetId ? document.getElementById(targetId) : null;
                if (target) {
                    target.classList.add('active');
                }
            });
        });

        if (worldSelect) {
            worldSelect.addEventListener('change', () => {
                const versionKey = currentVersionKey();
                const state = versionState[versionKey];
                state.world = worldSelect.value;
                state.startLocation = '';
                state.startCondition = '';
                updateWorldOptions();
                updateWorldThumb();
                clearInvalid(worldSelect);
                updateParamsValidity();
            });
        }

        versionRadios.forEach(radio => {
            radio.addEventListener('change', () => {
                populateWorldOptions();
                populateDifficultyOptions();
                // Do not repopulate startup language; instead update language control options
                try { buildLanguageMenu(); } catch(_) {}
                updateWorldThumb();
            });
        });

        if (difficultySelect) {
            difficultySelect.addEventListener('change', () => {
                // Keep initialDifficulty aligned only for UX fallback decisions
                // Not used as destructive param, so no modal involvement
            });
        }

        // Language control (top-right in Server Info card)
        function getAvailableLanguages() {
            const versionKey = currentVersionKey();
            return versionKey === 'beta' ? betaLanguages : releaseLanguages;
        }

        function closeLanguageMenu() {
            if (!langMenu) return;
            langMenu.classList.remove('active');
            if (langBtn) langBtn.setAttribute('aria-expanded', 'false');
        }

        function buildLanguageMenu() {
            if (!langMenu) return;
            const langs = getAvailableLanguages();
            langMenu.textContent = '';
            if (!langs || !langs.length) {
                const empty = document.createElement('div');
                empty.textContent = 'No languages available';
                empty.style.padding = '6px 8px';
                empty.style.color = 'var(--text-muted, #999)';
                langMenu.appendChild(empty);
                return;
            }
            langs.forEach(l => {
                const item = document.createElement('button');
                item.type = 'button';
                item.className = 'menu-item';
                item.setAttribute('role', 'menuitem');
                item.textContent = l;
                item.addEventListener('click', function(){
                    if (!l) return;
                    // POST set_language asynchronously
                    const sid = Number(rootEl.dataset.serverId || '0');
                    if (!sid) return;
                    fetch(window.location.pathname, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                            'X-Requested-With': 'XMLHttpRequest',
                            'Accept': 'application/json'
                        },
                        body: 'set_language=1&language=' + encodeURIComponent(l),
                        credentials: 'same-origin'
                    }).then((res) => {
                        try {
                            if (typeof window.showToast === 'function') {
                                const type = res.headers.get('X-Toast-Type');
                                const title = res.headers.get('X-Toast-Title');
                                const message = res.headers.get('X-Toast-Message');
                                if (message) window.showToast({ type: type || 'success', title: title || '', message });
                            }
                        } catch(_) {}
                        if (res.ok) {
                            // Update the inline label immediately for feedback
                            if (currLangLabel) currLangLabel.textContent = l;
                            // Reload the page to hydrate all language-dependent data (worlds, locations,
                            // conditions, difficulties, world image) without requiring manual refresh
                            // so the new language takes full effect across the UI.
                            window.location.reload();
                        }
                    }).catch(() => {}).finally(() => {
                        closeLanguageMenu();
                    });
                });
                langMenu.appendChild(item);
            });
        }

        if (langBtn && langMenu) {
            buildLanguageMenu();
            function openLanguageMenu(){
                // With absolute positioning in CSS, just toggle visibility under the button
                langMenu.classList.add('active');
                langBtn.setAttribute('aria-expanded', 'true');
            }
            langBtn.addEventListener('click', function(e){
                e.stopPropagation();
                if (!langMenu.classList.contains('active')) {
                    buildLanguageMenu();
                    openLanguageMenu();
                } else {
                    closeLanguageMenu();
                }
            });
            document.addEventListener('click', function(e){
                if (!langMenu.contains(e.target) && !langBtn.contains(e.target)) {
                    closeLanguageMenu();
                }
            });
            // No reposition needed with absolute anchoring
            window.addEventListener('keydown', function(e){ if(e.key === 'Escape') closeLanguageMenu(); });
        }

        if (locSelect) {
            locSelect.addEventListener('change', () => {
                const state = versionState[currentVersionKey()];
                state.startLocation = locSelect.value;
                if (locSelect.value) clearInvalid(locSelect);
                updateParamsValidity();
            });
        }

        if (condSelect) {
            condSelect.addEventListener('change', () => {
                const state = versionState[currentVersionKey()];
                state.startCondition = condSelect.value;
                if (condSelect.value) clearInvalid(condSelect);
                updateParamsValidity();
            });
        }

        const serverId = Number(rootEl.dataset.serverId || '0');
        updateButton = document.querySelector('button[name="update_server"]');
        progressContainer = document.getElementById('server-update-progress');
        progressFill = progressContainer ? progressContainer.querySelector('.update-progress-fill') : null;
        progressText = progressContainer ? progressContainer.querySelector('.update-progress-text') : null;

        setUpdateButtonDisabled = function(disabled) {
            if (!updateButton) {
                return;
            }
            updateButton.disabled = !!disabled;
            if (disabled) {
                updateButton.setAttribute('aria-disabled', 'true');
            } else {
                updateButton.removeAttribute('aria-disabled');
            }
        };

        function clampPercent(value) {
            if (Number.isNaN(value)) {
                return 0;
            }
            return Math.max(0, Math.min(100, value));
        }

        stopProgressPolling = function() {
            if (progressTimer) {
                clearInterval(progressTimer);
                progressTimer = null;
            }
        };

        startProgressPolling = function() {
            if (!serverId || progressTimer || connectionLost) {
                return;
            }
            progressTimer = setInterval(fetchProgress, 2000);
        };

        refreshUpdateButtonState = function() {
            if (!updateButton) {
                return;
            }
            if (connectionLost || serverIsRunning || serverIsStarting || progressActive) {
                setUpdateButtonDisabled(true);
            } else {
                setUpdateButtonDisabled(false);
            }
        };

        function updateProgressUI(data) {
            if (!progressContainer) {
                return;
            }
            const stage = (data && data.stage ? data.stage : '').trim();
            const percentRaw = data && typeof data.percent === 'number' ? data.percent : parseInt(data && data.percent, 10) || 0;
            const percent = clampPercent(percentRaw);
            const running = !!(data && data.running);
            const hasError = !!(data && data.error);
            const isIdleStage = !running && !hasError && percent === 0 && (stage === '' || stage === 'Idle');

            progressActive = running;

            progressContainer.classList.toggle('active', !isIdleStage);
            progressContainer.classList.toggle('error', hasError);

            if (progressFill) {
                progressFill.style.width = (isIdleStage ? 0 : percent) + '%';
            }

            if (progressText) {
                let text = stage;
                if (hasError) {
                    text = 'Error: ' + data.error;
                } else if (running) {
                    text = text || 'Copying files';
                    text += percent > 0 ? ' (' + percent + '%)' : '...';
                } else if (percent >= 100 && !hasError) {
                    text = text || 'Completed';
                } else if (isIdleStage) {
                    text = 'Idle';
                }
                progressText.textContent = text.trim();
            }

            if (running) {
                startProgressPolling();
            } else {
                stopProgressPolling();
            }

            updateControlButtons();
            refreshUpdateButtonState();
        }

        fetchProgress = function() {
            if (!serverId) {
                return;
            }
            fetch(`/server/${serverId}/progress`, {
                headers: {
                    'Accept': 'application/json'
                },
                credentials: 'same-origin'
            })
                .then(res => (res.ok ? res.json() : null))
                .then(data => {
                    if (data) {
                        updateProgressUI(data);
                    }
                })
                .catch(() => {
                    // Ignore polling errors
                });
        };

        function handleUpdateClick(event) {
            event.preventDefault();
            if (!updateButton || updateButton.disabled || serverIsRunning || serverIsStarting) {
                return;
            }

            progressActive = true;
            updateControlButtons();
            refreshUpdateButtonState();

            if (progressContainer) {
                progressContainer.classList.add('active');
                progressContainer.classList.remove('error');
            }
            if (progressFill) {
                progressFill.style.width = '0%';
            }
            if (progressText) {
                progressText.textContent = 'Starting update...';
            }

            fetch(window.location.pathname, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'X-Requested-With': 'XMLHttpRequest',
                    'Accept': 'application/json'
                },
                body: 'update_server=1',
                credentials: 'same-origin'
            })
                .then(res => {
                    try {
                        if (typeof window.showToast === 'function') {
                            const type = res.headers.get('X-Toast-Type');
                            const title = res.headers.get('X-Toast-Title');
                            const message = res.headers.get('X-Toast-Message');
                            if (message) window.showToast({ type: type || 'info', title: title || '', message });
                        }
                    } catch (_) {}
                    if (!res.ok) {
                        return res.json().then(data => Promise.reject(data));
                    }
                    return res.json();
                })
                .then(() => {
                    fetchProgress();
                    startProgressPolling();
                })
                .catch(err => {
                    const message = err && err.error ? err.error : 'Unable to start update.';
                    updateProgressUI({ stage: 'Error', percent: 0, running: false, error: message });
                    progressActive = false;
                    updateControlButtons();
                    refreshUpdateButtonState();
                });
        }

        if (updateButton) {
            updateButton.addEventListener('click', handleUpdateClick);
        }

        updateServerStatusUI = function(data) {
            if (!data) {
                return;
            }

            const running = !!data.running;
            const starting = !!data.starting;
            serverIsRunning = running;
            serverIsStarting = starting;
            rootEl.dataset.serverRunning = running ? 'true' : 'false';
            rootEl.dataset.serverStarting = starting ? 'true' : 'false';
            serverIsPaused = !!data.paused && running;
            rootEl.dataset.serverPaused = serverIsPaused ? 'true' : 'false';

            if (statusIndicator) {
                statusIndicator.classList.toggle('starting', running && starting);
                statusIndicator.classList.toggle('running', running && !serverIsPaused && !starting);
                statusIndicator.classList.toggle('paused', serverIsPaused && !starting);
                statusIndicator.classList.toggle('stopped', !running);
            }
            // Apply unified pill variant classes to container for visual styling
            if (statusContainer) {
                // Map: running (incl. starting) -> is-running; paused or stopped -> is-stopped
                const useRunningVariant = running && !serverIsPaused; // still consider starting as running variant
                statusContainer.classList.toggle('is-running', useRunningVariant);
                statusContainer.classList.toggle('is-stopped', !useRunningVariant);
            }
            if (statusText) {
                if (starting && running) {
                    statusText.textContent = 'Starting';
                } else if (!running) {
                    statusText.textContent = 'Stopped';
                } else if (serverIsPaused) {
                    statusText.textContent = 'Paused';
                } else {
                    statusText.textContent = 'Running';
                }
            }

            const lastLine = data.last_log_line && data.last_log_line.trim() ? data.last_log_line : 'No log data';
            setTextContent(lastLogLineEl, lastLine);

            setTextContent(startedValueEl, formatDateTimeDisplay(data.server_started, 'Not started'));
            setTextContent(savedValueEl, formatDateTimeDisplay(data.server_saved, 'Not saved'));

            // Error banner (last_error)
            const hasError = !!(data.last_error && String(data.last_error).trim());
            if (errorBanner) {
                showElement(errorBanner, hasError);
            }
            if (hasError) {
                if (errorTextEl) setTextContent(errorTextEl, data.last_error);
                if (errorTimeEl) setTextContent(errorTimeEl, formatDateTimeDisplay(data.last_error_at, '‚Äî'));
            } else {
                if (errorTextEl) setTextContent(errorTextEl, '');
                if (errorTimeEl) setTextContent(errorTimeEl, '');
            }

            // Update storm button label/state first
            try {
                serverIsStorming = !!data.storming;
                if (stormButton) {
                    const label = serverIsStorming ? 'Storm Stop' : 'Storm Start';
                    // Preserve icon markup while updating label
                    stormButton.innerHTML = '<svg class="icon-inline" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" title="Storm"><path d="M19 16.9A5 5 0 0 0 18 7h-1.26A8 8 0 1 0 3 15"/><polyline points="13 11 9 17 15 17 11 23"/></svg>' + label;
                    stormButton.title = serverIsStorming ? 'Stop the storm event' : 'Start a storm event';
                }
            } catch (_) {}

            // Detect new player connections and optionally trigger saveas
            const playersArr = Array.isArray(data.players) ? data.players : [];
            try {
                const currentSet = new Set(playersArr.map(p => (p && (p.steam_id || p.SteamID)) ? String(p.steam_id || p.SteamID) : '').filter(Boolean));
                const enabled = !!(playerSavesToggle && playerSavesToggle.checked);
                if (enabled && serverIsRunning && !serverIsStarting) {
                    const newIds = [];
                    currentSet.forEach(id => { if (!knownLiveSteam.has(id)) newIds.push(id); });
                    if (newIds.length && Number(rootEl.dataset.serverId || '0')) {
                        const sid = Number(rootEl.dataset.serverId);
                        newIds.forEach(id => {
                            const now = new Date();
                            const ts = `${now.getFullYear()}${pad2(now.getMonth()+1)}${pad2(now.getDate())}-${pad2(now.getHours())}${pad2(now.getMinutes())}${pad2(now.getSeconds())}`;
                            const filename = `${id}-${ts}`;
                            fetch(`/api/servers/${sid}/command`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
                                credentials: 'same-origin',
                                body: JSON.stringify({ type: 'console', payload: 'FILE saveas ' + filename })
                            }).then((res) => {
                                try {
                                    if (typeof window.showToast === 'function') {
                                        const type = res.headers.get('X-Toast-Type');
                                        const title = res.headers.get('X-Toast-Title');
                                        const message = res.headers.get('X-Toast-Message');
                                        if (message) window.showToast({ type: type || 'info', title: title || '', message });
                                    }
                                } catch(_) {}
                            }).catch(() => {});
                        });
                    }
                }
                knownLiveSteam = currentSet;
            } catch(_) { knownLiveSteam = new Set(); }

            renderLivePlayers(playersArr);

            // Keep banned set updated before rendering History rows so we can annotate
            if (Array.isArray(data.banned)) {
                try {
                    bannedSteamSet = new Set((data.banned || []).map(b => b && b.steam_id).filter(Boolean));
                } catch (_) { bannedSteamSet = new Set(); }
            } else {
                bannedSteamSet = new Set();
            }

            if (Array.isArray(data.clients)) {
                renderHistoryPlayers(data.clients);
            } else {
                renderHistoryPlayers([]);
            }

            if (Array.isArray(data.chat_messages)) {
                renderChatMessages(data.chat_messages);
            } else {
                renderChatMessages([]);
            }

            if (Array.isArray(data.banned)) {
                renderBanned(data.banned);
            } else {
                renderBanned([]);
            }

            updateControlButtons(data);
            refreshUpdateButtonState();
        };

        fetchStatus = function() {
            if (!serverId) {
                return;
            }
            fetch(`/server/${serverId}/status.json`, {
                headers: {
                    'Accept': 'application/json'
                },
                credentials: 'same-origin'
            })
                .then(res => {
                    if (res.status === 401) {
                        stopStatusUpdates();
                        return null;
                    }
                    if (!res.ok) {
                        throw new Error('Failed to fetch server status');
                    }
                    return res.json();
                })
                .then(data => {
                    statusFailureCount = 0;
                    if (data) {
                        handleConnectionRestored();
                        updateServerStatusUI(data);
                    }
                })
                .catch(() => {
                    statusFailureCount += 1;
                    if (statusFailureCount >= 2) {
                        handleConnectionLost();
                    }
                });
        };

        stopStatusUpdates = function() {
            if (statusTimer) {
                clearInterval(statusTimer);
                statusTimer = null;
            }
        };

        startStatusUpdates = function() {
            if (!serverId || statusTimer || connectionLost) {
                return;
            }
            statusTimer = setInterval(fetchStatus, 4000);
        };

        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                stopStatusUpdates();
                stopProgressPolling();
                stopLogTail();
            } else {
                fetchStatus();
                fetchProgress();
                startStatusUpdates();
                if (progressActive) {
                    startProgressPolling();
                }
                startLogTail();
            }
        });

        refreshUpdateButtonState();
        fetchProgress();
        fetchStatus();
        startStatusUpdates();
        // Initialize logs UI
        initLogsUI();
        fetchLogList();
        startLogTail();
        startLogListRefresh();

        function coreParamsChanged(){
            const currWorld = (document.getElementById('world') && document.getElementById('world').value) || '';
            const currLoc = (document.getElementById('start_location') && document.getElementById('start_location').value) || '';
            const currCond = (document.getElementById('start_condition') && document.getElementById('start_condition').value) || '';
                const initWorldRef = (typeof initialWorldID !== 'undefined' ? initialWorldID : '');
            const initLocRef = (rootEl && rootEl.dataset && rootEl.dataset.startLocation) ? rootEl.dataset.startLocation : (typeof initialStartLocation !== 'undefined' ? initialStartLocation : '');
            const initCondRef = (rootEl && rootEl.dataset && rootEl.dataset.startCondition) ? rootEl.dataset.startCondition : (typeof initialStartCondition !== 'undefined' ? initialStartCondition : '');
            return (currWorld !== initWorldRef) || (currLoc !== initLocRef) || (currCond !== initCondRef);
        }

        function showParamChangeModal(onConfirm, onCancel){
            if (modal) {
                modal.classList.add('active');
                const cleanup = () => {
                    if (modalConfirm) modalConfirm.removeEventListener('click', confirmHandler);
                    if (modalCancel) modalCancel.removeEventListener('click', cancelHandler);
                    modal.removeEventListener('click', backdropHandler);
                };
                const confirmHandler = () => { cleanup(); if (typeof onConfirm === 'function') onConfirm(); };
                const cancelHandler = () => { cleanup(); if (typeof onCancel === 'function') onCancel(); };
                const backdropHandler = (ev) => { if (ev.target === modal) cancelHandler(); };
                if (modalConfirm) modalConfirm.addEventListener('click', confirmHandler, { once: true });
                if (modalCancel) modalCancel.addEventListener('click', cancelHandler, { once: true });
                modal.addEventListener('click', backdropHandler);
                return true;
            }
            return false;
        }

        // Intercept Startup Parameters Update submit with blocking confirm when core params changed
        if (paramsForm && updateParamsBtn) {
            paramsForm.addEventListener('submit', function(e){
                if (window.__sdsmPendingSubmit) return; // allow the second submit after confirm
                const valid = updateParamsValidity();
                if (!valid) {
                    e.preventDefault();
                    notifyError('Cannot apply changes: fix invalid startup parameters highlighted above.');
                    return;
                }
                const changed = coreParamsChanged();
                if (!changed) {
                    return; // allow submit
                }
                e.preventDefault();
                const proceed = () => {
                    // Ensure server gets the expected 'update=true' field
                    let hiddenUpdate = paramsForm.querySelector('input[type="hidden"][name="update"]');
                    if (!hiddenUpdate) {
                        hiddenUpdate = document.createElement('input');
                        hiddenUpdate.type = 'hidden';
                        hiddenUpdate.name = 'update';
                        hiddenUpdate.value = 'true';
                        paramsForm.appendChild(hiddenUpdate);
                    } else {
                        hiddenUpdate.value = 'true';
                    }
                    try { if (confirmFlag) confirmFlag.value = '1'; } catch(_) {}
                    window.__sdsmPendingSubmit = true;
                    paramsForm.submit();
                };
                const canceled = () => {};
                const shown = showParamChangeModal(proceed, () => { try { modal.classList.remove('active'); } catch(_) {} });
                if (!shown) {
                    // Native fallback confirm if custom modal not available
                    if (window.confirm('Changing World, Start Location, or Start Condition will reset (purge) existing saves on next start. Continue?')) {
                        proceed();
                    }
                }
            });

            // Also intercept direct button clicks (some browsers may bypass submit listener in edge cases)
            updateParamsBtn.addEventListener('click', function(e){
                if (window.__sdsmPendingSubmit) return;
                if (!updateParamsValidity()) {
                    e.preventDefault();
                    notifyError('Cannot apply changes: fix invalid startup parameters highlighted above.');
                    return;
                }
                const changed = coreParamsChanged();
                if (!changed) {
                    // No confirmation needed; submit the form with update=true
                    let hiddenUpdate = paramsForm.querySelector('input[type="hidden"][name="update"]');
                    if (!hiddenUpdate) {
                        hiddenUpdate = document.createElement('input');
                        hiddenUpdate.type = 'hidden';
                        hiddenUpdate.name = 'update';
                        hiddenUpdate.value = 'true';
                        paramsForm.appendChild(hiddenUpdate);
                    } else {
                        hiddenUpdate.value = 'true';
                    }
                    paramsForm.submit();
                    return;
                }
                e.preventDefault();
                const proceed = () => {
                    let hiddenUpdate = paramsForm.querySelector('input[type="hidden"][name="update"]');
                    if (!hiddenUpdate) {
                        hiddenUpdate = document.createElement('input');
                        hiddenUpdate.type = 'hidden';
                        hiddenUpdate.name = 'update';
                        hiddenUpdate.value = 'true';
                        paramsForm.appendChild(hiddenUpdate);
                    } else {
                        hiddenUpdate.value = 'true';
                    }
                    try { if (confirmFlag) confirmFlag.value = '1'; } catch(_) {}
                    window.__sdsmPendingSubmit = true;
                    paramsForm.submit();
                };
                const shown = showParamChangeModal(proceed, () => { try { modal.classList.remove('active'); } catch(_) {} });
                if (!shown) {
                    if (window.confirm('Changing World, Start Location, or Start Condition will reset (purge) existing saves on next start. Continue?')) {
                        proceed();
                    }
                }
            });
        }

        // Intercept Chat send form to POST a command to the API
        (function(){
            const chatForm = document.getElementById('chat-send-form');
            const chatInput = document.getElementById('chat-input');
            const chatBtn = document.getElementById('chat-send-button');
            if (!chatForm || !chatInput || !chatBtn || !serverId) return;
            chatForm.addEventListener('submit', function(e){
                e.preventDefault();
                const message = (chatInput.value || '').trim();
                if (!message || chatBtn.disabled) return;
                setButtonDisabled(chatBtn, true);
                toggleButtonSpinner(chatBtn, true);
                fetch(`/api/servers/${serverId}/command`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    credentials: 'same-origin',
                    body: JSON.stringify({ type: 'chat', payload: message })
                })
                .then((res) => {
                    try {
                        if (typeof window.showToast === 'function') {
                            const type = res.headers.get('X-Toast-Type');
                            const title = res.headers.get('X-Toast-Title');
                            const msg = res.headers.get('X-Toast-Message');
                            if (msg) window.showToast({ type: type || 'info', title: title || '', message: msg });
                        }
                    } catch(_) {}
                    if (res.ok) {
                        chatInput.value = '';
                    }
                    // Status polling already updates chat view from logs
                })
                .catch(() => { /* no-op */ })
                .finally(() => { toggleButtonSpinner(chatBtn, false); setButtonDisabled(chatBtn, false); });
            });
        })();

        // Intercept Banned Add form submit for async update
        (function(){
            const addForm = document.getElementById('banned-add-form');
            const input = document.getElementById('ban_steam_id');
            const addBtn = addForm ? addForm.querySelector('button[type="submit"]') : null;
            if (addForm && input) {
                addForm.addEventListener('submit', function(e) {
                    e.preventDefault();
                    const id = (input.value || '').trim();
                    if (!id) return;
                    if (addBtn && addBtn.disabled) return;
                    // Disable input and button while request is in flight
                    if (addBtn) {
                        setButtonDisabled(addBtn, true);
                        toggleButtonSpinner(addBtn, true);
                    }
                    input.disabled = true;
                    fetch(window.location.pathname, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                            'X-Requested-With': 'XMLHttpRequest',
                            'Accept': 'application/json'
                        },
                        body: 'add_ban=1&ban_steam_id=' + encodeURIComponent(id),
                        credentials: 'same-origin'
                    }).then((res) => {
                        try {
                            if (typeof window.showToast === 'function') {
                                const type = res.headers.get('X-Toast-Type');
                                const title = res.headers.get('X-Toast-Title');
                                const message = res.headers.get('X-Toast-Message');
                                if (message) window.showToast({ type: type || 'info', title: title || '', message });
                            }
                        } catch (_) {}
                        input.value = '';
                        fetchStatus();
                    }).catch(() => {
                        // No-op; status poll will reconcile
                    }).finally(() => {
                        if (addBtn) {
                            toggleButtonSpinner(addBtn, false);
                            setButtonDisabled(addBtn, false);
                        }
                        input.disabled = false;
                    });
                });
            }
        })();

        // Intercept Unban button clicks in banned table
        (function(){
            if (!playersBannedBody) return;
            playersBannedBody.addEventListener('click', function(e){
                const btn = e.target.closest && e.target.closest('button[name="unban"]');
                if (!btn) return;
                e.preventDefault();
                const id = (btn.value || '').trim();
                if (!id) return;
                if (btn.disabled) return;
                setButtonDisabled(btn, true);
                toggleButtonSpinner(btn, true);
                fetch(window.location.pathname, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                        'X-Requested-With': 'XMLHttpRequest',
                        'Accept': 'application/json'
                    },
                    body: 'unban=' + encodeURIComponent(id),
                    credentials: 'same-origin'
                }).then((res) => {
                    try {
                        if (typeof window.showToast === 'function') {
                            const type = res.headers.get('X-Toast-Type');
                            const title = res.headers.get('X-Toast-Title');
                            const message = res.headers.get('X-Toast-Message');
                            if (message) window.showToast({ type: type || 'info', title: title || '', message });
                        }
                    } catch (_) {}
                    fetchStatus();
                }).catch(() => {
                    // No-op
                }).finally(() => {
                    toggleButtonSpinner(btn, false);
                    setButtonDisabled(btn, false);
                });
            });
        })();

        // Intercept Start/Stop/Restart to use async fetch with toast + disable buttons during request
        (function(){
            function postAction(param, btn) {
                if (!param) return;
                if (btn && btn.disabled) return;
                if (btn) { setButtonDisabled(btn, true); toggleButtonSpinner(btn, true); }
                fetch(window.location.pathname, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                        'X-Requested-With': 'XMLHttpRequest',
                        'Accept': 'application/json'
                    },
                    body: encodeURIComponent(param) + '=1',
                    credentials: 'same-origin'
                })
                .then((res) => {
                    try {
                        if (typeof window.showToast === 'function') {
                            const type = res.headers.get('X-Toast-Type');
                            const title = res.headers.get('X-Toast-Title');
                            const message = res.headers.get('X-Toast-Message');
                            if (message) window.showToast({ type: type || 'info', title: title || '', message });
                        }
                    } catch (_) {}
                    // status refresh to reflect new state
                    fetchStatus();
                    return res.ok ? res.json().catch(() => ({})) : Promise.resolve({});
                })
                .catch(() => { /* ignore, status poll will reconcile */ })
                .finally(() => {
                    if (btn) { toggleButtonSpinner(btn, false); setButtonDisabled(btn, false); }
                });
            }

            if (startButton) {
                startButton.addEventListener('click', function(e){ e.preventDefault(); postAction('start', startButton); });
            }
            if (stopButton) {
                stopButton.addEventListener('click', function(e){ e.preventDefault(); postAction('stop', stopButton); });
            }
            if (restartButton) {
                restartButton.addEventListener('click', function(e){ e.preventDefault(); postAction('restart', restartButton); });
            }
        })();

        // Save button: sends FILE save console command via API
        (function(){
            if (!saveButton || !serverId) return;
            saveButton.addEventListener('click', function(e){
                e.preventDefault();
                if (saveButton.disabled) return;
                setButtonDisabled(saveButton, true);
                toggleButtonSpinner(saveButton, true);
                fetch(`/api/servers/${serverId}/command`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    credentials: 'same-origin',
                    body: JSON.stringify({ type: 'console', payload: 'FILE save' })
                })
                .then((res) => {
                    try {
                        if (typeof window.showToast === 'function') {
                            const type = res.headers.get('X-Toast-Type');
                            const title = res.headers.get('X-Toast-Title');
                            const message = res.headers.get('X-Toast-Message');
                            if (message) window.showToast({ type: type || 'info', title: title || '', message });
                        }
                    } catch(_) {}
                    fetchStatus();
                })
                .catch(() => { /* no-op */ })
                .finally(() => { toggleButtonSpinner(saveButton, false); setButtonDisabled(saveButton, false); });
            });
        })();

        // Pause/Resume button: sends PAUSE true/false console command via API
        (function(){
            if (!pauseButton || !serverId) return;
            pauseButton.addEventListener('click', function(e){
                e.preventDefault();
                if (pauseButton.disabled) return;
                const isPaused = serverIsPaused;
                const command = isPaused ? 'PAUSE false' : 'PAUSE true';
                setButtonDisabled(pauseButton, true);
                toggleButtonSpinner(pauseButton, true);
                fetch(`/api/servers/${serverId}/command`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    credentials: 'same-origin',
                    body: JSON.stringify({ type: 'console', payload: command })
                })
                .then((res) => {
                    try {
                        if (typeof window.showToast === 'function') {
                            const type = res.headers.get('X-Toast-Type');
                            const title = res.headers.get('X-Toast-Title');
                            const message = res.headers.get('X-Toast-Message');
                            if (message) window.showToast({ type: type || 'info', title: title || '', message });
                        }
                    } catch(_) {}
                    fetchStatus();
                })
                .catch(() => { /* no-op */ })
                .finally(() => { toggleButtonSpinner(pauseButton, false); setButtonDisabled(pauseButton, false); });
            });
        })();

        // Storm Start/Stop button: sends STORM start/stop via API and updates label
        (function(){
            if (!stormButton || !serverId) return;
            stormButton.addEventListener('click', function(e){
                e.preventDefault();
                if (stormButton.disabled) return;
                const cmd = serverIsStorming ? 'STORM stop' : 'STORM start';
                setButtonDisabled(stormButton, true);
                toggleButtonSpinner(stormButton, true);
                fetch(`/api/servers/${serverId}/command`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    credentials: 'same-origin',
                    body: JSON.stringify({ type: 'console', payload: cmd })
                }).then((res) => {
                    try {
                        if (typeof window.showToast === 'function') {
                            const type = res.headers.get('X-Toast-Type');
                            const title = res.headers.get('X-Toast-Title');
                            const message = res.headers.get('X-Toast-Message');
                            if (message) window.showToast({ type: type || 'info', title: title || '', message });
                        }
                    } catch(_) {}
                    fetchStatus();
                }).catch(() => {
                    // no-op; polling will reconcile
                }).finally(() => {
                    toggleButtonSpinner(stormButton, false);
                    setButtonDisabled(stormButton, false);
                });
            });
        })();

        // Cleanup Players buttons: send CLEANUPPLAYERS {dead|disconnected|all}
        (function(){
            function sendCleanup(option, btn){
                if (!serverId || !option) return;
                if (btn && btn.disabled) return;
                if (btn) { setButtonDisabled(btn, true); toggleButtonSpinner(btn, true); }
                const cmd = 'CLEANUPPLAYERS ' + option;
                fetch(`/api/servers/${serverId}/command`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
                    credentials: 'same-origin',
                    body: JSON.stringify({ type: 'console', payload: cmd })
                }).then((res) => {
                    try {
                        if (typeof window.showToast === 'function') {
                            const type = res.headers.get('X-Toast-Type');
                            const title = res.headers.get('X-Toast-Title');
                            const message = res.headers.get('X-Toast-Message');
                            if (message) window.showToast({ type: type || 'info', title: title || '', message });
                        }
                    } catch(_) {}
                    fetchStatus();
                }).catch(() => {
                    // no-op
                }).finally(() => {
                    if (btn) { toggleButtonSpinner(btn, false); setButtonDisabled(btn, false); }
                });
            }

            if (cleanupDeadButton) cleanupDeadButton.addEventListener('click', function(e){ e.preventDefault(); sendCleanup('dead', cleanupDeadButton); });
            if (cleanupDiscButton) cleanupDiscButton.addEventListener('click', function(e){ e.preventDefault(); sendCleanup('disconnected', cleanupDiscButton); });
            if (cleanupAllButton) cleanupAllButton.addEventListener('click', function(e){ e.preventDefault(); sendCleanup('all', cleanupAllButton); });
        })();

        // Make Live/History Kick/Ban async as well (with toasts and button disable)
        (function(){
            // Local safe wrappers in case shared helpers aren't present
            function setBtnDisabled(btn, disabled) {
                try { if (typeof setButtonDisabled === 'function') return setButtonDisabled(btn, disabled); } catch(_) {}
                btn.disabled = !!disabled;
            }
            function toggleBtnSpinner(btn, on) {
                try { if (typeof toggleButtonSpinner === 'function') return toggleButtonSpinner(btn, on); } catch(_) {}
                // Minimal fallback: swap content with a simple spinner dot
                if (!btn) return;
                if (on) {
                    if (!btn.dataset.originalHtml) btn.dataset.originalHtml = btn.innerHTML;
                    btn.innerHTML = '<span class="btn-spinner" aria-hidden="true"></span>';
                } else {
                    if (btn.dataset.originalHtml) { btn.innerHTML = btn.dataset.originalHtml; delete btn.dataset.originalHtml; }
                }
            }
            function showToastFromResponse(res) {
                try {
                    if (typeof window.showToast === 'function') {
                        const type = res.headers.get('X-Toast-Type');
                        const title = res.headers.get('X-Toast-Title');
                        const message = res.headers.get('X-Toast-Message');
                        if (message) window.showToast({ type: type || 'info', title: title || '', message });
                    }
                } catch (_) {}
            }

            function postPlayerAction(action, value, btn) {
                if (!action || !value) return;
                if (btn && btn.disabled) return;
                if (btn) { setBtnDisabled(btn, true); toggleBtnSpinner(btn, true); }
                
                // For kick action, send console command via API
                if (action === 'kick') {
                    if (!serverId) {
                        if (btn) { toggleBtnSpinner(btn, false); setBtnDisabled(btn, false); }
                        return;
                    }
                    fetch(`/api/servers/${serverId}/command`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Accept': 'application/json'
                        },
                        credentials: 'same-origin',
                        body: JSON.stringify({ type: 'console', payload: 'KICK ' + value })
                    })
                    .then((res) => { showToastFromResponse(res); fetchStatus(); return res.ok ? res.json().catch(() => ({})) : Promise.resolve({}); })
                    .catch(() => { /* ignore; polling will reconcile */ })
                    .finally(() => { if (btn) { toggleBtnSpinner(btn, false); setBtnDisabled(btn, false); } });
                    return;
                }
                
                // For ban/unban, use existing form POST
                const body = encodeURIComponent(action) + '=' + encodeURIComponent(value);
                fetch(window.location.pathname, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                        'X-Requested-With': 'XMLHttpRequest',
                        'Accept': 'application/json'
                    },
                    body,
                    credentials: 'same-origin'
                })
                .then((res) => { showToastFromResponse(res); fetchStatus(); return res.ok ? res.json().catch(() => ({})) : Promise.resolve({}); })
                .catch(() => { /* ignore; polling will reconcile */ })
                .finally(() => { if (btn) { toggleBtnSpinner(btn, false); setBtnDisabled(btn, false); } });
            }

            function delegateAction(container) {
                if (!container) return;
                container.addEventListener('click', function(e){
                    const banBtn = e.target.closest && e.target.closest('button[name="ban"]');
                    const unbanBtn = !banBtn && e.target.closest && e.target.closest('button[name="unban"]');
                    const kickBtn = !banBtn && !unbanBtn && e.target.closest && e.target.closest('button[name="kick"]');
                    const btn = banBtn || unbanBtn || kickBtn;
                    if (!btn) return;
                    e.preventDefault();
                    const action = banBtn ? 'ban' : (unbanBtn ? 'unban' : 'kick');
                    const value = (btn.value || '').trim();
                    if (!value) return;
                    postPlayerAction(action, value, btn);
                });
            }

            const liveBody = document.getElementById('players-live-body');
            const historyBody = document.getElementById('players-history-body');
            delegateAction(liveBody);
            delegateAction(historyBody);
        })();
    });

    // -------- Server Logs (tabs + tail) --------
    function renderLogTabs(files) {
        if (!logTabs) return;
        logTabs.textContent = '';
        const hasFiles = Array.isArray(files) && files.length > 0;
        if (logTabsEmpty) logTabsEmpty.style.display = hasFiles ? 'none' : '';
        if (!hasFiles) return;
        files.forEach((name, idx) => {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'log-tab';
            btn.setAttribute('role', 'tab');
            btn.setAttribute('aria-selected', selectedLog === name ? 'true' : 'false');
            const label = document.createElement('span');
            label.className = 'filename';
            label.textContent = name;
            btn.appendChild(label);
            btn.addEventListener('click', function(){
                if (selectedLog === name) return;
                selectedLog = name;
                // update selected states
                const tabs = logTabs.querySelectorAll('.log-tab');
                tabs.forEach(t => t.setAttribute('aria-selected', t === btn ? 'true' : 'false'));
                // reset tail to end and clear viewer, then tail
                logTailOffset = -1;
                logPausedByScroll = false; // resume tailing on new selection
                if (logViewer) logViewer.textContent = '';
                fetchLogTail();
            });
            logTabs.appendChild(btn);
            if (!selectedLog && idx === 0) {
                selectedLog = name;
                btn.setAttribute('aria-selected', 'true');
            }
        });
    }

    function fetchLogList() {
        const serverId = Number(rootEl.dataset.serverId || '0');
        if (!serverId || !logTabs) return;
        fetch(`/api/servers/${serverId}/logs`, { headers: { 'Accept': 'application/json' }, credentials: 'same-origin' })
            .then(r => r.ok ? r.json() : null)
            .then(data => {
                if (!data || !Array.isArray(data.files)) return;
                const prevSelected = selectedLog;
                logFiles = data.files;
                renderLogTabs(logFiles);
                // If previously selected file no longer exists, reset selection and viewer
                if (prevSelected && !logFiles.includes(prevSelected)) {
                    selectedLog = logFiles[0] || '';
                    logTailOffset = -1;
                    if (logViewer) logViewer.textContent = '';
                }
                // Kick off tailing if we have a selection and no timer
                if (selectedLog && !logTimer) {
                    fetchLogTail();
                    startLogTail();
                }
            })
            .catch(() => {});
    }

    function fetchLogTail() {
        const serverId = Number(rootEl.dataset.serverId || '0');
        if (!serverId || !selectedLog || !logViewer || connectionLost) return;
        const params = new URLSearchParams();
        params.set('name', selectedLog);
        params.set('offset', String(logTailOffset));
        params.set('back', String(LOG_TAIL_BACK));
        params.set('max', String(LOG_TAIL_MAX));
        fetch(`/api/servers/${serverId}/log/tail?` + params.toString(), { credentials: 'same-origin' })
            .then(r => r.ok ? r.json() : null)
            .then(data => {
                if (!data) return;
                if (data.reset) {
                    // file rotated/truncated; viewer should show last chunk only
                    logViewer.textContent = '';
                }
                const chunk = typeof data.data === 'string' ? data.data : '';
                if (chunk) {
                    // Determine if we should stick to bottom (only when not paused and currently at bottom)
                    const shouldStick = !logPausedByScroll && isViewerAtBottom();
                    logViewer.textContent += chunk;
                    if (shouldStick) {
                        scrollViewerToBottom();
                    }
                }
                if (typeof data.offset === 'number') {
                    logTailOffset = data.offset;
                }
            })
            .catch(() => {});
    }

    function stopLogTail() {
        if (logTimer) {
            clearInterval(logTimer);
            logTimer = null;
        }
    }

    function startLogTail() {
        if (logTimer || connectionLost) return;
        if (logPausedByScroll) return;
        if (!selectedLog) return;
        logTimer = setInterval(fetchLogTail, 2000);
    }

    function initLogsUI() {
        // If no logs UI present, skip
        if (!logTabs || !logViewer) return;
        // Pause/resume tailing based on user scroll position
        logViewer.addEventListener('scroll', function(){
            // If user scrolls off the bottom, pause tailing. Resume when back at bottom.
            if (isViewerAtBottom()) {
                if (logPausedByScroll) {
                    logPausedByScroll = false;
                    startLogTail();
                }
            } else {
                if (!logPausedByScroll) {
                    logPausedByScroll = true;
                    stopLogTail();
                }
            }
        });
    }

    function startLogListRefresh() {
        if (logListTimer) return;
        logListTimer = setInterval(fetchLogList, 30000);
    }

    function isViewerAtBottom(tolerance){
        if (!logViewer) return false;
        const tol = typeof tolerance === 'number' ? tolerance : 4; // pixels
        return (logViewer.scrollTop + logViewer.clientHeight) >= (logViewer.scrollHeight - tol);
    }

    function scrollViewerToBottom(){
        if (!logViewer) return;
        logViewer.scrollTop = logViewer.scrollHeight;
    }
</script>