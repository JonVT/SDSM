<script>
    // Global guard to prevent ReferenceError if handlers run before DOMContentLoaded sets locals
    window.__sdsmPendingSubmit = window.__sdsmPendingSubmit || false;
    function openLogPopup(serverId) {
        if (typeof window.openInfo === 'function') {
            const body = document.createElement('div');
            body.className = 'log-popup-body';
            body.textContent = 'Loading...';
            window.openInfo({ title: 'Server Log', body, buttonText: 'Close' });
            fetch(`/api/servers/${serverId}/log`, { credentials: 'same-origin' })
                .then(r => r.text())
                .then(log => { body.textContent = log || 'No log data available'; body.scrollTop = body.scrollHeight; })
                .catch(err => { body.textContent = 'Error loading log: ' + err.message; });
        } else {
            // Minimal fallback using askInfo helper
            fetch(`/api/servers/${serverId}/log`, { credentials: 'same-origin' })
                .then(r => r.text())
                .then(log => {
                    askInfo({ title: 'Server Log', message: (log || 'No log data available').slice(0, 4000) });
                })
                .catch(err => { askInfo({ title: 'Server Log Error', message: 'Error loading log: ' + err.message }); });
        }
    }

    function closeLogPopup() {
        const el = document.getElementById('logPopup');
        if (el) el.classList.remove('active');
    }

    // Close popup when clicking outside: no handler needed (no logPopup element present)

    function getStoredTheme() {
        return localStorage.getItem('theme') || 'dark';
    }

    function setTheme(theme) {
        const html = document.documentElement;
        html.setAttribute('data-theme', theme);
        localStorage.setItem('theme', theme);
        const icon = document.getElementById('theme-icon');
        if (icon) {
            icon.textContent = theme === 'dark' ? 'â˜€ï¸' : 'ðŸŒ™';
        }
    }

    function toggleTheme() {
        const current = document.documentElement.getAttribute('data-theme') || getStoredTheme();
        const next = current === 'dark' ? 'light' : 'dark';
        setTheme(next);
    }

    // Unified confirm wrapper using modal helper when available
    function askConfirm(options, fallbackMessage) {
        try {
            if (window.openConfirm) {
                return window.openConfirm(options);
            }
        } catch(_) {}
        return Promise.resolve(window.confirm(fallbackMessage));
    }

    // Unified info wrapper using modal helper when available
    function askInfo(options) {
        try {
            if (window.openInfo) {
                const body = document.createElement('div');
                body.textContent = options.message || '';
                return window.openInfo({ title: options.title || 'Info', body, buttonText: options.buttonText || 'Close' });
            }
        } catch(_) {}
        return Promise.resolve(alert((options.title ? options.title + ': ' : '') + (options.message || '')));
    }

    // Initialize theme
    setTheme(getStoredTheme());
    const rootEl = document.body;
    const statusIndicator = document.getElementById('status-dot-indicator');
    const statusText = document.getElementById('status-dot-text');
    const statusContainer = document.getElementById('status-pill-container');
    const stormStatusPill = document.getElementById('storm-status-pill');
    const startedValueEl = document.getElementById('server-started-value');
    const savedValueEl = document.getElementById('server-saved-value');
    const lastLogLineEl = document.getElementById('last-log-line');
    const playersLiveTable = document.getElementById('players-live-table');
    const playersLiveBody = document.getElementById('players-live-body');
    const playersLiveEmpty = document.getElementById('players-live-empty');
    const playersLiveCount = document.getElementById('players-live-count');
    const playersHistoryTable = document.getElementById('players-history-table');
    const playersHistoryBody = document.getElementById('players-history-body');
    const playersHistoryEmpty = document.getElementById('players-history-empty');
    const startButton = document.getElementById('btn-start');
    const stopButton = document.getElementById('btn-stop');
    const restartButton = document.getElementById('btn-restart');
    const saveMainButton = document.getElementById('btn-save-main');
    const saveMenuButton = document.getElementById('btn-save-menu');
    const saveSplitRoot = document.getElementById('save-split');
    const stormButton = document.getElementById('btn-storm');
    const cleanupDeadButton = document.getElementById('btn-cleanup-dead');
    const cleanupDiscButton = document.getElementById('btn-cleanup-disconnected');
    const cleanupAllButton = document.getElementById('btn-cleanup-all');
    const deleteButton = document.getElementById('btn-delete');
    const updateNeededBadge = document.getElementById('update-needed-badge');
    const connectionBanner = document.getElementById('connection-banner');
    const connectionBannerText = document.getElementById('connection-banner-text');
    const chatMessagesContainer = document.getElementById('chat-messages');
    const chatEmptyState = document.getElementById('chat-empty');
    const chatSendButton = document.getElementById('chat-send-button');
    const chatInput = document.getElementById('chat-input');
    const playersBannedTable = document.getElementById('players-banned-table');
    const playersBannedBody = document.getElementById('players-banned-body');
    const playersBannedEmpty = document.getElementById('players-banned-empty');
    const errorBanner = document.getElementById('server-error-banner');
    const errorTextEl = document.getElementById('server-error-text');
    const errorTimeEl = document.getElementById('server-error-time');
    let bannedSteamSet = new Set();
    const worldThumb = document.querySelector('.world-thumb');
    // Server logs UI elements
    const logTabs = document.getElementById('log-tabs');
    const logTabsEmpty = document.getElementById('log-tabs-empty');
    const logViewer = document.getElementById('log-viewer');
    // Server Logs buttons
    const btnLogRefresh = document.getElementById('sl-refresh');
    const btnLogDownload = document.getElementById('sl-download');
    const btnLogClear = document.getElementById('sl-clear');
    let logFiles = [];
    let selectedLog = '';
    let logTimer = null;
    let logListTimer = null;
    let logTailOffset = -1; // -1 means from end
    let logPausedByScroll = false; // pause tailing when user scrolls off bottom
    const LOG_TAIL_BACK = 8192; // fetch last 8KB on first load / rotation
    const LOG_TAIL_MAX = 65536; // cap per-poll payload

    let serverIsRunning = rootEl.dataset.serverRunning === "true";
    let serverIsPaused = rootEl.dataset.serverPaused === "true";
    let serverIsStarting = rootEl.dataset.serverStarting === "true";
    let serverIsStopping = rootEl.dataset.serverStopping === "true"; // new
    let updateButton = null;
    let progressContainer = null;
    let progressFill = null;
    let progressText = null;
    let progressTimer = null;
    let statusTimer = null;
    let progressActive = false;
    let connectionLost = false;
    let statusFailureCount = 0;
    let reconnectTimer = null;
    let setUpdateButtonDisabled = function() {};
    let stopProgressPolling = function() {};
    let startProgressPolling = function() {};
    let refreshUpdateButtonState = function() {};
    // Stop-button countdown state
    let stoppingCountdownActive = false;
    // Local pill countdown for stopping state
    let pillStoppingInterval = null;
    let pillStoppingRemaining = 0;
    let stopCountdownTimer = null;
    let stopCountdownEnd = 0;
    let stopOriginalHTML = null;
    // Restart spinner state
    let restartingActive = false;
    let restartSawStarting = false;
    let restartOriginalHTML = null;
    let updateServerStatusUI = function() {};
    let fetchProgress = function() {};
    let fetchStatus = function() {};
    let stopStatusUpdates = function() {};
    let startStatusUpdates = function() {};

    let serverIsStorming = false;
    // SCON health UI elements
    const sconPill = document.getElementById('scon-health-pill');
    const sconDot = document.getElementById('scon-health-dot');
    const sconText = document.getElementById('scon-health-text');
    let sconTimer = null;
    // Console command UI
    const consoleInput = document.getElementById('console-command');
    const consoleSendBtn = document.getElementById('btn-console-send');

    function paintSCONHealth(ok) {
        if (!sconPill || !sconDot) return;
        if (ok) {
            sconDot.style.color = 'var(--success-500)';
            sconPill.setAttribute('aria-label', 'SCON Online');
        } else {
            sconDot.style.color = 'var(--danger-500)';
            sconPill.setAttribute('aria-label', 'SCON Offline');
        }
    }

    function pollSCONHealth() {
        const serverId = Number(rootEl && rootEl.dataset && rootEl.dataset.serverId || '0');
        if (!serverId) return;
        fetch(`/api/servers/${serverId}/scon/health`, {
            credentials: 'same-origin',
            cache: 'no-store',
            headers: { 'Accept': 'application/json' }
        })
            .then(r => r.ok ? r.json() : Promise.reject(new Error('probed')))
            .then(data => {
                const ok = !!(data && data.reachable);
                paintSCONHealth(ok);
            })
            .catch(() => {
                paintSCONHealth(false);
            });
    }
    let knownLiveSteam = new Set();
    let playerSavesToggle = null;

    // Saves UI elements
    const savesTabs = document.getElementById('saves-tabs');
    const savesList = document.getElementById('saves-list');
    const savesEmpty = document.getElementById('saves-empty');

    updateControlButtons({ running: serverIsRunning, paused: serverIsPaused, starting: serverIsStarting });

    function pad2(value) {
        return String(value).padStart(2, '0');
    }

    function formatCountdown(seconds) {
        const s = Math.max(0, Math.floor(seconds));
        const m = Math.floor(s / 60);
        const rem = s % 60;
        return `${m}:${pad2(rem)}`;
    }

    /* Duplicate stop countdown helpers removed; canonical versions retained later in file */

    function formatDateTimeDisplay(value, fallback) {
        if (!value) {
            return fallback;
        }
        const dt = new Date(value);
        if (Number.isNaN(dt.getTime())) {
            return fallback;
        }
        return `${pad2(dt.getMonth() + 1)}/${pad2(dt.getDate())}/${dt.getFullYear()} ${pad2(dt.getHours())}:${pad2(dt.getMinutes())}:${pad2(dt.getSeconds())}`;
    }

    // Autosave display format: DDD dd-MMM-yy hh:mm:ss (e.g., Mon 03-Nov-25 11:48:35)
    function formatAutosaveDate(dt) {
        if (!(dt instanceof Date) || Number.isNaN(dt.getTime())) return 'â€”';
        const days = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
        const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
        const ddd = days[dt.getDay()];
        const dd = pad2(dt.getDate());
        const mmm = months[dt.getMonth()];
        const yy = String(dt.getFullYear()).slice(-2);
        const hh = pad2(dt.getHours());
        const mm = pad2(dt.getMinutes());
        const ss = pad2(dt.getSeconds());
        return `${ddd} ${dd}-${mmm}-${yy} ${hh}:${mm}:${ss}`;
    }

    function getSteamIdFromItem(it) {
        try {
            const fname = (it && it.filename ? String(it.filename) : '').trim();
            if (!fname) return '';
            const idx = fname.indexOf('-');
            return idx > 0 ? fname.slice(0, idx) : '';
        } catch(_) { return ''; }
    }

    function renderSaves(items) {
        if (!savesList) return;
        savesList.textContent = '';
        if (!Array.isArray(items) || items.length === 0) {
            showElement(savesList, false);
            showElement(savesEmpty, true);
            return;
        }
        // Sort by datetime descending by default. For Player saves, sort by SteamID asc, then datetime desc
        try {
            const allPlayer = items.length > 0 && items.every(it => (it && String(it.type)) === 'player');
            if (allPlayer) {
                items.sort((a, b) => {
                    const sa = getSteamIdFromItem(a);
                    const sb = getSteamIdFromItem(b);
                    if (sa && sb && sa !== sb) return sa.localeCompare(sb);
                    const ta = a && a.datetime ? new Date(a.datetime).getTime() : 0;
                    const tb = b && b.datetime ? new Date(b.datetime).getTime() : 0;
                    return tb - ta; // newest first within same SteamID
                });
            } else {
                items.sort((a, b) => {
                    const ta = a && a.datetime ? new Date(a.datetime).getTime() : 0;
                    const tb = b && b.datetime ? new Date(b.datetime).getTime() : 0;
                    return tb - ta;
                });
            }
        } catch (_) {}
        // Build a simple table (without headers as requested)
        const table = document.createElement('table');
        table.className = 'table';
        const tbody = document.createElement('tbody');
        items.forEach(it => {
            const tr = document.createElement('tr');
            const name = document.createElement('td');
            // Add extra space between the name and the datetime/action cells
            name.style.paddingRight = '24px';
            // Name cell with stopwatch icon for autosaves
            const nameWrap = document.createElement('span');
            nameWrap.style.display = 'inline-flex';
            nameWrap.style.alignItems = 'center';
            nameWrap.style.gap = '6px';
            const icon = document.createElement('span');
            const type = (it && it.type) ? String(it.type) : '';
            if (type === 'manual') {
                // Disc/floppy icon for manual saves
                icon.innerHTML = '<svg class="icon-inline" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" title="Manual save"><path d="M4 4h13l3 3v13a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2z"></path><path d="M16 4v6H8V4"></path><rect x="8" y="14" width="8" height="6" rx="1"/></svg>';
            } else if (type === 'quick') {
                // Lightning bolt icon for quicksaves
                icon.innerHTML = '<svg class="icon-inline" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" title="Quicksave"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg>';
            } else if (type === 'player') {
                // User icon for player saves
                icon.innerHTML = '<svg class="icon-inline" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" title="Player save"><path d="M20 21v-2a4 4 0 0 0-3-3.87"/><path d="M4 21v-2a4 4 0 0 1 3-3.87"/><circle cx="12" cy="7" r="4"/></svg>';
            } else {
                // Stopwatch icon for autosaves (default)
                icon.innerHTML = '<svg class="icon-inline" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" title="Autosave"><circle cx="12" cy="13" r="8"></circle><line x1="12" y1="5" x2="12" y2="2"></line><line x1="9" y1="2" x2="15" y2="2"></line><line x1="12" y1="13" x2="16" y2="13"></line></svg>';
            }
            const label = document.createElement('span');
            const rawName = (it && it.name) ? String(it.name) : '';
            let displayName = rawName;
            if (!displayName) {
                if (type === 'manual') {
                    displayName = (it && it.filename) ? String(it.filename).replace(/\.save$/i, '') : '';
                } else if (type === 'player') {
                    const sid = getSteamIdFromItem(it);
                    displayName = sid || 'Player';
                } else {
                    displayName = 'Autosave';
                }
            } else if (type !== 'manual' && rawName.toLowerCase() === 'auto') {
                displayName = 'Autosave';
            }
            label.textContent = displayName;
            nameWrap.appendChild(icon);
            nameWrap.appendChild(label);
            name.appendChild(nameWrap);
            const dt = document.createElement('td');
            const d = it && it.datetime ? new Date(it.datetime) : null;
            // Lay out time on the left and actions on the right with comfortable spacing
            dt.style.display = 'flex';
            dt.style.alignItems = 'center';
            dt.style.justifyContent = 'space-between';
            dt.style.flexWrap = 'nowrap';
            dt.style.gap = '10px';
            const timeSpan = document.createElement('span');
            timeSpan.textContent = d && !Number.isNaN(d.getTime()) ? formatAutosaveDate(d) : 'â€”';
            const actions = document.createElement('span');
            actions.style.whiteSpace = 'nowrap';
            actions.style.marginLeft = '12px';
            // Load button
            const btnLoad = document.createElement('button');
            btnLoad.type = 'button';
            btnLoad.className = 'btn btn-primary btn-icon btn-sm btn-load-save';
            // More descriptive tooltip with context
            try {
                const fileLabel = (it && it.filename ? String(it.filename) : '').trim();
                const tip = displayName
                    ? `Load "${displayName}"${fileLabel ? ` (file: ${fileLabel})` : ''} â€” replaces current world state`
                    : (fileLabel ? `Load "${fileLabel}" â€” replaces current world state` : 'Load this save â€” replaces current world state');
                btnLoad.title = tip;
            } catch(_) { btnLoad.title = 'Load this save â€” replaces current world state'; }
            btnLoad.setAttribute('aria-label', 'Load save');
            btnLoad.dataset.filename = it && it.filename ? it.filename : '';
            btnLoad.dataset.path = it && it.path ? it.path : '';
            btnLoad.dataset.type = type || 'auto';
            btnLoad.innerHTML = '<svg class="icon-inline" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>';
            // Delete button
            const btnDel = document.createElement('button');
            btnDel.type = 'button';
            btnDel.className = 'btn btn-danger btn-icon btn-sm btn-delete-save';
            btnDel.title = 'Delete this save';
            btnDel.setAttribute('aria-label', 'Delete save');
            btnDel.dataset.filename = it && it.filename ? it.filename : '';
            btnDel.dataset.type = type || 'auto';
            btnDel.style.marginLeft = '6px';
            btnDel.innerHTML = '<svg class="icon-inline" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><polyline points="3 6 5 6 21 6"/><path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"/><path d="M10 11v6"/><path d="M14 11v6"/><path d="M9 6V4a2 2 0 0 1 2-2h2a2 2 0 0 1 2 2v2"/></svg>';
            actions.appendChild(btnLoad);
            actions.appendChild(btnDel);
            dt.appendChild(timeSpan);
            dt.appendChild(actions);
            tr.appendChild(name); tr.appendChild(dt);
            tbody.appendChild(tr);
        });
        table.appendChild(tbody);
        savesList.appendChild(table);
        showElement(savesEmpty, false);
        showElement(savesList, true, 'block');
    }

    function fetchAutoSaves() {
        const serverId = rootEl.dataset.serverId;
        if (!serverId) return;
        fetch(`/api/servers/${serverId}/saves?type=auto`, {
            credentials: 'same-origin',
            cache: 'no-store',
            headers: { 'Accept': 'application/json' }
        })
            .then(r => r.ok ? r.json() : Promise.reject(new Error('Failed to load saves')))
            .then(data => {
                renderSaves((data && data.items) || []);
            })
            .catch(() => {
                renderSaves([]);
            });
    }

    function fetchManualSaves() {
        const serverId = rootEl.dataset.serverId;
        if (!serverId) return;
        fetch(`/api/servers/${serverId}/saves?type=manual`, {
            credentials: 'same-origin',
            cache: 'no-store',
            headers: { 'Accept': 'application/json' }
        })
            .then(r => r.ok ? r.json() : Promise.reject(new Error('Failed to load saves')))
            .then(data => {
                renderSaves((data && data.items) || []);
            })
            .catch(() => {
                renderSaves([]);
            });
    }

    function fetchAllSaves() {
        const serverId = rootEl.dataset.serverId;
        if (!serverId) return;
        const reqs = [
            fetch(`/api/servers/${serverId}/saves?type=auto`, { credentials: 'same-origin', cache: 'no-store', headers: { 'Accept': 'application/json' } }).then(r => r.ok ? r.json() : { items: [] }).catch(() => ({ items: [] })),
            fetch(`/api/servers/${serverId}/saves?type=quick`, { credentials: 'same-origin', cache: 'no-store', headers: { 'Accept': 'application/json' } }).then(r => r.ok ? r.json() : { items: [] }).catch(() => ({ items: [] })),
            fetch(`/api/servers/${serverId}/saves?type=manual`, { credentials: 'same-origin', cache: 'no-store', headers: { 'Accept': 'application/json' } }).then(r => r.ok ? r.json() : { items: [] }).catch(() => ({ items: [] })),
        ];
        Promise.all(reqs).then(([autoRes, quickRes, manRes]) => {
            const a = Array.isArray(autoRes.items) ? autoRes.items : [];
            const q = Array.isArray(quickRes.items) ? quickRes.items : [];
            const m = Array.isArray(manRes.items) ? manRes.items : [];
            const merged = a.concat(q).concat(m);
            // Sort by datetime desc if available
            merged.sort((x, y) => {
                const dx = x && x.datetime ? new Date(x.datetime).getTime() : 0;
                const dy = y && y.datetime ? new Date(y.datetime).getTime() : 0;
                return dy - dx;
            });
            renderSaves(merged);
        }).catch(() => renderSaves([]));
    }

    function renderPlayerSaves(groups) {
        if (!savesList) return;
        savesList.textContent = '';
        const arr = Array.isArray(groups) ? groups.slice() : [];
        if (arr.length === 0) {
            showElement(savesList, false);
            showElement(savesEmpty, true);
            return;
        }
        // Sort groups by name asc (fallback steam id)
        arr.sort((a, b) => {
            const an = (a && a.name ? String(a.name) : '').toLowerCase().trim();
            const bn = (b && b.name ? String(b.name) : '').toLowerCase().trim();
            if (an === bn) {
                const as = (a && a.steam_id ? String(a.steam_id) : '');
                const bs = (b && b.steam_id ? String(b.steam_id) : '');
                return as.localeCompare(bs);
            }
            if (!an) return 1;
            if (!bn) return -1;
            return an.localeCompare(bn);
        });
        const table = document.createElement('table');
        table.className = 'table';
        const tbody = document.createElement('tbody');
        arr.forEach(g => {
            const steam = g && g.steam_id ? String(g.steam_id) : '';
            const pname = g && g.name ? String(g.name) : '';
            // Group header row (click to expand/collapse)
            const hr = document.createElement('tr');
            hr.className = 'player-header';
            hr.dataset.group = steam;
            hr.setAttribute('aria-expanded', 'false');
            const hname = document.createElement('td');
            hname.colSpan = 2;
            const wrap = document.createElement('div');
            wrap.style.display = 'flex';
            wrap.style.alignItems = 'center';
            wrap.style.justifyContent = 'space-between';
            wrap.style.gap = '12px';
            const left = document.createElement('div');
            left.style.display = 'inline-flex';
            left.style.alignItems = 'center';
            left.style.gap = '10px';
            const caret = document.createElement('span');
            caret.className = 'player-caret';
            caret.innerHTML = '<svg class="icon-inline" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><polyline points="6 9 12 15 18 9"/></svg>';
            const label = document.createElement('span');
            label.textContent = pname ? `${pname} (${steam})` : steam;
            left.appendChild(caret);
            left.appendChild(label);
            const right = document.createElement('div');
            right.style.marginLeft = '16px';
            // Delete all player files (no exclusion)
            const btnDelAll = document.createElement('button');
            btnDelAll.type = 'button';
            btnDelAll.className = 'btn btn-warning btn-icon btn-delete-all-player';
            btnDelAll.title = 'Delete all files for this player (does not exclude)';
            btnDelAll.setAttribute('aria-label', 'Delete all player files');
            btnDelAll.dataset.steamId = steam;
            btnDelAll.innerHTML = '<svg class="icon-inline" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><polyline points="3 6 5 6 21 6"/><path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"/><path d="M10 11v6"/><path d="M14 11v6"/><path d="M9 6V4a2 2 0 0 1 2-2h2a2 2 0 0 1 2 2v2"/></svg>';
            right.appendChild(btnDelAll);
            const btnExclude = document.createElement('button');
            btnExclude.type = 'button';
            btnExclude.className = 'btn btn-danger btn-icon btn-exclude-player';
            btnExclude.title = 'Delete + Exclude (remove files and exclude from future player saves)';
            btnExclude.setAttribute('aria-label', 'Delete player (exclude from player saves)');
            btnExclude.dataset.steamId = steam;
            btnExclude.innerHTML = '<svg class="icon-inline" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><polyline points="3 6 5 6 21 6"/><path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"/><path d="M10 11v6"/><path d="M14 11v6"/><path d="M9 6V4a2 2 0 0 1 2-2h2a2 2 0 0 1 2 2v2"/></svg>';
            right.appendChild(btnExclude);
            wrap.appendChild(left);
            wrap.appendChild(right);
            hname.appendChild(wrap);
            hr.appendChild(hname);
            tbody.appendChild(hr);
            // Child rows: saves for this player, sorted by datetime desc (initially hidden)
            const items = Array.isArray(g.items) ? g.items.slice() : [];
            items.sort((a, b) => {
                const ta = a && a.datetime ? new Date(a.datetime).getTime() : 0;
                const tb = b && b.datetime ? new Date(b.datetime).getTime() : 0;
                return tb - ta;
            });
            items.forEach(it => {
                const tr = document.createElement('tr');
                tr.className = 'player-child hidden';
                tr.dataset.group = steam;
                const name = document.createElement('td');
                name.style.paddingRight = '24px';
                const iconOnly = document.createElement('span');
                iconOnly.innerHTML = '<svg class="icon-inline" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" title="Player save"><path d="M20 21v-2a4 4 0 0 0-3-3.87"/><path d="M4 21v-2a4 4 0 0 1 3-3.87"/><circle cx="12" cy="7" r="4"/></svg>';
                name.appendChild(iconOnly);
                const dt = document.createElement('td');
                dt.style.display = 'flex';
                dt.style.alignItems = 'center';
                dt.style.justifyContent = 'space-between';
                dt.style.gap = '10px';
                const d = it && it.datetime ? new Date(it.datetime) : null;
                const timeSpan = document.createElement('span');
                timeSpan.textContent = d && !Number.isNaN(d.getTime()) ? formatAutosaveDate(d) : 'â€”';
                const actions = document.createElement('span');
                actions.style.whiteSpace = 'nowrap';
                actions.style.marginLeft = '12px';
                const btnLoad = document.createElement('button');
                btnLoad.type = 'button';
                btnLoad.className = 'btn btn-primary btn-icon btn-sm btn-load-save';
                // Tooltip: include timestamp and filename when available
                try {
                    const fileLabel = (it && it.filename ? String(it.filename) : '').trim();
                    const dateStr = (d && !Number.isNaN(d.getTime())) ? formatAutosaveDate(d) : '';
                    const when = dateStr ? `from ${dateStr}` : '';
                    const detail = fileLabel ? `${when ? when + ' ' : ''}(file: ${fileLabel})` : when;
                    btnLoad.title = `Load player save ${detail} â€” replaces current world state`;
                } catch(_) { btnLoad.title = 'Load this save â€” replaces current world state'; }
                btnLoad.setAttribute('aria-label', 'Load save');
                btnLoad.dataset.filename = it && it.filename ? it.filename : '';
                btnLoad.dataset.path = it && it.path ? it.path : '';
                btnLoad.dataset.type = 'player';
                btnLoad.innerHTML = '<svg class="icon-inline" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>';
                actions.appendChild(btnLoad);
                // Per-file delete button for player save
                const btnDel = document.createElement('button');
                btnDel.type = 'button';
                btnDel.className = 'btn btn-danger btn-icon btn-sm btn-delete-save';
                btnDel.title = 'Delete this save';
                btnDel.setAttribute('aria-label', 'Delete save');
                btnDel.dataset.filename = it && it.filename ? it.filename : '';
                btnDel.dataset.type = 'player';
                btnDel.style.marginLeft = '6px';
                btnDel.innerHTML = '<svg class="icon-inline" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><polyline points="3 6 5 6 21 6"/><path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"/><path d="M10 11v6"/><path d="M14 11v6"/><path d="M9 6V4a2 2 0 0 1 2-2h2a 2 2 0 0 1 2 2v 2"/></svg>';
                actions.appendChild(btnDel);
                dt.appendChild(timeSpan);
                dt.appendChild(actions);
                tr.appendChild(name);
                tr.appendChild(dt);
                tbody.appendChild(tr);
            });
        });
        table.appendChild(tbody);
        savesList.appendChild(table);
        showElement(savesEmpty, false);
        showElement(savesList, true, 'block');
    }

    function fetchPlayerSaves() {
        const serverId = rootEl.dataset.serverId;
        if (!serverId) return;
        fetch(`/api/servers/${serverId}/saves?type=player`, {
            credentials: 'same-origin',
            cache: 'no-store',
            headers: { 'Accept': 'application/json' }
        })
            .then(r => r.ok ? r.json() : Promise.reject(new Error('Failed to load saves')))
            .then(data => {
                const groups = (data && Array.isArray(data.groups)) ? data.groups : [];
                renderPlayerSaves(groups);
            })
            .catch(() => {
                renderPlayerSaves([]);
            });
    }

    function fetchQuickSaves() {
        const serverId = rootEl.dataset.serverId;
        if (!serverId) return;
        fetch(`/api/servers/${serverId}/saves?type=quick`, {
            credentials: 'same-origin',
            cache: 'no-store',
            headers: { 'Accept': 'application/json' }
        })
            .then(r => r.ok ? r.json() : Promise.reject(new Error('Failed to load saves')))
            .then(data => {
                renderSaves((data && data.items) || []);
            })
            .catch(() => {
                renderSaves([]);
            });
    }

    // Bind saves tab interactions (first pass: Auto only)
    if (savesTabs) {
        savesTabs.addEventListener('click', (e) => {
            const btn = e.target.closest('.tab');
            if (!btn) return;
            e.preventDefault();
            savesTabs.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            btn.classList.add('active');
            const filter = btn.getAttribute('data-save-filter');
            if (filter === 'auto') {
                fetchAutoSaves();
            } else if (filter === 'quick') {
                fetchQuickSaves();
            } else if (filter === 'manual') {
                fetchManualSaves();
            } else if (filter === 'player') {
                fetchPlayerSaves();
            } else if (filter === 'all') {
                fetchAllSaves();
            } else {
                // Not implemented yet; show empty state
                renderSaves([]);
            }
        });
        // If Auto tab is already active on load, fetch immediately
        try {
            const activeTab = savesTabs.querySelector('.tab.active');
            const activeFilter = activeTab ? activeTab.getAttribute('data-save-filter') : '';
            if (activeFilter === 'auto') {
                fetchAutoSaves();
            } else if (activeFilter === 'quick') {
                fetchQuickSaves();
            } else if (activeFilter === 'manual') {
                fetchManualSaves();
            } else if (activeFilter === 'player') {
                fetchPlayerSaves();
            } else if (activeFilter === 'all') {
                fetchAllSaves();
            }
        } catch(_) {}
    }

    // Delegated handlers for Load/Delete in saves list
    if (savesList) {
        savesList.addEventListener('click', function(e){
            const excludeBtn = e.target.closest && e.target.closest('.btn-exclude-player');
            const delAllBtn = e.target.closest && e.target.closest('.btn-delete-all-player');
            const loadBtn = e.target.closest && e.target.closest('.btn-load-save');
            const delBtn = e.target.closest && e.target.closest('.btn-delete-save');
            const headerRow = e.target.closest && e.target.closest('tr.player-header');
            const serverId = Number(rootEl.dataset.serverId || '0');
            if (!serverId) return;
            if (delAllBtn) {
                e.preventDefault();
                const steamId = (delAllBtn.dataset.steamId || '').trim();
                if (!steamId) return;
                e.stopPropagation();
                function proceed(){
                    delAllBtn.disabled = true;
                    fetch(`/api/servers/${serverId}/player-saves/delete-all`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
                        credentials: 'same-origin',
                        body: JSON.stringify({ steam_id: steamId })
                    }).then((res) => {
                        try {
                            if (typeof window.showToast === 'function') {
                                const typeH = res.headers.get('X-Toast-Type');
                                const title = res.headers.get('X-Toast-Title');
                                const message = res.headers.get('X-Toast-Message');
                                if (message) window.showToast({ type: typeH || 'success', title: title || '', message });
                            }
                        } catch(_) {}
                        fetchPlayerSaves();
                    }).catch(() => {}).finally(() => { delAllBtn.disabled = false; });
                }
                askConfirm({
                    title: 'Delete All Player Files',
                    body: 'Delete all save files for this player? This does not exclude the player from future saves.',
                    confirmText: 'Delete All',
                    cancelText: 'Cancel',
                    danger: true,
                    icon: 'âš '
                }, 'Delete all files for this player?').then(ok => { if (ok) proceed(); });
                return;
            }
            if (headerRow && !excludeBtn) {
                e.preventDefault();
                const group = headerRow.dataset.group || '';
                if (!group) return;
                const expanded = headerRow.getAttribute('aria-expanded') === 'true';
                headerRow.setAttribute('aria-expanded', expanded ? 'false' : 'true');
                const childs = savesList.querySelectorAll(`tr.player-child[data-group="${group}"]`);
                childs.forEach(row => {
                    if (expanded) {
                        row.classList.add('hidden');
                    } else {
                        row.classList.remove('hidden');
                    }
                });
                return;
            }
            if (excludeBtn) {
                e.preventDefault();
                const steamId = (excludeBtn.dataset.steamId || '').trim();
                if (!steamId) return;
                e.stopPropagation();
                function proceed(){
                    excludeBtn.disabled = true;
                    fetch(`/api/servers/${serverId}/player-saves/exclude`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
                        credentials: 'same-origin',
                        body: JSON.stringify({ steam_id: steamId })
                    }).then((res) => {
                        try {
                            if (typeof window.showToast === 'function') {
                                const typeH = res.headers.get('X-Toast-Type');
                                const title = res.headers.get('X-Toast-Title');
                                const message = res.headers.get('X-Toast-Message');
                                if (message) window.showToast({ type: typeH || 'success', title: title || '', message });
                            }
                        } catch(_) {}
                        fetchPlayerSaves();
                    }).catch(() => {}).finally(() => { excludeBtn.disabled = false; });
                }
                askConfirm({
                    title: 'Delete + Exclude Player',
                    body: 'Delete all files for this player and exclude them from future player saves?',
                    confirmText: 'Delete + Exclude',
                    cancelText: 'Cancel',
                    danger: true,
                    icon: 'âš '
                }, 'Delete files and exclude this player from future saves?').then(ok => { if (ok) proceed(); });
                return;
            }
            if (loadBtn) {
                e.preventDefault();
                const path = (loadBtn.dataset.path || '').trim();
                const name = (loadBtn.dataset.filename || '').trim();
                if (!path && !name) return;
                const type = (loadBtn.dataset.type || 'auto');
                function doLoad(){
                    loadBtn.disabled = true;
                    fetch(`/api/servers/${serverId}/load`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
                        credentials: 'same-origin',
                        body: JSON.stringify({ type, name })
                    }).then((res) => {
                        try {
                            if (typeof window.showToast === 'function') {
                                const type = res.headers.get('X-Toast-Type');
                                const title = res.headers.get('X-Toast-Title');
                                const message = res.headers.get('X-Toast-Message');
                                if (message) window.showToast({ type: type || 'info', title: title || '', message });
                            }
                        } catch(_) {}
                    }).catch(() => {
                        // no-op
                    }).finally(() => { loadBtn.disabled = false; });
                }
                askConfirm({
                    title: 'Load Save',
                    body: 'Load this save? The current world state will be replaced.',
                    confirmText: 'Load',
                    cancelText: 'Cancel',
                    icon: 'â†»'
                }, 'Load this save? The current world state will be replaced.').then(ok => { if (ok) doLoad(); });
                return;
            }
            if (delBtn) {
                e.preventDefault();
                const name = (delBtn.dataset.filename || '').trim();
                const type = (delBtn.dataset.type || 'auto');
                if (!name) return;
                function doDelete(){
                    delBtn.disabled = true;
                    const url = new URL(window.location.origin + `/api/servers/${serverId}/saves`);
                    url.searchParams.set('type', type);
                    url.searchParams.set('name', name);
                    fetch(url.toString(), {
                        method: 'DELETE',
                        credentials: 'same-origin',
                        headers: { 'Accept': 'application/json' }
                    }).then((res) => {
                        try {
                            if (typeof window.showToast === 'function') {
                                const typeH = res.headers.get('X-Toast-Type');
                                const title = res.headers.get('X-Toast-Title');
                                const message = res.headers.get('X-Toast-Message');
                                if (message) window.showToast({ type: typeH || 'success', title: title || '', message });
                            }
                        } catch(_) {}
                        // Refresh the currently active tab after deletion
                        try {
                            const activeTab = savesTabs.querySelector('.tab.active');
                            const filter = activeTab ? activeTab.getAttribute('data-save-filter') : '';
                            if (filter === 'auto') fetchAutoSaves();
                            else if (filter === 'quick') fetchQuickSaves();
                            else if (filter === 'manual') fetchManualSaves();
                            else if (filter === 'player') fetchPlayerSaves();
                            else fetchAllSaves();
                        } catch(_) { fetchAllSaves(); }
                    }).catch(() => {
                        // no-op
                    }).finally(() => { delBtn.disabled = false; });
                }
                askConfirm({
                    title: 'Delete Save',
                    body: 'Delete this save file permanently?',
                    confirmText: 'Delete',
                    cancelText: 'Cancel',
                    danger: true,
                    icon: 'ðŸ—‘'
                }, 'Delete this save file permanently?').then(ok => { if (ok) doDelete(); });
            }
        });
    }

    function formatTimeDisplay(value, fallback) {
        if (!value) {
            return fallback;
        }
        const dt = new Date(value);
        if (Number.isNaN(dt.getTime())) {
            return fallback;
        }
        return `${pad2(dt.getHours())}:${pad2(dt.getMinutes())}`;
    }

    function setTextContent(el, text) {
        if (el) {
            el.textContent = text;
        }
    }

    function showElement(el, shouldShow, displayValue) {
        if (!el) {
            return;
        }
        // Also toggle a generic 'hidden' class if present to avoid CSS overriding inline display
        try {
            if (shouldShow) {
                el.classList.remove('hidden');
            } else {
                el.classList.add('hidden');
            }
        } catch(_) {}
        if (shouldShow) {
            if (displayValue) {
                el.style.display = displayValue;
            } else {
                // Set to initial to override any stylesheet default without relying on removal
                el.style.display = '';
            }
        } else {
            el.style.display = 'none';
        }
    }

    function setButtonDisabled(btn, disabled) {
        if (!btn) {
            return;
        }
        const isDisabled = !!disabled;
        btn.disabled = isDisabled;
        if (isDisabled) {
            btn.setAttribute('aria-disabled', 'true');
        } else {
            btn.removeAttribute('aria-disabled');
        }
    }

    function toggleButtonSpinner(btn, on) {
        if (!btn) return;
        btn.setAttribute('aria-busy', on ? 'true' : 'false');
        let sp = btn.querySelector('.btn-spinner');
        if (on) {
            if (!sp) {
                sp = document.createElement('span');
                sp.className = 'btn-spinner';
                sp.setAttribute('aria-hidden', 'true');
                btn.appendChild(sp);
            }
        } else if (sp) {
            sp.remove();
        }
    }

    // ---- Stop-button countdown helpers ----
    function formatCountdown(totalSeconds) {
        const s = Math.max(0, Math.floor(Number(totalSeconds) || 0));
        const m = Math.floor(s / 60);
        const r = s % 60;
        return `${m}:${pad2(r)}`;
    }

    function setStopButtonLabel(label) {
        if (!stopButton) return;
        // Capture icon markup on first use
        if (stopOriginalHTML == null) {
            stopOriginalHTML = stopButton.innerHTML;
        }
        let iconHTML = '';
        try {
            const svg = stopButton.querySelector('svg');
            if (svg) iconHTML = svg.outerHTML;
        } catch(_) {}
        if (!iconHTML && stopOriginalHTML) {
            // Fallback to original until next capture
            const tmp = document.createElement('div');
            tmp.innerHTML = stopOriginalHTML;
            const s = tmp.querySelector('svg');
            if (s) iconHTML = s.outerHTML;
        }
        stopButton.innerHTML = (iconHTML ? iconHTML : '') + label;
        // If countdown active, ensure spinner remains visible
        if (stoppingCountdownActive) {
            toggleButtonSpinner(stopButton, true);
        }
    }

    function startStopCountdown() {
        if (!stopButton) return;
        if (stoppingCountdownActive) return;
        const delay = Math.max(0, parseInt(rootEl.dataset.shutdownDelay || '0', 10));
        stoppingCountdownActive = true;
        setButtonDisabled(stopButton, true);
        if (delay <= 0) {
            setStopButtonLabel('Stopping');
            toggleButtonSpinner(stopButton, true);
            return; // wait for server to report stopped
        }
        const now = Date.now();
        stopCountdownEnd = now + delay * 1000;
        toggleButtonSpinner(stopButton, true);
        // Immediate paint
        const firstLeft = Math.max(0, Math.ceil((stopCountdownEnd - Date.now()) / 1000));
        setStopButtonLabel(`Stopping (${formatCountdown(firstLeft)})`);
        // Tick every 500ms until zero; then keep "Stopping" until server stops
        stopCountdownTimer = window.setInterval(() => {
            const left = Math.ceil((stopCountdownEnd - Date.now()) / 1000);
            if (left > 0) {
                setStopButtonLabel(`Stopping (${formatCountdown(left)})`);
            } else {
                window.clearInterval(stopCountdownTimer);
                stopCountdownTimer = null;
                setStopButtonLabel('Stopping');
            }
        }, 500);
    }

    function clearStopCountdown() {
        if (stopCountdownTimer) {
            try { window.clearInterval(stopCountdownTimer); } catch(_) {}
            stopCountdownTimer = null;
        }
        stoppingCountdownActive = false;
        stopCountdownEnd = 0;
        // Restore original label
        if (stopButton) {
            try {
                // Reset to default markup text "Stop" with icon
                const icon = stopButton.querySelector('svg');
                const iconHTML = icon ? icon.outerHTML : '';
                stopButton.innerHTML = iconHTML + 'Stop';
            } catch(_) {
                stopButton.textContent = 'Stop';
            }
            toggleButtonSpinner(stopButton, false);
            // Let button enabled/visibility be driven by updateControlButtons
        }
    }

    // ---- Restart spinner helpers ----
    function setRestartButtonLabel(label) {
        if (!restartButton) return;
        if (restartOriginalHTML == null) {
            restartOriginalHTML = restartButton.innerHTML;
        }
        let iconHTML = '';
        try {
            const svg = restartButton.querySelector('svg');
            if (svg) iconHTML = svg.outerHTML;
        } catch(_) {}
        if (!iconHTML && restartOriginalHTML) {
            const tmp = document.createElement('div');
            tmp.innerHTML = restartOriginalHTML;
            const s = tmp.querySelector('svg');
            if (s) iconHTML = s.outerHTML;
        }
        restartButton.innerHTML = (iconHTML ? iconHTML : '') + label;
        if (restartingActive) toggleButtonSpinner(restartButton, true);
    }

    function startRestartSpinner() {
        if (!restartButton) return;
        if (restartingActive) return;
        restartingActive = true;
        restartSawStarting = false;
        setButtonDisabled(restartButton, true);
        toggleButtonSpinner(restartButton, true);
        setRestartButtonLabel('Restarting');
    }

    function clearRestartSpinner() {
        if (!restartButton) { restartingActive = false; restartSawStarting = false; return; }
        restartingActive = false;
        restartSawStarting = false;
        try {
            const icon = restartButton.querySelector('svg');
            const iconHTML = icon ? icon.outerHTML : '';
            restartButton.innerHTML = iconHTML + 'Restart';
        } catch(_) {
            restartButton.textContent = 'Restart';
        }
        toggleButtonSpinner(restartButton, false);
        // Button disabled/enabled managed by updateControlButtons
    }

    function updateLiveCount(count) {
        if (!playersLiveCount) {
            return;
        }
        const value = Number(count) || 0;
        playersLiveCount.textContent = value === 1 ? '1 online' : `${value} online`;
    }

    function createTextCell(text) {
        const td = document.createElement('td');
        td.textContent = text;
        return td;
    }

    function createPlayerNameCell(player, opts) {
        const td = document.createElement('td');
        const wrapper = document.createElement('span');
        wrapper.className = 'player-name';

        if (player && player.is_admin) {
            const badge = document.createElement('span');
            badge.className = 'player-admin-icon';
            badge.title = 'Admin';
            badge.setAttribute('aria-label', 'Admin');
            badge.textContent = 'ðŸ›¡ï¸';
            wrapper.appendChild(badge);
        }

        // Optional banned indicator when requested (used on History tab)
        if (opts && opts.banned) {
            const bannedIcon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            bannedIcon.setAttribute('class', 'icon-inline player-banned-icon');
            bannedIcon.setAttribute('width', '14');
            bannedIcon.setAttribute('height', '14');
            bannedIcon.setAttribute('viewBox', '0 0 24 24');
            bannedIcon.setAttribute('fill', 'none');
            bannedIcon.setAttribute('stroke', 'currentColor');
            bannedIcon.setAttribute('stroke-width', '2');
            bannedIcon.setAttribute('aria-hidden', 'true');
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', '12');
            circle.setAttribute('cy', '12');
            circle.setAttribute('r', '9');
            const slash = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            slash.setAttribute('x1', '5');
            slash.setAttribute('y1', '19');
            slash.setAttribute('x2', '19');
            slash.setAttribute('y2', '5');
            bannedIcon.appendChild(circle);
            bannedIcon.appendChild(slash);
            bannedIcon.setAttribute('title', 'Banned');
            wrapper.appendChild(bannedIcon);
        }

        const nameSpan = document.createElement('span');
        nameSpan.textContent = player && player.name ? player.name : 'Unknown';
        wrapper.appendChild(nameSpan);

        td.appendChild(wrapper);
        return td;
    }

    function createActionCell(playerName, action) {
        const td = document.createElement('td');
        const form = document.createElement('form');
        form.method = 'POST';
        form.style.display = 'inline';

        const button = document.createElement('button');
        button.type = 'submit';
        button.name = action;
        button.value = playerName || '';
        // Assign color by action: ban=red, unban=green, kick=amber
        if (action === 'ban') {
            button.className = 'btn btn-danger btn-icon';
            button.title = 'Ban Steam ID';
            button.setAttribute('aria-label', 'Ban player');
        } else if (action === 'unban') {
            button.className = 'btn btn-success btn-icon';
            button.title = 'Unban Steam ID';
            button.setAttribute('aria-label', 'Unban player');
        } else if (action === 'kick') {
            button.className = 'btn btn-warning btn-icon';
            button.title = 'Kick player';
            button.setAttribute('aria-label', 'Kick player');
        } else {
            button.className = 'btn btn-ghost btn-icon';
            const label = action.charAt(0).toUpperCase() + action.slice(1);
            button.title = label;
            button.setAttribute('aria-label', label);
        }
        if (action === 'ban') {
            button.innerHTML = '<svg class="icon-inline" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><circle cx="12" cy="12" r="9"></circle><line x1="5" y1="19" x2="19" y2="5"></line></svg>';
        } else if (action === 'unban') {
            button.innerHTML = '<svg class="icon-inline" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><circle cx="12" cy="12" r="9"></circle><polyline points="9 12 12 15 17 10"></polyline></svg>';
        } else if (action === 'kick') {
            button.innerHTML = '<svg class="icon-inline" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><circle cx="12" cy="12" r="9"></circle><line x1="8" y1="12" x2="16" y2="12"></line></svg>';
        } else {
            button.textContent = action.charAt(0).toUpperCase() + action.slice(1);
        }

        form.appendChild(button);
        td.appendChild(form);
        return td;
    }

    function renderLivePlayers(players) {
        if (!playersLiveBody) {
            return;
        }
        playersLiveBody.textContent = '';

        if (!Array.isArray(players) || players.length === 0) {
            showElement(playersLiveTable, false);
            showElement(playersLiveEmpty, true);
            updateLiveCount(0);
            return;
        }

        // Client-side enforce newest first (descending connected_at) even if backend/order changes later.
        try {
            players.sort((a, b) => {
                if (!a || !b) return 0;
                const ad = new Date(a.connected_at || a.ConnectDatetime || 0).getTime();
                const bd = new Date(b.connected_at || b.ConnectDatetime || 0).getTime();
                return bd - ad; // newest first
            });
        } catch(_) {}

        showElement(playersLiveTable, true, 'table');
        showElement(playersLiveEmpty, false);

        players.forEach(player => {
            const row = document.createElement('tr');
            row.appendChild(createPlayerNameCell(player));
            row.appendChild(createTextCell(player.steam_id || ''));
            row.appendChild(createTextCell(formatDateTimeDisplay(player.connected_at, 'â€”')));
            row.appendChild(createActionCell(player.name || '', 'kick'));
            row.appendChild(createActionCell(player.steam_id || '', 'ban'));
            playersLiveBody.appendChild(row);
        });

        updateLiveCount(players.length);
    }

    // On-demand live players refresh when clicking the pill
    if (playersLiveCount) {
        playersLiveCount.style.cursor = 'pointer';
        playersLiveCount.addEventListener('click', () => {
            if (!serverId) return;
            playersLiveCount.setAttribute('aria-busy','true');
            playersLiveCount.classList.add('loading');
            // Trigger CLIENTS on the server; the status poller will reflect changes
            fetch(`/server/${serverId}/clients`, { headers:{'Accept':'application/json'}, credentials:'same-origin' })
              .then(()=>{ /* ignore body; rely on subsequent status poll */ })
              .catch(()=>{})
              .finally(()=>{ setTimeout(()=>{ try { if (typeof fetchStatus === 'function') fetchStatus(); } catch(_) {} playersLiveCount.removeAttribute('aria-busy'); playersLiveCount.classList.remove('loading'); }, 600); });
        });
    }

    function renderHistoryPlayers(history) {
        if (!playersHistoryBody) {
            return;
        }
        playersHistoryBody.textContent = '';

        if (!Array.isArray(history) || history.length === 0) {
            showElement(playersHistoryTable, false);
            showElement(playersHistoryEmpty, true);
            return;
        }

        // Sort descending by connected_at to keep most recent sessions at top after refresh.
        try {
            history.sort((a, b) => {
                if (!a || !b) return 0;
                const ad = new Date(a.connected_at || a.ConnectDatetime || 0).getTime();
                const bd = new Date(b.connected_at || b.ConnectDatetime || 0).getTime();
                return bd - ad; // newest first
            });
        } catch(_) {}

        showElement(playersHistoryTable, true, 'table');
        showElement(playersHistoryEmpty, false);

        history.forEach(entry => {
            const row = document.createElement('tr');
            const isBanned = !!(entry && entry.steam_id && bannedSteamSet && bannedSteamSet.has(entry.steam_id));
            if (isBanned) {
                row.classList.add('row-banned');
            }
            row.appendChild(createPlayerNameCell(entry, { banned: isBanned }));
            row.appendChild(createTextCell(entry.steam_id || ''));
            row.appendChild(createTextCell(formatDateTimeDisplay(entry.connected_at, 'â€”')));
            row.appendChild(createTextCell(entry.session_length || 'â€”'));
            row.appendChild(createActionCell(entry.steam_id || '', isBanned ? 'unban' : 'ban'));
            playersHistoryBody.appendChild(row);
        });
    }

    function renderChatMessages(messages) {
        if (!chatMessagesContainer || !chatEmptyState) {
            return;
        }

        chatMessagesContainer.textContent = '';

        if (!Array.isArray(messages) || messages.length === 0) {
            chatEmptyState.style.removeProperty('display');
            return;
        }

        chatEmptyState.style.display = 'none';

        messages.forEach((entry) => {
            if (!entry) {
                return;
            }
            const row = document.createElement('div');
            row.className = 'chat-message';

            const timeSpan = document.createElement('span');
            timeSpan.className = 'chat-time';
            timeSpan.textContent = formatTimeDisplay(entry.time, '--:--');

            const playerSpan = document.createElement('span');
            playerSpan.className = 'chat-player';
            playerSpan.textContent = `${entry.player || 'Unknown'}:`;

            const messageSpan = document.createElement('span');
            messageSpan.className = 'chat-text';
            messageSpan.textContent = entry.message || '';

            row.appendChild(timeSpan);
            row.appendChild(playerSpan);
            row.appendChild(messageSpan);

            chatMessagesContainer.appendChild(row);
        });

        chatMessagesContainer.scrollTop = chatMessagesContainer.scrollHeight;
    }

    function renderBanned(list) {
        if (!playersBannedBody) {
            return;
        }
        playersBannedBody.textContent = '';

        if (!Array.isArray(list) || list.length === 0) {
            showElement(playersBannedTable, false);
            showElement(playersBannedEmpty, true);
            return;
        }

        showElement(playersBannedTable, true, 'table');
        showElement(playersBannedEmpty, false);

        list.forEach(entry => {
            const row = document.createElement('tr');
            const nameTd = document.createElement('td');
            nameTd.textContent = (entry && entry.name) ? entry.name : 'â€”';
            const idTd = document.createElement('td');
            idTd.textContent = entry && entry.steam_id ? entry.steam_id : '';
            const actionTd = document.createElement('td');
            const form = document.createElement('form');
            form.method = 'POST';
            form.style.display = 'inline';
            const btn = document.createElement('button');
            btn.type = 'submit';
            btn.name = 'unban';
            btn.value = (entry && entry.steam_id) ? entry.steam_id : '';
            btn.className = 'btn btn-success btn-icon';
            btn.setAttribute('aria-label', 'Unban player');
            btn.title = 'Unban Steam ID';
            btn.innerHTML = '<svg class="icon-inline" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><circle cx="12" cy="12" r="9"></circle><polyline points="9 12 12 15 17 10"></polyline></svg>';
            form.appendChild(btn);
            actionTd.appendChild(form);
            row.appendChild(nameTd);
            row.appendChild(idTd);
            row.appendChild(actionTd);
            playersBannedBody.appendChild(row);
        });
    }

    function setConnectionBanner(active, message) {
        // If this page is inside the main frame, use the top-level banner instead
        if (window.top && window.top !== window && typeof window.top.setConnectionBanner === 'function') {
            window.top.setConnectionBanner(!!active, message || '');
            return;
        }
        if (!connectionBanner) {
            return;
        }
        if (active) {
            connectionBanner.classList.add('active');
            if (connectionBannerText && message) {
                connectionBannerText.textContent = message;
            }
            document.body.style.paddingTop = '3rem';
        } else {
            connectionBanner.classList.remove('active');
            document.body.style.paddingTop = '';
        }
    }

    // Reload button
    (function(){
        const reloadBtn = document.getElementById('connection-banner-action');
        if (reloadBtn) {
            reloadBtn.addEventListener('click', () => window.location.reload());
        }
    })();

    function clearReconnectTimer() {
        if (reconnectTimer) {
            clearInterval(reconnectTimer);
            reconnectTimer = null;
        }
    }

    function handleConnectionLost() {
        if (connectionLost) {
            return;
        }
        connectionLost = true;
        setConnectionBanner(true, 'Connection lost. Attempting to reconnect...');
        stopStatusUpdates();
        stopProgressPolling();
        stopLogTail();
        setUpdateButtonDisabled(true);
        updateControlButtons();
        if (!reconnectTimer) {
            reconnectTimer = setInterval(attemptReconnect, 5000);
        }
        attemptReconnect();
    }

    function handleConnectionRestored() {
        if (!connectionLost) {
            return;
        }
        connectionLost = false;
        clearReconnectTimer();
        setConnectionBanner(false);
        refreshUpdateButtonState();
        updateControlButtons();
        startStatusUpdates();
        if (progressActive) {
            startProgressPolling();
        }
        startLogTail();
    }

    function attemptReconnect() {
        const serverId = rootEl.dataset.serverId;
        if (!serverId) {
            return;
        }
        fetch(`/api/servers/${serverId}/status`, {
            credentials: 'same-origin',
            headers: {
                'Accept': 'application/json'
            }
        })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Server unavailable');
                }
                return response.json();
            })
            .then(data => {
                statusFailureCount = 0;
                handleConnectionRestored();
                updateServerStatusUI(data);
                fetchProgress();
            })
            .catch(() => {
                // Keep retrying until server responds again
            });
    }

    function updateControlButtons(status) {
        const statusObj = status || {};
        const running = typeof statusObj.running === 'boolean' ? statusObj.running : serverIsRunning;
        const paused = typeof statusObj.paused === 'boolean' ? statusObj.paused : serverIsPaused;
        const starting = typeof statusObj.starting === 'boolean' ? statusObj.starting : serverIsStarting;
        const stopping = typeof statusObj.stopping === 'boolean' ? statusObj.stopping : serverIsStopping;

        if (connectionLost) {
            setButtonDisabled(startButton, true);
            setButtonDisabled(stopButton, true);
            setButtonDisabled(restartButton, true);
            setButtonDisabled(saveMainButton, true);
            setButtonDisabled(saveMenuButton, true);
            setButtonDisabled(deleteButton, true);
            if (typeof setButtonDisabled === 'function' && typeof consoleSendBtn !== 'undefined' && consoleSendBtn) {
                setButtonDisabled(consoleSendBtn, true);
            } else {
                try { if (consoleSendBtn) consoleSendBtn.disabled = true; } catch(_) {}
            }
            try { if (consoleInput) consoleInput.disabled = true; } catch(_) {}
            serverIsRunning = running;
            serverIsPaused = paused;
            serverIsStarting = starting;
            return;
        }

        if (startButton) {
            // Show start button when server is not running OR when running but in stopping window (to allow cancellation)
            showElement(startButton, !running || (running && stopping));
            // Enabled for cancellation when stopping; disabled otherwise if already running
            const disable = (!stopping && running) || progressActive;
            setButtonDisabled(startButton, disable);
            // Update label to reflect cancellation action when stopping
            try {
                const icon = startButton.querySelector('svg');
                const iconHTML = icon ? icon.outerHTML : '';
                if (running && stopping) {
                    // Keep Running (cancel shutdown)
                    startButton.innerHTML = iconHTML + ' Keep Running';
                    startButton.title = 'Cancel scheduled shutdown';
                } else {
                    startButton.innerHTML = iconHTML + ' Start';
                    startButton.title = 'Start the server';
                }
            } catch(_) {}
        }

        if (stopButton) {
            showElement(stopButton, running);
            setButtonDisabled(stopButton, !running || progressActive || stoppingCountdownActive);
        }

        if (restartButton) {
            // Disable restart when server is not running (matches Pause behavior)
            setButtonDisabled(restartButton, !running || progressActive || starting || restartingActive);
            // Keep spinner on while restartingActive, even if not yet starting
            if (restartingActive) {
                toggleButtonSpinner(restartButton, true);
            }
        }


        if (saveMainButton) {
            setButtonDisabled(saveMainButton, !running || progressActive || starting);
        }
        if (saveMenuButton) {
            setButtonDisabled(saveMenuButton, !running || progressActive || starting);
        }
        if (saveSplitRoot) {
            const disabled = (!running || progressActive || starting);
            saveSplitRoot.classList.toggle('is-disabled', disabled);
        }

        if (stormButton) {
            setButtonDisabled(stormButton, !running || progressActive || starting);
        }

        if (cleanupDeadButton) {
            setButtonDisabled(cleanupDeadButton, !running || progressActive || starting);
        }
        if (cleanupDiscButton) {
            setButtonDisabled(cleanupDiscButton, !running || progressActive || starting);
        }
        if (cleanupAllButton) {
            setButtonDisabled(cleanupAllButton, !running || progressActive || starting);
        }

        if (deleteButton) {
            setButtonDisabled(deleteButton, running || starting);
        }

        // Chat controls follow running state: disable when stopped
        if (chatSendButton) {
            setButtonDisabled(chatSendButton, !running || progressActive || starting);
        }
        if (chatInput) {
            try { chatInput.disabled = !running || progressActive || starting; } catch(_) {}
        }

        // Console command controls follow running state similar to chat
        if (typeof consoleSendBtn !== 'undefined' && consoleSendBtn) {
            setButtonDisabled(consoleSendBtn, !running || progressActive || starting);
        }
        if (typeof consoleInput !== 'undefined' && consoleInput) {
            try { consoleInput.disabled = !running || progressActive || starting; } catch(_) {}
        }

        serverIsRunning = running;
        serverIsPaused = paused;
        serverIsStarting = starting;
        serverIsStopping = stopping;
    }

    // Worlds and data keyed by stable world IDs; names are localized for display
    let worldsByVersion = {"release": [], "beta": []};
    let worldDataByVersion = {"release": {}, "beta": {}};

    {{ if and .worlds .worldData }}
    {{ $worlds := .worlds }}
    {{ $worldData := .worldData }}
    worldsByVersion = {
        "release": [
            {{ $release := index $worlds "release" }}
            {{ range $idx, $w := $release }}
            {{ if $idx}}, {{ end }}
            {"id": '{{js (index $w "id")}}', "name": '{{js (index $w "name")}}'}
            {{ end }}
        ],
        "beta": [
            {{ $beta := index $worlds "beta" }}
            {{ range $idx, $w := $beta }}
            {{ if $idx}}, {{ end }}
            {"id": '{{js (index $w "id")}}', "name": '{{js (index $w "name")}}'}
            {{ end }}
        ]
    };

    worldDataByVersion = {
        "release": {
            {{ $releaseData := index $worldData "release" }}
            {{ $releaseWorlds := index $worlds "release" }}
            {{ range $idx, $w := $releaseWorlds }}
            {{ if $idx}}, {{ end }}
            "{{js (index $w "id")}}": {
                "locations": [
                    {{ with index $releaseData (index $w "id") }}
                    {{ range $locIdx, $loc := index . "locations" }}
                    {{ if $locIdx}}, {{ end }}
                    {"ID": "{{js $loc.ID}}", "Name": "{{js $loc.Name}}", "Description": "{{js $loc.Description}}"}
                    {{ end }}
                    {{ end }}
                ],
                "conditions": [
                    {{ with index $releaseData (index $w "id") }}
                    {{ range $condIdx, $cond := index . "conditions" }}
                    {{ if $condIdx}}, {{ end }}
                    {"ID": "{{js $cond.ID}}", "Name": "{{js $cond.Name}}", "Description": "{{js $cond.Description}}"}
                    {{ end }}
                    {{ end }}
                ]
            }
            {{ end }}
        },
        "beta": {
            {{ $betaData := index $worldData "beta" }}
            {{ $betaWorlds := index $worlds "beta" }}
            {{ range $idx, $w := $betaWorlds }}
            {{ if $idx}}, {{ end }}
            "{{js (index $w "id")}}": {
                "locations": [
                    {{ with index $betaData (index $w "id") }}
                    {{ range $locIdx, $loc := index . "locations" }}
                    {{ if $locIdx}}, {{ end }}
                    {"ID": "{{js $loc.ID}}", "Name": "{{js $loc.Name}}", "Description": "{{js $loc.Description}}"}
                    {{ end }}
                    {{ end }}
                ],
                "conditions": [
                    {{ with index $betaData (index $w "id") }}
                    {{ range $condIdx, $cond := index . "conditions" }}
                    {{ if $condIdx}}, {{ end }}
                    {"ID": "{{js $cond.ID}}", "Name": "{{js $cond.Name}}", "Description": "{{js $cond.Description}}"}
                    {{ end }}
                    {{ end }}
                ]
            }
            {{ end }}
        }
    };
    {{ end }}

    // Difficulties per version from server payload
    const releaseDifficulties = [
        {{- range $idx, $d := .release_difficulties -}}
        {{- if $idx}}, {{- end -}}
        "{{ js $d }}"
        {{- end -}}
    ];
    const betaDifficulties = [
        {{- range $idx, $d := .beta_difficulties -}}
        {{- if $idx}}, {{- end -}}
        "{{ js $d }}"
        {{- end -}}
    ];

    // Languages per version from server payload
    const releaseLanguages = [
        {{- range $idx, $l := .release_languages -}}
        {{- if $idx}}, {{- end -}}
        "{{ js $l }}"
        {{- end -}}
    ];
    const betaLanguages = [
        {{- range $idx, $l := .beta_languages -}}
        {{- if $idx}}, {{- end -}}
        "{{ js $l }}"
        {{- end -}}
    ];

    const initialVersionKey = {{if .server.Beta}}"beta"{{else}}"release"{{end}};
    const __resolvedWorldId = "{{js .resolved_world_id}}";
    const __serverWorldId = "{{js .server.WorldID}}";
    const initialWorldID = (__resolvedWorldId && __resolvedWorldId.trim()) || (__serverWorldId && __serverWorldId.trim()) || "";
    const initialStartLocation = {{if .server.StartLocation}}"{{js .server.StartLocation}}"{{else}}""{{end}};
    const initialStartCondition = {{if .server.StartCondition}}"{{js .server.StartCondition}}"{{else}}""{{end}};
    const initialDifficulty = {{if .server.Difficulty}}"{{js .server.Difficulty}}"{{else}}""{{end}};
    const initialLanguage = {{if .server.Language}}"{{js .server.Language}}"{{else}}""{{end}};

    const versionState = {
        release: {
            world: initialVersionKey === 'release' ? initialWorldID : '',
            startLocation: initialVersionKey === 'release' ? initialStartLocation : '',
            startCondition: initialVersionKey === 'release' ? initialStartCondition : ''
        },
        beta: {
            world: initialVersionKey === 'beta' ? initialWorldID : '',
            startLocation: initialVersionKey === 'beta' ? initialStartLocation : '',
            startCondition: initialVersionKey === 'beta' ? initialStartCondition : ''
        }
    };

    function currentVersionKey() {
        const checked = document.querySelector('input[name="beta"]:checked');
        return checked && checked.value === "true" ? "beta" : "release";
    }

    // Validation helpers: do not create fallback options. Instead, flag errors.
    function markInvalid(select, message) {
        if (!select) return;
        select.setAttribute('aria-invalid', 'true');
        // Inline highlight to avoid theme dependency
        select.style.outline = '2px solid var(--danger-500)';
        if (message) select.title = message;
    }

    function clearInvalid(select) {
        if (!select) return;
        select.removeAttribute('aria-invalid');
        select.style.removeProperty('outline');
        select.title = '';
    }

    function notifyError(msg) {
        try {
            if (typeof window.showToast === 'function') {
                window.showToast({ type: 'error', title: 'Invalid configuration', message: msg });
            }
        } catch(_) {}
    }

    function updateParamsValidity() {
        const worldSelect = document.getElementById('world');
        const locSelect = document.getElementById('start_location');
        const condSelect = document.getElementById('start_condition');
        const updateBtn = document.getElementById('btn-update-params');
        let invalid = false;
        // If world is disabled (read-only), do not treat empty as invalid
        if (worldSelect && !worldSelect.disabled && !worldSelect.value) invalid = true;
        if (locSelect && locSelect.getAttribute('aria-invalid') === 'true') invalid = true;
        if (condSelect && condSelect.getAttribute('aria-invalid') === 'true') invalid = true;
        if (updateBtn) {
            updateBtn.disabled = invalid || updateBtn.hasAttribute('aria-disabled');
            if (invalid) updateBtn.setAttribute('aria-disabled', 'true');
            else updateBtn.removeAttribute('aria-disabled');
        }
        return !invalid;
    }

    function populateWorldOptions() {
        const worldSelect = document.getElementById('world');
        playerSavesToggle = document.getElementById('player-saves-toggle');
        const playerSavesKey = `sdsm:server:${rootEl.dataset.serverId}:player-saves`;
        if (playerSavesToggle) {
            try {
                const saved = localStorage.getItem(playerSavesKey);
                if (saved === null || saved === undefined) {
                    // Default to persisted config value from dataset when no client preference exists
                    const defaultPS = String(rootEl.dataset.playerSaves || '').toLowerCase() === 'true';
                    playerSavesToggle.checked = defaultPS;
                    try { localStorage.setItem(playerSavesKey, defaultPS ? '1' : '0'); } catch(_) {}
                } else {
                    playerSavesToggle.checked = saved === '1';
                }
            } catch(_) {}
            playerSavesToggle.addEventListener('change', function(){
                const checked = !!this.checked;
                try { localStorage.setItem(playerSavesKey, checked ? '1' : '0'); } catch(_) {}
                // Persist to server config asynchronously
                const sid = Number(rootEl && rootEl.dataset && rootEl.dataset.serverId || '0');
                if (!sid) return;
                fetch(`/api/servers/${sid}/settings`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
                    body: JSON.stringify({ player_saves: checked }),
                    credentials: 'same-origin'
                }).then((res) => {
                    try {
                        if (typeof window.showToast === 'function') {
                            const type = res.headers.get('X-Toast-Type');
                            const title = res.headers.get('X-Toast-Title');
                            const message = res.headers.get('X-Toast-Message');
                            if (message) window.showToast({ type: type || 'success', title: title || '', message });
                        }
                    } catch(_) {}
                }).catch(() => {});
            });
        }
        const versionKey = currentVersionKey();
        const worlds = worldsByVersion[versionKey] || [];
        const state = versionState[versionKey];

        // If there is no visible world selector (read-only world), still populate
        // dependent selects and the world thumbnail using the initial world.
        if (!worldSelect) {
            updateWorldOptions();
            updateWorldThumb();
            updateParamsValidity();
            return;
        }
        worldSelect.innerHTML = '';

        if (!worlds.length) {
            worldSelect.innerHTML = '<option value="">No worlds available</option>';
            if (!worldSelect.disabled) {
                // No fallback: force empty and error
                if (state.world) {
                    notifyError('Configured world ' + state.world + ' is not available for this language/channel. Please choose a valid world.');
                }
                worldSelect.value = '';
                markInvalid(worldSelect, 'World not available for this language/channel');
            } else {
                // When disabled (read-only), don't block with errors; keep current state
                clearInvalid(worldSelect);
            }
            updateWorldOptions();
            updateWorldThumb();
            updateParamsValidity();
            return;
        }

        // If current configured world is not available, do not fallback; require user selection
        const worldIDs = new Set(worlds.map(w => w.id));
        if (state.world && !worldIDs.has(state.world)) {
            if (!worldSelect.disabled) {
                notifyError('Configured world ' + state.world + ' is not available for this language/channel. Please choose a valid world.');
                state.world = '';
                state.startLocation = '';
                state.startCondition = '';
            }
        }

        worlds.forEach(w => {
            const option = document.createElement('option');
            option.value = w.id;
            option.textContent = w.name || w.id;
            worldSelect.appendChild(option);
        });
        // If read-only and current world is not in the list, add it as a synthetic option
        if (worldSelect.disabled && state.world && !worldIDs.has(state.world)) {
            const opt = document.createElement('option');
            opt.value = state.world;
            opt.textContent = state.world;
            worldSelect.appendChild(opt);
        }

        // Select current value only if valid; otherwise leave empty and mark invalid
        if (state.world && (worldIDs.has(state.world) || worldSelect.disabled)) {
            worldSelect.value = state.world;
            clearInvalid(worldSelect);
        } else {
            worldSelect.value = '';
            if (!worldSelect.disabled && !worldSelect.value) {
                markInvalid(worldSelect, 'World not available for this language/channel');
            }
        }
        state.world = worldSelect.value;

        updateWorldOptions();
        updateWorldThumb();
        updateParamsValidity();
    }

    function updateWorldOptions() {
        const worldSelect = document.getElementById('world');
        const locSelect = document.getElementById('start_location');
        const condSelect = document.getElementById('start_condition');
        const versionKey = currentVersionKey();
        const initWorld = (typeof initialWorldID !== 'undefined' && initialWorldID) ? String(initialWorldID) : '';
        const world = worldSelect ? worldSelect.value : initWorld; // world ID
        const worldData = (worldDataByVersion[versionKey] || {})[world];
        const state = versionState[versionKey];

        locSelect.innerHTML = '<option value="">-- Select Start Location --</option>';
        condSelect.innerHTML = '<option value="">-- Select Start Condition --</option>';

        if (worldData) {
            (worldData.locations || []).forEach(loc => {
            const option = document.createElement('option');
            option.value = loc.ID;
            option.textContent = loc.Name || loc.ID;
            if (loc.Description) {
                option.title = loc.Description;
            }
            locSelect.appendChild(option);
        });

            (worldData.conditions || []).forEach(cond => {
            const option = document.createElement('option');
            option.value = cond.ID;
            option.textContent = cond.Name || cond.ID;
            if (cond.Description) {
                option.title = cond.Description;
            }
            condSelect.appendChild(option);
        });
        }
        // Validate selections without fallbacks
        const locIDs = new Set(Array.from(locSelect.options).map(o => o.value).filter(v => v));
        const condIDs = new Set(Array.from(condSelect.options).map(o => o.value).filter(v => v));
        clearInvalid(locSelect);
        clearInvalid(condSelect);
        if (state.startLocation) {
            if (locIDs.has(state.startLocation)) {
                locSelect.value = state.startLocation;
            } else {
                locSelect.value = '';
                markInvalid(locSelect, 'Start Location not available for this world/language');
                notifyError('Configured Start Location is not available for this world/language. Please choose a valid location.');
            }
        } else {
            locSelect.value = '';
        }
        if (state.startCondition) {
            if (condIDs.has(state.startCondition)) {
                condSelect.value = state.startCondition;
            } else {
                condSelect.value = '';
                markInvalid(condSelect, 'Start Condition not available for this world/language');
                notifyError('Configured Start Condition is not available for this world/language. Please choose a valid condition.');
            }
        } else {
            condSelect.value = '';
        }
        updateParamsValidity();
    }

    function updateWorldThumb() {
        try {
            if (!worldThumb) return;
            const worldSelect = document.getElementById('world');
            const initWorld = (typeof initialWorldID !== 'undefined' && initialWorldID) ? String(initialWorldID) : '';
            const world = worldSelect ? (worldSelect.value || '').trim() : initWorld;
            const serverId = Number(rootEl.dataset.serverId || '0');
            if (!serverId || !world) {
                worldThumb.style.display = 'none';
                return;
            }
            // Reset display in case a previous error hid the image
            worldThumb.style.removeProperty('display');
            const betaFlag = currentVersionKey() === 'beta';
            const v = encodeURIComponent((betaFlag ? 'beta' : 'release') + '-' + world);
            // Send world ID; server resolves IDs directly
            const url = `/server/${serverId}/world-image?world=${encodeURIComponent(world)}&beta=${betaFlag}&v=${v}`;
            // Force reload if src is same string
            if (worldThumb.src !== window.location.origin + url) {
                worldThumb.src = url;
            } else {
                // Append a tiny nonce to bust cache if the same URL is set
                worldThumb.src = url + `&t=${Date.now()}`;
            }
        } catch (_) { /* no-op */ }
    }

    function populateDifficultyOptions() {
        const diffSelect = document.getElementById('difficulty');
        const versionKey = currentVersionKey();
        const diffs = versionKey === 'beta' ? betaDifficulties : releaseDifficulties;
        const previous = diffSelect ? diffSelect.value : '';
        if (!diffSelect) return;
        diffSelect.innerHTML = '';
        if (!diffs || !diffs.length) {
            const opt = document.createElement('option');
            opt.value = '';
            opt.textContent = 'No difficulties';
            diffSelect.appendChild(opt);
            return;
        }
        diffs.forEach((d) => {
            const opt = document.createElement('option');
            opt.value = d;
            opt.textContent = d;
            diffSelect.appendChild(opt);
        });
        const desired = diffs.includes(initialDifficulty) ? initialDifficulty : (diffs.includes(previous) ? previous : diffs[0]);
        diffSelect.value = desired;
    }

    function populateLanguageOptions() {
        const langSelect = document.getElementById('language');
        if (!langSelect) return;
        const versionKey = currentVersionKey();
        const langs = versionKey === 'beta' ? betaLanguages : releaseLanguages;
        const previous = langSelect.value;
        langSelect.innerHTML = '';
        if (!langs || !langs.length) {
            const opt = document.createElement('option');
            opt.value = '';
            opt.textContent = 'No languages';
            langSelect.appendChild(opt);
            return;
        }
        langs.forEach((l) => {
            const opt = document.createElement('option');
            opt.value = l;
            opt.textContent = l;
            langSelect.appendChild(opt);
        });
        const desired = langs.includes(initialLanguage) ? initialLanguage : (langs.includes(previous) ? previous : langs[0]);
        langSelect.value = desired;
    }

    document.addEventListener('DOMContentLoaded', () => {
        // Safety net: ensure every .btn has a visible variant; default to neutral if none present
        (function enforceButtonVariants(){
            try {
                const btns = document.querySelectorAll('.btn');
                btns.forEach((b)=>{
                    const hasVariant = b.classList.contains('btn-primary') || b.classList.contains('btn-secondary') || b.classList.contains('btn-danger') || b.classList.contains('btn-success') || b.classList.contains('btn-warning') || b.classList.contains('btn-control') || b.classList.contains('btn-storm') || b.classList.contains('btn-info') || b.classList.contains('btn-neutral') || b.classList.contains('btn-ghost') || b.classList.contains('btn-outline');
                    if (!hasVariant) b.classList.add('btn-neutral');
                });
            } catch(_) {}
        })();
        const worldSelect = document.getElementById('world');
        const locSelect = document.getElementById('start_location');
        const condSelect = document.getElementById('start_condition');
        const difficultySelect = document.getElementById('difficulty');
        const languageSelect = document.getElementById('language');
        const langBtn = document.getElementById('btn-language');
        const langMenu = document.getElementById('language-menu');
        const currLangLabel = document.getElementById('current-language');
        const viewLogBtn = document.getElementById('btn-view-log');
        const serverLogsCard = document.getElementById('server-logs-card');
        const serverLogsToggle = document.getElementById('serverLogsToggle');
        const serverLogsContent = document.getElementById('serverLogsContent');
            const renameBtn = document.getElementById('btn-rename-server');
        const versionRadios = document.querySelectorAll('input[name="beta"]');
        const paramsForm = document.getElementById('startup-params-form');
                        // If an inline startup error banner is present on load, also surface a modal
                        try {
                            const banner = document.getElementById('server-error-banner');
                            const textNode = document.getElementById('server-error-text');
                            if (banner && textNode) {
                                const msg = (textNode.textContent || '').trim();
                                if (msg) {
                                    if (window.askInfo) window.askInfo({ title: 'Server Startup Error', message: msg, confirmText: 'Close' });
                                    else if (window.openInfo) window.openInfo({ title: 'Server Startup Error', message: msg, confirmText: 'Close' });
                                }
                            }
                        } catch(_) {}
                // Token Help modal wiring (for Chat and Welcome Message)
                (function(){
                    const chatTokenBtn = document.getElementById('chat-token-help');
                    const welcomeTokenBtn = document.getElementById('welcome-token-help');
                    function buildBody(){
                        const wrap = document.createElement('div');
                        wrap.innerHTML = '<p>You can include these tokens in chat messages and the Welcome Message. They will be replaced automatically before sending to the server. Click any token to copy it.</p>'+
                            '<ul class="pl-5 token-list">'
                            + '<li><code class="token-ref cmd-name" data-token="[ServerName]" title="Click to copy">[ServerName]</code>: The server name</li>'
                            + '<li><code class="token-ref cmd-name" data-token="[WorldName]" title="Click to copy">[WorldName]</code>: The world name</li>'
                            + '<li><code class="token-ref cmd-name" data-token="[WorldID]" title="Click to copy">[WorldID]</code>: The world ID</li>'
                            + '<li><code class="token-ref cmd-name" data-token="[StartLocation]" title="Click to copy">[StartLocation]</code>: Start location</li>'
                            + '<li><code class="token-ref cmd-name" data-token="[StartCondition]" title="Click to copy">[StartCondition]</code>: Start condition</li>'
                            + '<li><code class="token-ref cmd-name" data-token="[Date]" title="Click to copy">[Date]</code>: Current date (YYYY-MM-DD)</li>'
                            + '<li><code class="token-ref cmd-name" data-token="[Time]" title="Click to copy">[Time]</code>: Current time (HH:MM:SS)</li>'
                            + '<li><code class="token-ref cmd-name" data-token="[LastPlayer]" title="Click to copy">[LastPlayer]</code>: Name of the last player to connect</li>'
                            + '</ul>';
                        // Event delegation for copying tokens
                        wrap.addEventListener('click', async (ev) => {
                            const codeEl = ev.target.closest('code.token-ref');
                            if (!codeEl) return;
                            const token = codeEl.getAttribute('data-token') || (codeEl.textContent || '').trim();
                            if (!token) return;
                            let copied = false;
                            try {
                                if (navigator.clipboard && navigator.clipboard.writeText) {
                                    await navigator.clipboard.writeText(token);
                                    copied = true;
                                }
                            } catch(_) {}
                            if (!copied) {
                                try {
                                    const ta = document.createElement('textarea');
                                    ta.value = token;
                                    ta.style.position = 'fixed';
                                    ta.style.top = '-2000px';
                                    document.body.appendChild(ta);
                                    ta.focus(); ta.select();
                                    document.execCommand && document.execCommand('copy');
                                    ta.remove();
                                    copied = true;
                                } catch(_) {}
                            }
                            if (copied) {
                                codeEl.classList.add('copied');
                                const msg = token + ' copied';
                                if (typeof window.showToast === 'function') {
                                    window.showToast({ type: 'info', title: 'Token Copied', message: msg });
                                } else {
                                    // Fallback inline feedback
                                    const fb = document.createElement('span');
                                    fb.textContent = 'Copied';
                                    fb.style.marginLeft = '8px';
                                    fb.style.fontSize = '0.7rem';
                                    fb.style.opacity = '0.85';
                                    codeEl.parentElement.appendChild(fb);
                                    setTimeout(()=>{ try { fb.remove(); } catch(_){} }, 1500);
                                }
                                setTimeout(()=>{ codeEl.classList.remove('copied'); }, 1200);
                                // Close the info popup after copying
                                try {
                                    const modal = wrap.closest('.confirm-modal');
                                    if (modal) {
                                        const okBtn = modal.querySelector('[data-confirm]');
                                        const closeBtn = modal.querySelector('[data-close]');
                                        if (okBtn) okBtn.click(); else if (closeBtn) closeBtn.click();
                                    }
                                } catch(_) {}
                            }
                        });
                        return wrap;
                    }
                    function openTokenHelp(e){
                        if (e) e.preventDefault();
                        if (typeof window.openInfo === 'function') {
                            window.openInfo({ title: 'Chat Token Reference', body: buildBody(), buttonText: 'Close' });
                        }
                    }
                    if (chatTokenBtn) chatTokenBtn.addEventListener('click', openTokenHelp);
                    if (welcomeTokenBtn) welcomeTokenBtn.addEventListener('click', openTokenHelp);
                })();
        const updateParamsBtn = document.getElementById('btn-update-params');
        // Param change modal elements removed; now handled by openConfirm helper
        const modal = null;
        const modalConfirm = null;
        const modalCancel = null;
        const confirmFlag = document.getElementById('confirm-reset-saves-flag');
        // More/Less toggle for Server Control card
        const controlCard = document.querySelector('.card.card-control');
        const moreToggle = document.getElementById('control-more-toggle');
        const moreSection = document.getElementById('server-more-section');
        if (controlCard && moreToggle && moreSection) {
            try {
                const key = `sdsm:server:${rootEl.dataset.serverId}:control:more`;
                const savedState = sessionStorage.getItem(key);
                const initiallyExpanded = savedState === '1';

                const chevronDown = '<svg class="icon-inline" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><polyline points="6 9 12 15 18 9"></polyline></svg>';
                const chevronUp = '<svg class="icon-inline" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><polyline points="18 15 12 9 6 15"></polyline></svg>';

                function renderMoreToggle(expanded) {
                    if (!moreToggle) return;
                    moreToggle.setAttribute('aria-expanded', expanded ? 'true' : 'false');
                    moreToggle.innerHTML = (expanded ? chevronUp : chevronDown) + '<span class="ml-6">' + (expanded ? 'Less' : 'More') + '</span>';
                    // Match User Management toggle semantics: title reflects Collapse/Expand
                    moreToggle.title = expanded ? 'Collapse' : 'Expand';
                }

                if (initiallyExpanded) {
                    controlCard.classList.add('expanded');
                    renderMoreToggle(true);
                    moreSection.setAttribute('aria-hidden', 'false');
                } else {
                    renderMoreToggle(false);
                }
                moreToggle.addEventListener('click', function(){
                    const expanded = controlCard.classList.toggle('expanded');
                    renderMoreToggle(expanded);
                    moreSection.setAttribute('aria-hidden', expanded ? 'false' : 'true');
                    try { sessionStorage.setItem(key, expanded ? '1' : '0'); } catch(_) {}
                });
            } catch(_) { /* non-fatal */ }
        }

        populateWorldOptions();
        populateDifficultyOptions();
        // Language is no longer a startup parameter; dropdown remains for backward compatibility only if present
        populateLanguageOptions();
        updateWorldThumb();
            // Rename server handler (admin only button present when role == admin)
            if (renameBtn) {
                renameBtn.addEventListener('click', function(){
                    const serverId = String(rootEl.dataset.serverId || '').trim();
                    if (!serverId) return;
                    const nameEl = document.getElementById('server-name');
                    const current = nameEl ? (nameEl.textContent || '').trim() : '';

                    const tpl = document.getElementById('renameModalTemplate');
                    let modal;
                    if (tpl) {
                        modal = tpl.cloneNode(true);
                        modal.id = '';
                        modal.style.display = '';
                        modal.classList.add('active');
                    } else {
                        modal = document.createElement('div');
                        modal.className = 'confirm-modal active';
                        modal.innerHTML = '<div class="modal-card">'
                            + '<div class="modal-header"><h3 class="modal-title">Rename Server</h3></div>'
                            + '<div class="modal-body">'
                            + '<label for="rename-input">New Name</label>'
                            + '<input id="rename-input" class="form-input" style="margin-top:8px;width:100%;" />'
                            + '</div>'
                            + '<div class="modal-actions">'
                            + '<button type="button" class="btn btn-ghost" data-action="cancel">Cancel</button>'
                            + '<button type="button" class="btn btn-primary" data-action="apply">Save</button>'
                            + '</div>'
                            + '</div>';
                    }
                    document.body.appendChild(modal);
                    const input = modal.querySelector('#rename-input');
                    if (input) { input.value = current; input.focus(); try { input.select && input.select(); } catch(_) {} }
                    const cleanup = () => { try { modal.remove(); } catch(_) {} try { renameBtn.disabled = false; } catch(_) {} };
                    const onBackdrop = (e) => { if (e.target === modal) { modal.removeEventListener('click', onBackdrop); cleanup(); } };
                    modal.addEventListener('click', onBackdrop);
                    const cancelEl = modal.querySelector('[data-action=cancel]');
                    const applyEl = modal.querySelector('[data-action=apply]');
                    if (cancelEl) cancelEl.addEventListener('click', cleanup);
                    if (applyEl) applyEl.addEventListener('click', () => {
                        const val = (input && input.value || '').trim();
                        if (!val || val === current) { cleanup(); return; }
                        renameBtn.disabled = true;
                        // API-only rename via settings endpoint
                        fetch(`/api/servers/${serverId}/settings`, {
                            method: 'POST',
                            credentials: 'same-origin',
                            headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
                            body: JSON.stringify({ name: val })
                        }).then(res => {
                            try {
                                const typeH = res.headers.get('X-Toast-Type');
                                const titleH = res.headers.get('X-Toast-Title') || 'Server Renamed';
                                const msgH = res.headers.get('X-Toast-Message') || 'Server name updated.';
                                if (msgH && typeof window.showToast === 'function') {
                                    window.showToast({ type: typeH || 'success', title: titleH, message: msgH });
                                }
                            } catch(_) {}
                            if (res.ok && nameEl) {
                                nameEl.textContent = val;
                                try { document.title = val + ' - SDSM'; } catch(_) {}
                            }
                        }).catch(()=>{}).finally(cleanup);
                    });
                    const escHandler = (e) => { if (e.key === 'Escape') { cleanup(); window.removeEventListener('keydown', escHandler); } };
                    window.addEventListener('keydown', escHandler);
                });
            }
                // Start SCON health polling
                try {
                    paintSCONHealth(false);
                    if (sconTimer) { clearInterval(sconTimer); }
                    pollSCONHealth();
                    sconTimer = setInterval(pollSCONHealth, 10000);
                } catch(_) {}
        // Apply Player Saves preference from URL on first load after creation
        (function(){
            try {
                const params = new URLSearchParams(window.location.search || '');
                const ps = params.get('player_saves') || params.get('ps');
                const sid = Number(rootEl && rootEl.dataset && rootEl.dataset.serverId || '0');
                if (sid && ps !== null) {
                    const key = `sdsm:server:${sid}:player-saves`;
                    const val = (ps === '1' || ps === 'true') ? '1' : '0';
                    try { localStorage.setItem(key, val); } catch(_) {}
                    if (playerSavesToggle) {
                        playerSavesToggle.checked = (val === '1');
                    }
                    // Clean the URL so the param doesn't persist on reloads
                    const url = new URL(window.location.href);
                    url.searchParams.delete('player_saves');
                    url.searchParams.delete('ps');
                    window.history.replaceState({}, document.title, url.toString());
                }
            } catch(_) { /* no-op */ }
        })();


        const tabButtons = document.querySelectorAll('.tab-set .tab-btn');
        const tabContents = document.querySelectorAll('.tab-panel');
        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                tabButtons.forEach(b => b.classList.remove('active'));
                tabContents.forEach(content => content.classList.remove('active'));
                button.classList.add('active');
                const targetId = button.getAttribute('data-target');
                const target = targetId ? document.getElementById(targetId) : null;
                if (target) {
                    target.classList.add('active');
                }
            });
        });

        if (worldSelect) {
            worldSelect.addEventListener('change', () => {
                const versionKey = currentVersionKey();
                const state = versionState[versionKey];
                state.world = worldSelect.value;
                state.startLocation = '';
                state.startCondition = '';
                updateWorldOptions();
                updateWorldThumb();
                clearInvalid(worldSelect);
                updateParamsValidity();
            });
        }

        versionRadios.forEach(radio => {
            radio.addEventListener('change', () => {
                populateWorldOptions();
                populateDifficultyOptions();
                // Do not repopulate startup language; instead update language control options
                try { buildLanguageMenu(); } catch(_) {}
                updateWorldThumb();
            });
        });

        if (difficultySelect) {
            difficultySelect.addEventListener('change', () => {
                // Keep initialDifficulty aligned only for UX fallback decisions
                // Not used as destructive param, so no modal involvement
            });
        }

        // Language control (top-right in Server Info card)
        function getAvailableLanguages() {
            const versionKey = currentVersionKey();
            return versionKey === 'beta' ? betaLanguages : releaseLanguages;
        }

        function closeLanguageMenu() {
            if (!langMenu) return;
            langMenu.classList.remove('active');
            if (langBtn) langBtn.setAttribute('aria-expanded', 'false');
        }

        function buildLanguageMenu() {
            if (!langMenu) return;
            const langs = getAvailableLanguages();
            langMenu.textContent = '';
            if (!langs || !langs.length) {
                const empty = document.createElement('div');
                empty.textContent = 'No languages available';
                empty.style.padding = '6px 8px';
                empty.style.color = 'var(--text-tertiary)';
                langMenu.appendChild(empty);
                return;
            }
            langs.forEach(l => {
                const item = document.createElement('button');
                item.type = 'button';
                item.className = 'dropdown-item';
                item.setAttribute('role', 'menuitem');
                item.textContent = l;
                item.addEventListener('click', function(){
                    if (!l) return;
                    // POST set_language asynchronously
                    const sid = Number(rootEl.dataset.serverId || '0');
                    if (!sid) return;
                    fetch(`/api/servers/${sid}/language`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
                        body: JSON.stringify({ language: l }),
                        credentials: 'same-origin'
                    }).then((res) => {
                        try {
                            if (typeof window.showToast === 'function') {
                                const type = res.headers.get('X-Toast-Type');
                                const title = res.headers.get('X-Toast-Title');
                                const message = res.headers.get('X-Toast-Message');
                                if (message) window.showToast({ type: type || 'success', title: title || '', message });
                            }
                        } catch(_) {}
                        if (res.ok) {
                            // Update the inline label immediately for feedback
                            if (currLangLabel) currLangLabel.textContent = l;
                            // Reload the page to hydrate all language-dependent data (worlds, locations,
                            // conditions, difficulties, world image) without requiring manual refresh
                            // so the new language takes full effect across the UI.
                            window.location.reload();
                        }
                    }).catch(() => {}).finally(() => {
                        closeLanguageMenu();
                    });
                });
                langMenu.appendChild(item);
            });
        }

        if (langBtn && langMenu) {
            buildLanguageMenu();
            function openLanguageMenu(){
                // With absolute positioning in CSS, just toggle visibility under the button
                langMenu.classList.add('active');
                langBtn.setAttribute('aria-expanded', 'true');
                // Focus first item for keyboard use
                try {
                    const first = langMenu.querySelector('.dropdown-item');
                    if (first) first.focus();
                } catch(_) {}
            }
            langBtn.addEventListener('click', function(e){
                e.stopPropagation();
                if (!langMenu.classList.contains('active')) {
                    buildLanguageMenu();
                    openLanguageMenu();
                } else {
                    closeLanguageMenu();
                }
            });
            // Constrain outside click listener to language menu interactions only.
            // Using capture on the whole document can contribute to scroll jumps in some
            // browsers when focus is moved after close; keep this minimal.
            document.addEventListener('click', function(e){
                if (!langMenu.contains(e.target) && !langBtn.contains(e.target)) {
                    closeLanguageMenu();
                }
            }, { passive: true });
            // No reposition needed with absolute anchoring
            window.addEventListener('keydown', function(e){ if(e.key === 'Escape') closeLanguageMenu(); });
            // Keyboard support: open menu from button, navigate items
            langBtn.addEventListener('keydown', function(e){
                if (e.key === 'ArrowDown' || e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    if (!langMenu.classList.contains('active')) {
                        buildLanguageMenu();
                        openLanguageMenu();
                    }
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    if (!langMenu.classList.contains('active')) {
                        buildLanguageMenu();
                        openLanguageMenu();
                    }
                    const items = Array.from(langMenu.querySelectorAll('.dropdown-item'));
                    if (items.length) { try { items[items.length - 1].focus(); } catch(_) {} }
                }
            });
            langMenu.addEventListener('keydown', function(e){
                const items = Array.from(langMenu.querySelectorAll('.dropdown-item'));
                if (!items.length) return;
                const current = document.activeElement;
                const idx = items.indexOf(current);
                if (e.key === 'ArrowDown') { e.preventDefault(); items[(idx + 1) % items.length].focus(); }
                else if (e.key === 'ArrowUp') { e.preventDefault(); items[(idx - 1 + items.length) % items.length].focus(); }
                else if (e.key === 'Home') { e.preventDefault(); items[0].focus(); }
                else if (e.key === 'End') { e.preventDefault(); items[items.length - 1].focus(); }
                else if (e.key === 'Escape') { e.preventDefault(); closeLanguageMenu(); try { langBtn.focus(); } catch(_) {} }
            });
        }

        if (locSelect) {
            locSelect.addEventListener('change', () => {
                const state = versionState[currentVersionKey()];
                state.startLocation = locSelect.value;
                if (locSelect.value) clearInvalid(locSelect);
                updateParamsValidity();
            });
        }

        if (condSelect) {
            condSelect.addEventListener('change', () => {
                const state = versionState[currentVersionKey()];
                state.startCondition = condSelect.value;
                if (condSelect.value) clearInvalid(condSelect);
                updateParamsValidity();
            });
        }

        const serverId = Number(rootEl.dataset.serverId || '0');
        // Hydrate attach/rehydration placeholders with effective defaults from API
        (function hydrateAttachDefaults(){
            if (!serverId) return;
            const winEl = document.getElementById('log_attach_rehydrate_kb');
            const cntEl = document.getElementById('clients_query_retry_count');
            const delEl = document.getElementById('clients_query_retry_delay_seconds');
            if (!winEl && !cntEl && !delEl) return;
            fetch(`/api/servers/${serverId}/settings/attach-defaults`, {
                credentials: 'same-origin',
                headers: { 'Accept': 'application/json' }
            })
            .then(r => r.ok ? r.json() : null)
            .then(data => {
                if (!data) return;
                try {
                    if (winEl && typeof data.log_attach_rehydrate_kb !== 'undefined') {
                        const v = Number(data.log_attach_rehydrate_kb) || 0;
                        winEl.setAttribute('placeholder', String(v > 0 ? v : 256));
                    }
                } catch(_) {}
                try {
                    if (cntEl && typeof data.clients_query_retry_count !== 'undefined') {
                        const v = Number(data.clients_query_retry_count) || 0;
                        cntEl.setAttribute('placeholder', String(v > 0 ? v : 3));
                    }
                } catch(_) {}
                try {
                    if (delEl && typeof data.clients_query_retry_delay_seconds !== 'undefined') {
                        const v = Number(data.clients_query_retry_delay_seconds) || 0;
                        delEl.setAttribute('placeholder', String(v > 0 ? v : 2));
                    }
                } catch(_) {}
            })
            .catch(() => { /* non-fatal */ });
        })();
        // Helper to submit startup params via API
        function submitStartupParamsAPI(form){
            if (!form || connectionLost) return;
            const fd = new FormData(form);
            // Signal update action explicitly
            fd.set('update', '1');
            const body = new URLSearchParams();
            for (const [k, v] of fd.entries()) {
                body.append(k, String(v));
            }
            // Disable the submit button(s) during request
            let submitBtns = Array.prototype.slice.call(form.querySelectorAll('button[name="update"]'));
            submitBtns.forEach(b => { b.disabled = true; b.setAttribute('aria-disabled', 'true'); });
            return fetch(`/api/servers/${serverId}/settings`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'X-Requested-With': 'XMLHttpRequest',
                    'Accept': 'application/json'
                },
                credentials: 'same-origin',
                body: body.toString()
            }).then((res) => {
                try {
                    if (typeof window.showToast === 'function') {
                        const type = res.headers.get('X-Toast-Type');
                        const title = res.headers.get('X-Toast-Title');
                        const message = res.headers.get('X-Toast-Message');
                        if (message) window.showToast({ type: type || 'info', title: title || '', message });
                    }
                } catch(_) {}
                // Even on error, try to parse JSON for potential details
                return res.json().catch(() => ({}));
            }).then(() => {
                // Refresh status snapshot in case something changed
                fetchStatus();
            }).catch(() => {
                // No-op; toast already displayed via headers
            }).finally(() => {
                submitBtns.forEach(b => { b.disabled = false; b.removeAttribute('aria-disabled'); });
            });
        }
        // Intercept Startup Parameters form submit for async update + toast
        (function(){
            const form = document.getElementById('startup-params-form');
            if (!form) return;
            // Toggle visibility of forwarding extras based on auto port forwarding toggle
            const extras = document.getElementById('net-forwarding-extras');
            const ipEl = document.getElementById('external-ip-value');
            function refreshForwardingExtras() {
                try {
                    const pf = form.querySelector('#auto_port_forward');
                    const enabled = !!(pf && pf.checked);
                    if (enabled) {
                        if (extras) extras.style.display = '';
                    } else {
                        if (extras) extras.style.display = 'none';
                    }
                } catch(_) {}
            }
            form.addEventListener('change', function(e){
                if (e && e.target && e.target.id === 'auto_port_forward') {
                    refreshForwardingExtras();
                }
            });
            refreshForwardingExtras();

            // Wire Test Port button
            const testButton = document.getElementById('btn-test-port');
            if (testButton) {
                testButton.addEventListener('click', function(ev){
                    ev.preventDefault();
                    const serverId = Number(rootEl && rootEl.dataset && rootEl.dataset.serverId ? rootEl.dataset.serverId : '0');
                    if (!serverId) return;
                    testButton.disabled = true;
                    fetch(`/api/servers/${serverId}/port-test`, {
                        method: 'POST',
                        headers: { 'Accept': 'application/json' },
                        credentials: 'same-origin'
                    }).then(res => {
                        try { if (typeof window.showToast === 'function') { showToastFromResponse(res); } } catch(_) {}
                        return res.ok ? res.json().catch(() => ({})) : res.json().catch(() => ({}));
                    }).then(data => {
                        if (ipEl && data && data.external_ip) {
                            ipEl.textContent = String(data.external_ip);
                        }
                        // Fallback toast if headers not set
                        if (typeof window.showToast === 'function') {
                            const ok = !!(data && data.active);
                            const msg = ok ? `Port ${data.external_port || ''} appears mapped on ${data.external_ip || 'external IP'}.` : (data && data.error ? data.error : 'Port check could not verify reachability.');
                            window.showToast({ type: ok ? 'success' : 'warning', title: 'Test Port', message: msg });
                        }
                    }).finally(() => { testButton.disabled = false; });
                });
            }
            form.addEventListener('submit', function(e){
                if (connectionLost) return; // let default if offline (though form is API-only)
                e.preventDefault();
                submitStartupParamsAPI(form);
            });
        })();
        // Support multiple 'Update Server Files' buttons across cards
        let updateButtons = Array.prototype.slice.call(document.querySelectorAll('button[name="update_server"]'));
        progressContainer = document.getElementById('server-update-progress');
        progressFill = progressContainer ? progressContainer.querySelector('.update-progress-fill') : null;
        progressText = progressContainer ? progressContainer.querySelector('.update-progress-text') : null;

        setUpdateButtonDisabled = function(disabled) {
            if (!updateButtons || !updateButtons.length) return;
            const d = !!disabled;
            updateButtons.forEach(btn => {
                btn.disabled = d;
                if (d) btn.setAttribute('aria-disabled', 'true');
                else btn.removeAttribute('aria-disabled');
            });
        };

        function clampPercent(value) {
            if (Number.isNaN(value)) {
                return 0;
            }
            return Math.max(0, Math.min(100, value));
        }

        stopProgressPolling = function() {
            if (progressTimer) {
                clearInterval(progressTimer);
                progressTimer = null;
            }
        };

        startProgressPolling = function() {
            if (!serverId || progressTimer || connectionLost) {
                return;
            }
            progressTimer = setInterval(fetchProgress, 2000);
        };

        refreshUpdateButtonState = function() {
            if (!updateButtons || !updateButtons.length) {
                return;
            }
            if (connectionLost || serverIsRunning || serverIsStarting || progressActive) {
                setUpdateButtonDisabled(true);
            } else {
                setUpdateButtonDisabled(false);
            }
        };

        function updateProgressUI(data) {
            if (!progressContainer) {
                return;
            }
            const stage = (data && data.stage ? data.stage : '').trim();
            const percentRaw = data && typeof data.percent === 'number' ? data.percent : parseInt(data && data.percent, 10) || 0;
            const percent = clampPercent(percentRaw);
            const running = !!(data && data.running);
            const hasError = !!(data && data.error);
            const isIdleStage = !running && !hasError && percent === 0 && (stage === '' || stage === 'Idle');

            progressActive = running;

            progressContainer.classList.toggle('active', !isIdleStage);
            progressContainer.classList.toggle('error', hasError);

            if (progressFill) {
                progressFill.style.width = (isIdleStage ? 0 : percent) + '%';
            }

            if (progressText) {
                let text = stage;
                if (hasError) {
                    text = 'Error: ' + data.error;
                } else if (running) {
                    text = text || 'Copying files';
                    text += percent > 0 ? ' (' + percent + '%)' : '...';
                } else if (percent >= 100 && !hasError) {
                    text = text || 'Completed';
                } else if (isIdleStage) {
                    text = 'Idle';
                }
                progressText.textContent = text.trim();
            }

            if (running) {
                startProgressPolling();
            } else {
                stopProgressPolling();
            }

            updateControlButtons();
            refreshUpdateButtonState();
        }

        fetchProgress = function() {
            if (!serverId) {
                return;
            }
            fetch(`/api/servers/${serverId}/progress`, {
                headers: {
                    'Accept': 'application/json'
                },
                credentials: 'same-origin'
            })
                .then(res => (res.ok ? res.json() : null))
                .then(data => {
                    if (data) {
                        updateProgressUI(data);
                    }
                })
                .catch(() => {
                    // Ignore polling errors
                });
        };

        function handleUpdateClick(event) {
            event.preventDefault();
            const srcBtn = event && event.currentTarget ? event.currentTarget : null;
            if ((srcBtn && srcBtn.disabled) || serverIsRunning || serverIsStarting) {
                return;
            }

            progressActive = true;
            updateControlButtons();
            refreshUpdateButtonState();

            if (progressContainer) {
                progressContainer.classList.add('active');
                progressContainer.classList.remove('error');
            }
            if (progressFill) {
                progressFill.style.width = '0%';
            }
            if (progressText) {
                progressText.textContent = 'Starting update...';
            }

            fetch(`/api/servers/${serverId}/update-server`, {
                method: 'POST',
                headers: { 'Accept': 'application/json' },
                credentials: 'same-origin'
            })
                .then(res => {
                    try {
                        if (typeof window.showToast === 'function') {
                            const type = res.headers.get('X-Toast-Type');
                            const title = res.headers.get('X-Toast-Title');
                            const message = res.headers.get('X-Toast-Message');
                            if (message) window.showToast({ type: type || 'info', title: title || '', message });
                        }
                    } catch (_) {}
                    if (!res.ok) {
                        return res.json().then(data => Promise.reject(data));
                    }
                    return res.json();
                })
                .then(() => {
                    fetchProgress();
                    startProgressPolling();
                })
                .catch(err => {
                    const message = err && err.error ? err.error : 'Unable to start update.';
                    updateProgressUI({ stage: 'Error', percent: 0, running: false, error: message });
                    progressActive = false;
                    updateControlButtons();
                    refreshUpdateButtonState();
                });
        }

        if (updateButtons && updateButtons.length) {
            updateButtons.forEach(btn => btn.addEventListener('click', handleUpdateClick));
        }

        updateServerStatusUI = function(data) {
            if (!data) {
                return;
            }

            const running = !!data.running;
            const starting = !!data.starting;
            const stopping = !!data.stopping; // new flag from backend
            const stoppingEta = (data.stopping_eta !== undefined && data.stopping_eta !== null) ? Number(data.stopping_eta) : null;
            // Store last ETA for client-side countdown smoothing
            if (!isNaN(stoppingEta) && stoppingEta !== null) {
                rootEl.dataset.stoppingEta = String(stoppingEta);
                rootEl.dataset.stoppingEtaUpdated = String(Date.now());
            } else if (!stopping) {
                delete rootEl.dataset.stoppingEta;
                delete rootEl.dataset.stoppingEtaUpdated;
            }
            serverIsRunning = running;
            serverIsStarting = starting;
            rootEl.dataset.serverRunning = running ? 'true' : 'false';
            rootEl.dataset.serverStarting = starting ? 'true' : 'false';
            serverIsPaused = !!data.paused && running;
            serverIsStopping = stopping && running;
            rootEl.dataset.serverPaused = serverIsPaused ? 'true' : 'false';
            rootEl.dataset.serverStopping = serverIsStopping ? 'true' : 'false';

            if (statusIndicator) {
                statusIndicator.classList.toggle('starting', running && starting);
                statusIndicator.classList.toggle('running', running && !serverIsPaused && !starting);
                statusIndicator.classList.toggle('paused', serverIsPaused && !starting);
                statusIndicator.classList.toggle('stopped', !running);
            }
            // Apply pill variant classes to container for visual styling (starting, running, paused, stopped)
            if (statusContainer) {
                statusContainer.classList.remove('is-running', 'is-stopped', 'is-paused', 'is-starting', 'is-stopping');
                statusContainer.classList.toggle('is-starting', running && starting);
                statusContainer.classList.toggle('is-stopping', running && stopping && !starting);
                statusContainer.classList.toggle('is-running', running && !serverIsPaused && !starting && !stopping);
                statusContainer.classList.toggle('is-paused', running && serverIsPaused);
                statusContainer.classList.toggle('is-stopped', !running);
            }
            if (statusText) {
                if (starting && running) {
                    statusText.textContent = 'Starting';
                } else if (stopping && running) {
                    if (stoppingEta !== null && !isNaN(stoppingEta) && stoppingEta > 0) {
                        statusText.textContent = `Stopping (${stoppingEta}s)`;
                    } else {
                        statusText.textContent = 'Stopping';
                    }
                } else if (!running) {
                    statusText.textContent = 'Stopped';
                } else if (serverIsPaused) {
                    statusText.textContent = 'Paused';
                } else {
                    statusText.textContent = 'Running';
                }
            }

            // Toggle update-needed badge: show when backend reports update_needed and no active copy in progress
            try {
                const needed = !!data.update_needed;
                const busy = !!progressActive;
                if (updateNeededBadge) {
                    updateNeededBadge.classList.toggle('hidden', !(needed && !busy));
                }
            } catch(_) {}

            // Manage local pill countdown interval
            if (stopping && running) {
                const etaRaw = rootEl.dataset.stoppingEta ? Number(rootEl.dataset.stoppingEta) : NaN;
                if (!isNaN(etaRaw) && etaRaw > 0) {
                    // Reset remaining if broadcast ETA increased or interval not started
                    if (pillStoppingRemaining === 0 || etaRaw > pillStoppingRemaining) {
                        pillStoppingRemaining = etaRaw;
                    }
                    if (!pillStoppingInterval) {
                        pillStoppingInterval = setInterval(() => {
                            // Abort if server state changed
                            const stillStopping = rootEl.dataset.serverRunning === 'true' && stoppingCountdownActive || (!!rootEl.dataset.stoppingEta && rootEl.dataset.serverRunning === 'true');
                            if (!stillStopping) { clearInterval(pillStoppingInterval); pillStoppingInterval = null; return; }
                            pillStoppingRemaining = Math.max(0, pillStoppingRemaining - 1);
                            if (statusText) {
                                statusText.textContent = pillStoppingRemaining > 0 ? `Stopping (${pillStoppingRemaining}s)` : 'Stopping';
                            }
                            if (pillStoppingRemaining <= 0) {
                                clearInterval(pillStoppingInterval);
                                pillStoppingInterval = null;
                            }
                        }, 1000);
                    }
                }
            } else {
                if (pillStoppingInterval) { clearInterval(pillStoppingInterval); pillStoppingInterval = null; }
                pillStoppingRemaining = 0;
            }

            // If server is no longer running, clear any active stop countdown UI
            if (!running && stoppingCountdownActive) {
                clearStopCountdown();
            }

            // Manage restart spinner lifecycle:
            // Keep spinner while 'starting' is observed at least once after clicking restart.
            if (restartingActive) {
                if (starting) {
                    restartSawStarting = true;
                    // Ensure spinner remains visible on the button
                    try { toggleButtonSpinner(restartButton, true); } catch(_) {}
                } else if (restartSawStarting) {
                    // Starting finished (success) -> clear spinner and label
                    clearRestartSpinner();
                } else if (!running && !starting) {
                    // Restart appears to have failed or server stopped without entering starting
                    clearRestartSpinner();
                }
            }

            // Update name in title bar and document title if changed
            try {
                const newName = (data && typeof data.name === 'string') ? data.name.trim() : '';
                if (newName) {
                    const nameEl = document.getElementById('server-name');
                    if (nameEl && nameEl.textContent !== newName) {
                        nameEl.textContent = newName;
                    }
                    const desiredTitle = newName + ' - SDSM';
                    if (document.title !== desiredTitle) {
                        document.title = desiredTitle;
                    }
                }
            } catch(_) {}

            // Update Port and Max Players if elements exist
            try {
                const portEl = document.getElementById('server-port-value');
                if (portEl && typeof data.port !== 'undefined') {
                    const p = Number(data.port) || 0;
                    if (String(p) !== portEl.textContent) portEl.textContent = String(p);
                }
                const maxEl = document.getElementById('server-max-value');
                if (maxEl && typeof data.max_clients !== 'undefined') {
                    const mc = Number(data.max_clients) || 0;
                    if (String(mc) !== maxEl.textContent) maxEl.textContent = String(mc);
                }
                // Port forwarding status row (hide when disabled)
                const pfRow = document.getElementById('port-forward-row');
                const pfEl = document.getElementById('port-forward-status');
                if (pfEl) {
                    const enabled = !!data.auto_port_forward;
                    const active = !!data.port_forward_active;
                    const extPort = Number(data.port_forward_external_port) || 0;
                    const lastErr = (data.port_forward_last_error || '').trim();
                    const source = (data.port_forward_source || '').trim();
                    const useGame = !!data.use_game_upnp;
                    if (!enabled) {
                        if (pfRow) pfRow.style.display = 'none';
                    } else if (enabled && lastErr && !active) {
                        if (pfRow) pfRow.style.display = '';
                        pfEl.textContent = 'Error';
                        pfEl.className = 'pf-status pf-status-error';
                        pfEl.title = 'Failed to establish port mapping: ' + lastErr;
                    } else if (enabled && active) {
                        if (pfRow) pfRow.style.display = '';
                        const parts = [];
                        if (extPort) parts.push(String(extPort));
                        if (source === 'game') parts.push('Game UPnP');
                        else if (source === 'sdsm') parts.push('SDSM NAT');
                        pfEl.textContent = parts.length ? ('Active (' + parts.join(', ') + ')') : 'Active';
                        pfEl.className = 'pf-status pf-status-active';
                        pfEl.title = 'Port forwarding active' + (source ? ' via ' + (source === 'game' ? 'Game UPnP' : 'SDSM NAT') : '') + '. External UDP port may differ from internal.';
                    } else {
                        if (pfRow) pfRow.style.display = '';
                        pfEl.textContent = 'Pending';
                        pfEl.className = 'pf-status pf-status-pending';
                        pfEl.title = useGame ? 'Attempting to establish port mapping (Game UPnP first)...' : 'Attempting to establish port mapping...';
                    }
                }
            } catch(_) {}

            const lastLine = data.last_log_line && data.last_log_line.trim() ? data.last_log_line : 'No log data';
            setTextContent(lastLogLineEl, lastLine);

            setTextContent(startedValueEl, formatDateTimeDisplay(data.server_started, 'Not started'));
            setTextContent(savedValueEl, formatDateTimeDisplay(data.server_saved, 'Not saved'));

            // Error banner (last_error)
            const hasError = !!(data.last_error && String(data.last_error).trim());
            if (errorBanner) {
                showElement(errorBanner, hasError);
            }
            if (hasError) {
                if (errorTextEl) setTextContent(errorTextEl, data.last_error);
                if (errorTimeEl) setTextContent(errorTimeEl, formatDateTimeDisplay(data.last_error_at, 'â€”'));
            } else {
                if (errorTextEl) setTextContent(errorTextEl, '');
                if (errorTimeEl) setTextContent(errorTimeEl, '');
            }

            // Update storm button label/state first
            try {
                serverIsStorming = !!data.storming;
                // Update storm control button label
                if (stormButton) {
                    const label = serverIsStorming ? 'Stop' : 'Start';
                    stormButton.innerHTML = '<svg class="icon-inline" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" title="Storm"><path d="M19 16.9A5 5 0 0 0 18 7h-1.26A8 8 0 1 0 3 15"/><polyline points="13 11 9 17 15 17 11 23"/></svg>' + label;
                    stormButton.title = serverIsStorming ? 'Stop the storm event' : 'Start a storm event';
                }
                // Update storm status pill: show only when running AND storming
                if (stormStatusPill) {
                    if (serverIsRunning && serverIsStorming) {
                        stormStatusPill.style.display = '';
                        stormStatusPill.textContent = 'Storm';
                        stormStatusPill.classList.remove('is-storm', 'is-clear');
                        stormStatusPill.classList.add('is-storm');
                    } else {
                        stormStatusPill.style.display = 'none';
                    }
                }
            } catch (_) {}

            // Keep track of live players; backend handles player-save automation
            const playersArr = Array.isArray(data.players) ? data.players : [];
            try {
                const currentSet = new Set(playersArr.map(p => (p && (p.steam_id || p.SteamID)) ? String(p.steam_id || p.SteamID) : '').filter(Boolean));
                knownLiveSteam = currentSet;
            } catch(_) { knownLiveSteam = new Set(); }

            renderLivePlayers(playersArr);

            // Keep banned set updated before rendering History rows so we can annotate
            if (Array.isArray(data.banned)) {
                try {
                    bannedSteamSet = new Set((data.banned || []).map(b => b && b.steam_id).filter(Boolean));
                } catch (_) { bannedSteamSet = new Set(); }
            } else {
                bannedSteamSet = new Set();
            }

            if (Array.isArray(data.clients)) {
                renderHistoryPlayers(data.clients);
            } else {
                renderHistoryPlayers([]);
            }

            if (Array.isArray(data.chat_messages)) {
                renderChatMessages(data.chat_messages);
            } else {
                renderChatMessages([]);
            }

            if (Array.isArray(data.banned)) {
                renderBanned(data.banned);
            } else {
                renderBanned([]);
            }

            updateControlButtons(data);
            refreshUpdateButtonState();
        };

        fetchStatus = function() {
            if (!serverId) {
                return;
            }
            fetch(`/api/servers/${serverId}/status`, {
                headers: {
                    'Accept': 'application/json'
                },
                credentials: 'same-origin'
            })
                .then(res => {
                    if (res.status === 401) {
                        stopStatusUpdates();
                        return null;
                    }
                    if (!res.ok) {
                        throw new Error('Failed to fetch server status');
                    }
                    return res.json();
                })
                .then(data => {
                    statusFailureCount = 0;
                    if (data) {
                        handleConnectionRestored();
                        updateServerStatusUI(data);
                    }
                })
                .catch(() => {
                    statusFailureCount += 1;
                    if (statusFailureCount >= 2) {
                        handleConnectionLost();
                    }
                });
        };

        stopStatusUpdates = function() {
            if (statusTimer) {
                clearInterval(statusTimer);
                statusTimer = null;
            }
        };

        startStatusUpdates = function() {
            if (!serverId || statusTimer || connectionLost) {
                return;
            }
            statusTimer = setInterval(fetchStatus, 4000);
        };

        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                stopStatusUpdates();
                stopProgressPolling();
                stopLogTail();
            } else {
                fetchStatus();
                fetchProgress();
                startStatusUpdates();
                if (progressActive) {
                    startProgressPolling();
                }
                startLogTail();
            }
        });

        refreshUpdateButtonState();
        fetchProgress();
        fetchStatus();
        startStatusUpdates();
        // Initialize logs UI
        initLogsUI();
        // Optimistic default: immediately tail the primary output log without waiting for the list
        (function(){
            const sid = Number(rootEl && rootEl.dataset && rootEl.dataset.serverId || '0');
            if (!selectedLog && sid) {
                selectedLog = `Server${sid}_output.log`;
                // Start with tail from end; viewer will clear if rotation occurs
                logTailOffset = -1;
                if (logViewer) {
                    // kick off an immediate tail read; do not wait for list fetch/sort
                    fetchLogTail();
                }
            }
        })();
        fetchLogList();
        startLogTail();
        startLogListRefresh();

        // Enhanced View Log button behavior: expand logs card, select primary/output log, scroll into view (navigate to output log)
        (function(){
            if (!viewLogBtn) return;
            viewLogBtn.addEventListener('click', function(e){
                e.preventDefault();
                try {
                    // Expand logs card if collapsed
                    if (serverLogsToggle && serverLogsToggle.getAttribute('aria-expanded') === 'false') {
                        serverLogsToggle.click();
                    }
                    // Prefer a log file containing 'output' or 'server' in its name
                    if (Array.isArray(logFiles) && logFiles.length) {
                        let desired = logFiles.find(n => /output/i.test(n)) || logFiles.find(n => /server/i.test(n)) || logFiles[0];
                        if (desired && desired !== selectedLog) {
                            selectedLog = desired;
                            logTailOffset = -1;
                            logPausedByScroll = false;
                            if (logViewer) logViewer.textContent = '';
                            // Re-render tabs to reflect selection
                            renderLogTabs(logFiles);
                            fetchLogTail();
                            startLogTail();
                        } else if (desired) {
                            // Already selected: ensure tailing resumed and scrolled
                            logPausedByScroll = false;
                            startLogTail();
                            scrollViewerToBottom();
                        }
                    }
                    // Scroll logs card into view (user explicitly requested navigation)
                    if (serverLogsCard && typeof serverLogsCard.scrollIntoView === 'function') {
                        serverLogsCard.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }
                    // Focus the viewer for accessibility
                    if (logViewer) {
                        logViewer.setAttribute('tabindex','-1');
                        logViewer.focus({ preventScroll: true });
                    }
                } catch(_) { /* non-fatal */ }
            });
        })();

        // Collapsible Server Logs toggle (mirrors Manager/User Management behavior)
        (function(){
            try {
                const toggle = document.getElementById('serverLogsToggle');
                const content = document.getElementById('serverLogsContent');
                const chevron = document.getElementById('serverLogsChevron');
                const label = document.getElementById('serverLogsToggleLabel');
                if (!toggle || !content) return;
                const key = `sdsm:server:${rootEl.dataset.serverId}:logs:expanded`;
                const saved = sessionStorage.getItem(key);
                const initiallyExpanded = saved === null ? true : (saved === '1');
                function setState(expanded){
                    content.classList.toggle('hidden', !expanded);
                    content.setAttribute('aria-hidden', expanded ? 'false' : 'true');
                    toggle.setAttribute('aria-expanded', expanded ? 'true' : 'false');
                    if (label) label.textContent = expanded ? 'Less' : 'More';
                    if (chevron) chevron.innerHTML = expanded ? '<polyline points="6 15 12 9 18 15"></polyline>' : '<polyline points="6 9 12 15 18 9"></polyline>';
                    try { sessionStorage.setItem(key, expanded ? '1' : '0'); } catch(_) {}
                }
                setState(!!initiallyExpanded);
                toggle.addEventListener('click', function(){
                    const expanded = toggle.getAttribute('aria-expanded') !== 'true';
                    setState(expanded);
                });
            } catch(_) { /* non-fatal */ }
        })();

        function coreParamsChanged(){
            const worldEl = document.getElementById('world');
            const initWorldRef = (typeof initialWorldID !== 'undefined' ? initialWorldID : '');
            const currWorld = (!worldEl || worldEl.disabled)
                ? initWorldRef
                : ((worldEl && worldEl.value) || '');
            const currLoc = (document.getElementById('start_location') && document.getElementById('start_location').value) || '';
            const currCond = (document.getElementById('start_condition') && document.getElementById('start_condition').value) || '';
            const initLocRef = (rootEl && rootEl.dataset && rootEl.dataset.startLocation) ? rootEl.dataset.startLocation : (typeof initialStartLocation !== 'undefined' ? initialStartLocation : '');
            const initCondRef = (rootEl && rootEl.dataset && rootEl.dataset.startCondition) ? rootEl.dataset.startCondition : (typeof initialStartCondition !== 'undefined' ? initialStartCondition : '');
            return (currWorld !== initWorldRef) || (currLoc !== initLocRef) || (currCond !== initCondRef);
        }

        // Param change modal removed; confirmation handled by openConfirm/native confirm only.

        // Intercept Startup Parameters Update submit with blocking confirm when core params changed
        if (paramsForm && updateParamsBtn) {
            paramsForm.addEventListener('submit', function(e){
                if (window.__sdsmPendingSubmit) return;
                const valid = updateParamsValidity();
                if (!valid) {
                    e.preventDefault();
                    notifyError('Cannot apply changes: fix invalid startup parameters highlighted above.');
                    return;
                }
                const changed = coreParamsChanged();
                const apiOnly = paramsForm.getAttribute('data-api-only') === 'true';
                if (!apiOnly) {
                    // Not API-only: allow default behavior if unchanged; otherwise confirm then submit
                    if (!changed) return; // allow submit
                    e.preventDefault();
                    const proceedSubmit = () => {
                        let hiddenUpdate = paramsForm.querySelector('input[type="hidden"][name="update"]');
                        if (!hiddenUpdate) {
                            hiddenUpdate = document.createElement('input');
                            hiddenUpdate.type = 'hidden';
                            hiddenUpdate.name = 'update';
                            hiddenUpdate.value = 'true';
                            paramsForm.appendChild(hiddenUpdate);
                        } else {
                            hiddenUpdate.value = 'true';
                        }
                        try { if (confirmFlag) confirmFlag.value = '1'; } catch(_) {}
                        window.__sdsmPendingSubmit = true;
                        paramsForm.submit();
                    };
                    askConfirm({
                        title: 'Reset Saves Required',
                        body: 'Changing World, Start Location, or Start Condition will reset (purge) existing saves on next start. Continue?',
                        confirmText: 'Continue',
                        cancelText: 'Cancel',
                        danger: true,
                        icon: 'âš '
                    }, 'Changing World, Start Location, or Start Condition will reset (purge) existing saves on next start. Continue?').then(ok => { if (ok) proceedSubmit(); });
                    return;
                }
                // API-only path: never perform normal form submit; call API instead (with confirm if needed)
                e.preventDefault();
                const proceedAPI = () => { try { if (confirmFlag) confirmFlag.value = '1'; } catch(_) {} submitStartupParamsAPI(paramsForm); };
                if (!changed) { proceedAPI(); return; }
                askConfirm({
                    title: 'Reset Saves Required',
                    body: 'Changing World, Start Location, or Start Condition will reset (purge) existing saves on next start. Continue?',
                    confirmText: 'Continue',
                    cancelText: 'Cancel',
                    danger: true,
                    icon: 'âš '
                }, 'Changing World, Start Location, or Start Condition will reset (purge) existing saves on next start. Continue?').then(ok => { if (ok) proceedAPI(); });
            });

            // Also intercept direct button clicks
            updateParamsBtn.addEventListener('click', function(e){
                if (window.__sdsmPendingSubmit) return;
                if (!updateParamsValidity()) {
                    e.preventDefault();
                    notifyError('Cannot apply changes: fix invalid startup parameters highlighted above.');
                    return;
                }
                const changed = coreParamsChanged();
                const apiOnly = paramsForm.getAttribute('data-api-only') === 'true';
                if (!apiOnly) {
                    if (!changed) {
                        // No confirmation needed; submit
                        let hiddenUpdate = paramsForm.querySelector('input[type="hidden"][name="update"]');
                        if (!hiddenUpdate) {
                            hiddenUpdate = document.createElement('input');
                            hiddenUpdate.type = 'hidden';
                            hiddenUpdate.name = 'update';
                            hiddenUpdate.value = 'true';
                            paramsForm.appendChild(hiddenUpdate);
                        } else {
                            hiddenUpdate.value = 'true';
                        }
                        paramsForm.submit();
                        return;
                    }
                    e.preventDefault();
                    const proceedSubmit = () => {
                        let hiddenUpdate = paramsForm.querySelector('input[type="hidden"][name="update"]');
                        if (!hiddenUpdate) {
                            hiddenUpdate = document.createElement('input');
                            hiddenUpdate.type = 'hidden';
                            hiddenUpdate.name = 'update';
                            hiddenUpdate.value = 'true';
                            paramsForm.appendChild(hiddenUpdate);
                        } else {
                            hiddenUpdate.value = 'true';
                        }
                        try { if (confirmFlag) confirmFlag.value = '1'; } catch(_) {}
                        window.__sdsmPendingSubmit = true;
                        paramsForm.submit();
                    };
                    askConfirm({
                        title: 'Reset Saves Required',
                        body: 'Changing World, Start Location, or Start Condition will reset (purge) existing saves on next start. Continue?',
                        confirmText: 'Continue',
                        cancelText: 'Cancel',
                        danger: true,
                        icon: 'âš '
                    }, 'Changing World, Start Location, or Start Condition will reset (purge) existing saves on next start. Continue?').then(ok => { if (ok) proceedSubmit(); });
                    return;
                }
                // API-only
                e.preventDefault();
                const proceedAPI = () => { try { if (confirmFlag) confirmFlag.value = '1'; } catch(_) {} submitStartupParamsAPI(paramsForm); };
                if (!changed) { proceedAPI(); return; }
                askConfirm({
                    title: 'Reset Saves Required',
                    body: 'Changing World, Start Location, or Start Condition will reset (purge) existing saves on next start. Continue?',
                    confirmText: 'Continue',
                    cancelText: 'Cancel',
                    danger: true,
                    icon: 'âš '
                }, 'Changing World, Start Location, or Start Condition will reset (purge) existing saves on next start. Continue?').then(ok => { if (ok) proceedAPI(); });
            });
        }

        // Intercept Chat send form to POST a command to the API
        (function(){
            const chatForm = document.getElementById('chat-send-form');
            const chatInput = document.getElementById('chat-input');
            const chatBtn = document.getElementById('chat-send-button');
            if (!chatForm || !chatInput || !chatBtn || !serverId) return;
            chatForm.addEventListener('submit', function(e){
                e.preventDefault();
                const message = (chatInput.value || '').trim();
                if (!message || chatBtn.disabled) return;
                setButtonDisabled(chatBtn, true);
                toggleButtonSpinner(chatBtn, true);
                fetch(`/api/servers/${serverId}/chat`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    credentials: 'same-origin',
                    body: JSON.stringify({ message })
                })
                .then((res) => {
                    try {
                        if (typeof window.showToast === 'function') {
                            const type = res.headers.get('X-Toast-Type');
                            const title = res.headers.get('X-Toast-Title');
                            const msg = res.headers.get('X-Toast-Message');
                            if (msg) window.showToast({ type: type || 'info', title: title || '', message: msg });
                        }
                    } catch(_) {}
                    if (res.ok) {
                        chatInput.value = '';
                    }
                    // Status polling already updates chat view from logs
                })
                .catch(() => { /* no-op */ })
                .finally(() => { toggleButtonSpinner(chatBtn, false); setButtonDisabled(chatBtn, false); });
            });
        })();

        // Intercept Banned Add form submit for async update
        (function(){
            const addForm = document.getElementById('banned-add-form');
            const input = document.getElementById('ban_steam_id');
            const addBtn = addForm ? addForm.querySelector('button[type="submit"]') : null;
            if (addForm && input) {
                addForm.addEventListener('submit', function(e) {
                    e.preventDefault();
                    const id = (input.value || '').trim();
                    if (!id) return;
                    if (addBtn && addBtn.disabled) return;
                    // Disable input and button while request is in flight
                    if (addBtn) {
                        setButtonDisabled(addBtn, true);
                        toggleButtonSpinner(addBtn, true);
                    }
                    input.disabled = true;
                    const serverId = Number(rootEl.dataset.serverId || '0');
                    fetch(`/api/servers/${serverId}/ban`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
                        body: JSON.stringify({ steam_id: id }),
                        credentials: 'same-origin'
                    }).then((res) => {
                        try {
                            if (typeof window.showToast === 'function') {
                                const type = res.headers.get('X-Toast-Type');
                                const title = res.headers.get('X-Toast-Title');
                                const message = res.headers.get('X-Toast-Message');
                                if (message) window.showToast({ type: type || 'info', title: title || '', message });
                            }
                        } catch (_) {}
                        input.value = '';
                        fetchStatus();
                    }).catch(() => {
                        // No-op; status poll will reconcile
                    }).finally(() => {
                        if (addBtn) {
                            toggleButtonSpinner(addBtn, false);
                            setButtonDisabled(addBtn, false);
                        }
                        input.disabled = false;
                    });
                });
            }
        })();

        // Intercept Unban button clicks in banned table via API
        (function(){
            if (!playersBannedBody) return;
            playersBannedBody.addEventListener('click', function(e){
                const btn = e.target.closest && e.target.closest('button[name="unban"]');
                if (!btn) return;
                e.preventDefault();
                const id = (btn.value || '').trim();
                if (!id) return;
                if (btn.disabled) return;
                setButtonDisabled(btn, true);
                toggleButtonSpinner(btn, true);
                const serverId = Number(rootEl.dataset.serverId || '0');
                fetch(`/api/servers/${serverId}/unban`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
                    body: JSON.stringify({ steam_id: id }),
                    credentials: 'same-origin'
                }).then((res) => {
                    try {
                        if (typeof window.showToast === 'function') {
                            const type = res.headers.get('X-Toast-Type');
                            const title = res.headers.get('X-Toast-Title');
                            const message = res.headers.get('X-Toast-Message');
                            if (message) window.showToast({ type: type || 'info', title: title || '', message });
                        }
                    } catch (_) {}
                    fetchStatus();
                }).catch(() => {
                    // No-op
                }).finally(() => {
                    toggleButtonSpinner(btn, false);
                    setButtonDisabled(btn, false);
                });
            });
        })();

        // Intercept Start/Stop/Restart to use async fetch with toast + disable buttons during request
        (function(){
            function postAction(param, btn) {
                if (!param) return;
                if (btn && btn.disabled) return;
                if (btn) { setButtonDisabled(btn, true); toggleButtonSpinner(btn, true); }
                // If stopping, kick off local countdown UI based on configured delay
                if (param === 'stop') {
                    // Only show local countdown if players are connected
                    const liveCount = Number(playersLiveCount && playersLiveCount.textContent ? playersLiveCount.textContent.split(' ')[0] : '0');
                    if (liveCount > 0) {
                        try { startStopCountdown(); } catch(_) {}
                    }
                }
                if (param === 'restart') {
                    // For restart with shutdown delay, use stop countdown only if players present
                    const sd = Math.max(0, parseInt(rootEl.dataset.shutdownDelay || '0', 10));
                    const liveCount = Number(playersLiveCount && playersLiveCount.textContent ? playersLiveCount.textContent.split(' ')[0] : '0');
                    if (sd > 0 && liveCount > 0) {
                        try { startStopCountdown(); } catch(_) {}
                    }
                    try { startRestartSpinner(); } catch(_) {}
                }
                const serverId = Number(rootEl.dataset.serverId || '0');
                fetch(`/api/servers/${serverId}/` + param, {
                    method: 'POST',
                    headers: { 'Accept': 'application/json' },
                    credentials: 'same-origin'
                })
                .then((res) => {
                    try {
                        if (typeof window.showToast === 'function') {
                            const type = res.headers.get('X-Toast-Type');
                            const title = res.headers.get('X-Toast-Title');
                            const message = res.headers.get('X-Toast-Message');
                            if (message) window.showToast({ type: type || 'info', title: title || '', message });
                        }
                    } catch (_) {}
                    // status refresh to reflect new state
                    fetchStatus();
                    return res.ok ? res.json().catch(() => ({})) : Promise.resolve({});
                })
                .then((data) => {
                    // If API provided explicit scheduling info for restart, keep countdown UX
                    if (param === 'restart' && data && (data.status === 'restart-scheduled' || data.status === 'restart-pending')) {
                        const eta = Number(data.shutdown_eta_seconds || 0);
                        if (eta > 0) {
                            // Override local end time if provided by server (more accurate)
                            try {
                                const now = Date.now();
                                stopCountdownEnd = now + (eta * 1000);
                                if (!stoppingCountdownActive) {
                                    stoppingCountdownActive = true;
                                    setButtonDisabled(stopButton, true);
                                    toggleButtonSpinner(stopButton, true);
                                }
                            } catch(_) {}
                        }
                    }
                    return data;
                })
                .catch(() => { /* ignore, status poll will reconcile */ })
                .finally(() => {
                    if (btn) {
                        // For Stop during countdown, keep spinner+disabled
                        if (param === 'stop' && stoppingCountdownActive) {
                            setButtonDisabled(btn, true);
                            toggleButtonSpinner(btn, true);
                        // For Restart while active, keep spinner+disabled until starting completes
                        } else if (param === 'restart' && restartingActive) {
                            setButtonDisabled(btn, true);
                            toggleButtonSpinner(btn, true);
                        } else {
                            toggleButtonSpinner(btn, false);
                            setButtonDisabled(btn, false);
                        }
                    }
                });
            }

            if (startButton) {
                startButton.addEventListener('click', function(e){ e.preventDefault(); postAction('start', startButton); });
            }
            if (stopButton) {
                stopButton.addEventListener('click', function(e){ e.preventDefault(); postAction('stop', stopButton); });
            }
            if (restartButton) {
                restartButton.addEventListener('click', function(e){ e.preventDefault(); postAction('restart', restartButton); });
            }
        })();

        // Intercept Delete Server to call API and redirect on success
        (function(){
            if (!deleteButton) return;
            deleteButton.addEventListener('click', function(e){
                if (deleteButton.disabled) return;
                e.preventDefault();
                function proceed(){
                    setButtonDisabled(deleteButton, true);
                    toggleButtonSpinner(deleteButton, true);
                    const serverId = Number(rootEl.dataset.serverId || '0');
                    fetch(`/api/servers/${serverId}/delete`, {
                        method: 'POST',
                        headers: { 'Accept': 'application/json' },
                        credentials: 'same-origin'
                    }).then((res) => {
                        try {
                            if (typeof window.showToast === 'function') {
                                const type = res.headers.get('X-Toast-Type');
                                const title = res.headers.get('X-Toast-Title');
                                const message = res.headers.get('X-Toast-Message');
                                if (message) window.showToast({ type: type || 'success', title: title || '', message });
                            }
                        } catch(_) {}
                        setTimeout(() => { window.location.href = '/dashboard'; }, 300);
                    }).catch(() => {
                        // stay on page
                    }).finally(() => {
                        toggleButtonSpinner(deleteButton, false);
                        setButtonDisabled(deleteButton, false);
                    });
                }
                askConfirm({
                    title: 'Delete Server',
                    body: '<p>This will permanently delete this server and all of its files.</p><p><strong>This action cannot be undone.</strong></p>',
                    confirmText: 'Delete',
                    cancelText: 'Cancel',
                    danger: true,
                    icon: 'âš '
                }, 'Are you sure you want to delete this server? This action cannot be undone.').then(ok => { if (ok) proceed(); });
            });
        })();

        // Save split button: left click = Save, right caret opens dropdown with Save Asâ€¦
        (function(){
            const saveMain = document.getElementById('btn-save-main');
            const saveMenuBtn = document.getElementById('btn-save-menu');
            const saveMenu = document.getElementById('save-menu');
            const saveAsAction = document.getElementById('save-as-action');
            if ((!saveMain && !saveMenuBtn) || !serverId) return;

            function closeSaveMenu(){ if (saveMenu) saveMenu.classList.remove('active'); if (saveMenuBtn) saveMenuBtn.setAttribute('aria-expanded', 'false'); }
            function toggleSaveMenu(){ if (!saveMenu) return; const active = saveMenu.classList.toggle('active'); if (saveMenuBtn) saveMenuBtn.setAttribute('aria-expanded', active ? 'true' : 'false'); if (active) { try { const first = saveMenu.querySelector('.dropdown-item'); if (first) first.focus(); } catch(_) {} } }
            document.addEventListener('click', (ev) => {
                const root = document.getElementById('save-split');
                if (!root) return;
                if (!root.contains(ev.target)) { closeSaveMenu(); }
            }, { passive: true });

            if (saveMain) saveMain.addEventListener('click', function(e){
                e.preventDefault();
                if (saveMain.disabled) return;
                setButtonDisabled(saveMain, true);
                toggleButtonSpinner(saveMain, true);
                fetch(`/api/servers/${serverId}/save`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
                    credentials: 'same-origin',
                    body: JSON.stringify({})
                })
                .then((res) => {
                    try {
                        if (typeof window.showToast === 'function') {
                            const type = res.headers.get('X-Toast-Type');
                            const title = res.headers.get('X-Toast-Title');
                            const message = res.headers.get('X-Toast-Message');
                            if (message) window.showToast({ type: type || 'info', title: title || '', message });
                        }
                    } catch(_) {}
                    fetchStatus();
                })
                .catch(() => { /* no-op */ })
                .finally(() => { toggleButtonSpinner(saveMain, false); setButtonDisabled(saveMain, false); });
            });

            if (saveMenuBtn) saveMenuBtn.addEventListener('click', function(e){ e.preventDefault(); if (saveMenuBtn.disabled) return; toggleSaveMenu(); });
            // Keyboard navigation for save split menu
            if (saveMenuBtn && saveMenu) {
                saveMenuBtn.addEventListener('keydown', function(e){
                    if (e.key === 'ArrowDown' || e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        if (!saveMenu.classList.contains('active')) toggleSaveMenu();
                        const first = saveMenu.querySelector('.dropdown-item');
                        if (first) { try { first.focus(); } catch(_) {} }
                    } else if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        if (!saveMenu.classList.contains('active')) toggleSaveMenu();
                        const items = Array.from(saveMenu.querySelectorAll('.dropdown-item'));
                        if (items.length) { try { items[items.length - 1].focus(); } catch(_) {} }
                    }
                });
                saveMenu.addEventListener('keydown', function(e){
                    const items = Array.from(saveMenu.querySelectorAll('.dropdown-item'));
                    if (!items.length) return;
                    const current = document.activeElement;
                    const idx = items.indexOf(current);
                    if (e.key === 'ArrowDown') { e.preventDefault(); items[(idx + 1) % items.length].focus(); }
                    else if (e.key === 'ArrowUp') { e.preventDefault(); items[(idx - 1 + items.length) % items.length].focus(); }
                    else if (e.key === 'Home') { e.preventDefault(); items[0].focus(); }
                    else if (e.key === 'End') { e.preventDefault(); items[items.length - 1].focus(); }
                    else if (e.key === 'Escape') { e.preventDefault(); closeSaveMenu(); try { saveMenuBtn && saveMenuBtn.focus(); } catch(_) {} }
                });
            }

            // Save Asâ€¦ flow using shared prompt modal (fallback to simple modal if helpers unavailable)
            (function(){
                const legacy = {
                    modal: document.getElementById('saveAsModal'),
                    input: document.getElementById('saveAsName'),
                    confirm: document.getElementById('saveAsConfirm'),
                    cancel: document.getElementById('saveAsCancel')
                };

                function doSaveAs(name, btnToDisable){
                    if (!name) return Promise.resolve();
                    if (btnToDisable) setButtonDisabled(btnToDisable, true);
                    return fetch(`/api/servers/${serverId}/save-as`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
                        credentials: 'same-origin',
                        body: JSON.stringify({ name })
                    }).then((res) => {
                        try {
                            if (typeof window.showToast === 'function') {
                                const type = res.headers.get('X-Toast-Type');
                                const title = res.headers.get('X-Toast-Title');
                                const message = res.headers.get('X-Toast-Message');
                                if (message) window.showToast({ type: type || (res.ok ? 'success' : 'error'), title: title || '', message });
                            }
                        } catch(_) {}
                        fetchStatus();
                    }).catch(() => {}).finally(() => {
                        if (btnToDisable) setButtonDisabled(btnToDisable, false);
                    });
                }

                function openSaveAsPrompt(){
                    closeSaveMenu();
                    if (typeof window.openPrompt === 'function'){
                        window.openPrompt({
                            title: 'Save Asâ€¦',
                            label: 'Enter a name for your save',
                            placeholder: 'e.g., MyBase_NightShift',
                            confirmText: 'Save',
                            cancelText: 'Cancel',
                            validate: function(v){
                                if (!v || !v.trim()) return 'Please enter a name for your save.';
                                if (v.length > 100) return 'Name must be at most 100 characters.';
                                return true;
                            }
                        }).then(val => {
                            if (val == null) return; // cancelled
                            const name = String(val).trim();
                            if (!name) return;
                            return doSaveAs(name);
                        });
                        return;
                    }
                    // Fallback to existing modal if present
                    const m = legacy.modal;
                    const input = legacy.input;
                    const btnConfirm = legacy.confirm;
                    const btnCancel = legacy.cancel;
                    if (!m || !input || !btnConfirm){ return; }
                    m.classList.add('active');
                    setTimeout(() => { try { input && input.focus(); input && input.select && input.select(); } catch(_) {} }, 0);
                    function onCancel(){ try { m.classList.remove('active'); } catch(_) {} cleanup(); }
                    function onConfirm(){
                        const raw = (input.value || '').trim();
                        if (!raw) { notifyError && notifyError('Please enter a name for your save.'); try { input.focus(); } catch(_) {}; return; }
                        setButtonDisabled(btnConfirm, true);
                        doSaveAs(raw, btnConfirm).then(() => { try { m.classList.remove('active'); } catch(_) {} }).finally(() => { setButtonDisabled(btnConfirm, false); cleanup(); });
                    }
                    function onBackdrop(ev){ if (ev.target === m) onCancel(); }
                    function onKey(ev){ if (ev.key === 'Enter') { ev.preventDefault(); onConfirm(); } }
                    function cleanup(){
                        btnCancel && btnCancel.removeEventListener('click', onCancel);
                        btnConfirm && btnConfirm.removeEventListener('click', onConfirm);
                        m && m.removeEventListener('click', onBackdrop);
                        input && input.removeEventListener('keydown', onKey);
                    }
                    btnCancel && btnCancel.addEventListener('click', onCancel);
                    btnConfirm && btnConfirm.addEventListener('click', onConfirm);
                    m && m.addEventListener('click', onBackdrop);
                    input && input.addEventListener('keydown', onKey);
                }

                if (saveAsAction) saveAsAction.addEventListener('click', function(e){
                    e.preventDefault(); if (saveMenuBtn && saveMenuBtn.disabled) return; openSaveAsPrompt();
                });
            })();
        })();


        // Storm Start/Stop button: sends STORM start/stop via API and updates label
        (function(){
            if (!stormButton || !serverId) return;
            stormButton.addEventListener('click', function(e){
                e.preventDefault();
                if (stormButton.disabled) return;
                const startFlag = !serverIsStorming;
                setButtonDisabled(stormButton, true);
                toggleButtonSpinner(stormButton, true);
                fetch(`/api/servers/${serverId}/storm`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
                    credentials: 'same-origin',
                    body: JSON.stringify({ start: startFlag })
                }).then((res) => {
                    try {
                        if (typeof window.showToast === 'function') {
                            const type = res.headers.get('X-Toast-Type');
                            const title = res.headers.get('X-Toast-Title');
                            const message = res.headers.get('X-Toast-Message');
                            if (message) window.showToast({ type: type || 'info', title: title || '', message });
                        }
                    } catch(_) {}
                    fetchStatus();
                }).catch(() => {
                    // no-op; polling will reconcile
                }).finally(() => {
                    toggleButtonSpinner(stormButton, false);
                    setButtonDisabled(stormButton, false);
                });
            });
        })();

        // Cleanup Players buttons: send CLEANUPPLAYERS {dead|disconnected|all}
        (function(){
            function sendCleanup(option, btn){
                if (!serverId || !option) return;
                if (btn && btn.disabled) return;
                if (btn) { setButtonDisabled(btn, true); toggleButtonSpinner(btn, true); }
                fetch(`/api/servers/${serverId}/cleanup`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
                    credentials: 'same-origin',
                    body: JSON.stringify({ scope: option })
                }).then((res) => {
                    try {
                        if (typeof window.showToast === 'function') {
                            const type = res.headers.get('X-Toast-Type');
                            const title = res.headers.get('X-Toast-Title');
                            const message = res.headers.get('X-Toast-Message');
                            if (message) window.showToast({ type: type || 'info', title: title || '', message });
                        }
                    } catch(_) {}
                    fetchStatus();
                }).catch(() => {
                    // no-op
                }).finally(() => {
                    if (btn) { toggleButtonSpinner(btn, false); setButtonDisabled(btn, false); }
                });
            }

            if (cleanupDeadButton) cleanupDeadButton.addEventListener('click', function(e){ e.preventDefault(); sendCleanup('dead', cleanupDeadButton); });
            if (cleanupDiscButton) cleanupDiscButton.addEventListener('click', function(e){ e.preventDefault(); sendCleanup('disconnected', cleanupDiscButton); });
            if (cleanupAllButton) cleanupAllButton.addEventListener('click', function(e){ e.preventDefault(); sendCleanup('all', cleanupAllButton); });
        })();

        // Console: send arbitrary command to server via API
        (function(){
            if (!serverId || !consoleSendBtn || !consoleInput) return;
            function doSend(){
                const cmd = (consoleInput.value || '').trim();
                if (!cmd) return;
                if (consoleSendBtn.disabled) return;
                setButtonDisabled(consoleSendBtn, true);
                toggleButtonSpinner(consoleSendBtn, true);
                fetch(`/api/servers/${serverId}/console`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
                    credentials: 'same-origin',
                    body: JSON.stringify({ command: cmd })
                }).then((res) => {
                    try {
                        if (typeof window.showToast === 'function') {
                            const type = res.headers.get('X-Toast-Type');
                            const title = res.headers.get('X-Toast-Title');
                            const message = res.headers.get('X-Toast-Message');
                            if (message) window.showToast({ type: type || 'success', title: title || 'Command Sent', message });
                        }
                    } catch(_) {}
                    // keep input for convenience; optionally clear on success
                    // consoleInput.value = '';
                    fetchStatus();
                }).catch(() => {
                    // no-op
                }).finally(() => {
                    toggleButtonSpinner(consoleSendBtn, false);
                    setButtonDisabled(consoleSendBtn, false);
                    consoleInput.focus();
                });
            }
            consoleSendBtn.addEventListener('click', function(e){ e.preventDefault(); doSend(); });
            consoleInput.addEventListener('keydown', function(e){ if (e.key === 'Enter') { e.preventDefault(); doSend(); } });
        })();

        // Make Live/History Kick/Ban async as well (with toasts and button disable)
        (function(){
            // Local safe wrappers in case shared helpers aren't present
            function setBtnDisabled(btn, disabled) {
                try { if (typeof setButtonDisabled === 'function') return setButtonDisabled(btn, disabled); } catch(_) {}
                btn.disabled = !!disabled;
            }
            function toggleBtnSpinner(btn, on) {
                try { if (typeof toggleButtonSpinner === 'function') return toggleButtonSpinner(btn, on); } catch(_) {}
                // Minimal fallback: swap content with a simple spinner dot
                if (!btn) return;
                if (on) {
                    if (!btn.dataset.originalHtml) btn.dataset.originalHtml = btn.innerHTML;
                    btn.innerHTML = '<span class="btn-spinner" aria-hidden="true"></span>';
                } else {
                    if (btn.dataset.originalHtml) { btn.innerHTML = btn.dataset.originalHtml; delete btn.dataset.originalHtml; }
                }
            }
            function showToastFromResponse(res) {
                try {
                    if (typeof window.showToast === 'function') {
                        const type = res.headers.get('X-Toast-Type');
                        const title = res.headers.get('X-Toast-Title');
                        const message = res.headers.get('X-Toast-Message');
                        if (message) window.showToast({ type: type || 'info', title: title || '', message });
                    }
                } catch (_) {}
            }

            function postPlayerAction(action, value, btn) {
                if (!action || !value) return;
                if (btn && btn.disabled) return;
                if (btn) { setBtnDisabled(btn, true); toggleBtnSpinner(btn, true); }
                
                // For kick action, send console command via API
                if (action === 'kick') {
                    if (!serverId) {
                        if (btn) { toggleBtnSpinner(btn, false); setBtnDisabled(btn, false); }
                        return;
                    }
                    // Heuristic: if value looks like a 17-digit SteamID, send steam_id; else treat as name
                    const looksSteam = /^[0-9]{17}$/.test(value);
                    const payload = looksSteam ? { steam_id: value } : { name: value };
                    fetch(`/api/servers/${serverId}/kick`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Accept': 'application/json'
                        },
                        credentials: 'same-origin',
                        body: JSON.stringify(payload)
                    })
                    .then((res) => { showToastFromResponse(res); fetchStatus(); return res.ok ? res.json().catch(() => ({})) : Promise.resolve({}); })
                    .catch(() => { /* ignore; polling will reconcile */ })
                    .finally(() => { if (btn) { toggleBtnSpinner(btn, false); setBtnDisabled(btn, false); } });
                    return;
                }
                
                // For ban/unban, call API endpoints
                const endpoint = action === 'ban' ? 'ban' : 'unban';
                fetch(`/api/servers/${serverId}/${endpoint}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
                    credentials: 'same-origin',
                    body: JSON.stringify({ steam_id: value })
                })
                .then((res) => { showToastFromResponse(res); fetchStatus(); return res.ok ? res.json().catch(() => ({})) : Promise.resolve({}); })
                .catch(() => { /* ignore; polling will reconcile */ })
                .finally(() => { if (btn) { toggleBtnSpinner(btn, false); setBtnDisabled(btn, false); } });
            }

            function delegateAction(container) {
                if (!container) return;
                container.addEventListener('click', function(e){
                    const banBtn = e.target.closest && e.target.closest('button[name="ban"]');
                    const unbanBtn = !banBtn && e.target.closest && e.target.closest('button[name="unban"]');
                    const kickBtn = !banBtn && !unbanBtn && e.target.closest && e.target.closest('button[name="kick"]');
                    const btn = banBtn || unbanBtn || kickBtn;
                    if (!btn) return;
                    e.preventDefault();
                    const action = banBtn ? 'ban' : (unbanBtn ? 'unban' : 'kick');
                    const value = (btn.value || '').trim();
                    if (!value) return;
                    postPlayerAction(action, value, btn);
                });
            }

            const liveBody = document.getElementById('players-live-body');
            const historyBody = document.getElementById('players-history-body');
            delegateAction(liveBody);
            delegateAction(historyBody);
        })();
    });

    // -------- Server Logs (tabs + tail) --------
    function renderLogTabs(files) {
        if (!logTabs) return;
        logTabs.textContent = '';
        const hasFiles = Array.isArray(files) && files.length > 0;
        if (logTabsEmpty) logTabsEmpty.style.display = hasFiles ? 'none' : '';
        if (!hasFiles) return;
        files.forEach((name, idx) => {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'log-tab';
            btn.setAttribute('role', 'tab');
            btn.setAttribute('aria-selected', selectedLog === name ? 'true' : 'false');
            const label = document.createElement('span');
            label.className = 'filename';
            label.textContent = name;
            btn.appendChild(label);
            btn.addEventListener('click', function(){
                if (selectedLog === name) return;
                selectedLog = name;
                // update selected states
                const tabs = logTabs.querySelectorAll('.log-tab');
                tabs.forEach(t => t.setAttribute('aria-selected', t === btn ? 'true' : 'false'));
                // reset tail to end and clear viewer, then tail
                logTailOffset = -1;
                logPausedByScroll = false; // resume tailing on new selection
                if (logViewer) logViewer.textContent = '';
                fetchLogTail();
                try { if (typeof updateLogButtonsState === 'function') updateLogButtonsState(); } catch(_) {}
            });
            logTabs.appendChild(btn);
            if (!selectedLog && idx === 0) {
                selectedLog = name;
                btn.setAttribute('aria-selected', 'true');
                try { if (typeof updateLogButtonsState === 'function') updateLogButtonsState(); } catch(_) {}
            }
        });
    }

    function fetchLogList() {
        const serverId = Number(rootEl.dataset.serverId || '0');
        if (!serverId || !logTabs) return;
        fetch(`/api/servers/${serverId}/logs`, { headers: { 'Accept': 'application/json' }, credentials: 'same-origin' })
            .then(r => r.ok ? r.json() : null)
            .then(data => {
                if (!data || !Array.isArray(data.files)) return;
                const prevSelected = selectedLog;
                logFiles = data.files;
                renderLogTabs(logFiles);
                // If previously selected file no longer exists, reset selection and viewer
                if (prevSelected && !logFiles.includes(prevSelected)) {
                    selectedLog = logFiles[0] || '';
                    logTailOffset = -1;
                    if (logViewer) logViewer.textContent = '';
                }
                try { if (typeof updateLogButtonsState === 'function') updateLogButtonsState(); } catch(_) {}
                // Kick off tailing if we have a selection and no timer
                if (selectedLog && !logTimer) {
                    fetchLogTail();
                    startLogTail();
                }
            })
            .catch(() => {});
    }

    function fetchLogTail() {
        const serverId = Number(rootEl.dataset.serverId || '0');
        if (!serverId || !selectedLog || !logViewer || connectionLost) return;
        const params = new URLSearchParams();
        params.set('name', selectedLog);
        params.set('offset', String(logTailOffset));
        params.set('back', String(LOG_TAIL_BACK));
        params.set('max', String(LOG_TAIL_MAX));
        fetch(`/api/servers/${serverId}/log/tail?` + params.toString(), { credentials: 'same-origin' })
            .then(r => r.ok ? r.json() : null)
            .then(data => {
                if (!data) return;
                if (data.reset) {
                    // file rotated/truncated; viewer should show last chunk only
                    logViewer.textContent = '';
                }
                const chunk = typeof data.data === 'string' ? data.data : '';
                if (chunk) {
                    // Determine if we should stick to bottom (only when not paused and currently at bottom)
                    const shouldStick = !logPausedByScroll && isViewerAtBottom();
                    logViewer.textContent += chunk;
                    if (shouldStick) {
                        scrollViewerToBottom();
                    }
                }
                if (typeof data.offset === 'number') {
                    logTailOffset = data.offset;
                }
            })
            .catch(() => {});
    }

    function stopLogTail() {
        if (logTimer) {
            clearInterval(logTimer);
            logTimer = null;
        }
    }

    function startLogTail() {
        if (logTimer || connectionLost) return;
        if (logPausedByScroll) return;
        if (!selectedLog) return;
        logTimer = setInterval(fetchLogTail, 2000);
    }

    function initLogsUI() {
        // If no logs UI present, skip
        if (!logTabs || !logViewer) return;
        // Pause/resume tailing based on user scroll position
        logViewer.addEventListener('scroll', function(){
            // If user scrolls off the bottom, pause tailing. Resume when back at bottom.
            if (isViewerAtBottom()) {
                if (logPausedByScroll) {
                    logPausedByScroll = false;
                    startLogTail();
                }
            } else {
                if (!logPausedByScroll) {
                    logPausedByScroll = true;
                    stopLogTail();
                }
            }
        });
    }

    function startLogListRefresh() {
        if (logListTimer) return;
        logListTimer = setInterval(fetchLogList, 30000);
    }

    function isViewerAtBottom(tolerance){
        if (!logViewer) return false;
        const tol = typeof tolerance === 'number' ? tolerance : 4; // pixels
        return (logViewer.scrollTop + logViewer.clientHeight) >= (logViewer.scrollHeight - tol);
    }

    function scrollViewerToBottom(){
        if (!logViewer) return;
        logViewer.scrollTop = logViewer.scrollHeight;
    }

    // --- Logs actions (Refresh/Download/Clear) ---
    function updateLogButtonsState(){
        const hasSel = !!selectedLog;
        try { if (btnLogRefresh) btnLogRefresh.disabled = !hasSel; } catch(_) {}
        try { if (btnLogDownload) btnLogDownload.disabled = !hasSel; } catch(_) {}
        try { if (btnLogClear) btnLogClear.disabled = !hasSel; } catch(_) {}
    }

    (function initLogButtons(){
        const serverId = Number(rootEl && rootEl.dataset && rootEl.dataset.serverId || '0');
        if (!serverId) return;
        if (btnLogRefresh) {
            btnLogRefresh.addEventListener('click', function(){
                if (!selectedLog) return;
                logTailOffset = -1; // force reread from end/back window
                if (logViewer) logViewer.textContent = '';
                fetchLogTail();
            });
        }
        if (btnLogDownload) {
            btnLogDownload.addEventListener('click', function(){
                if (!selectedLog) return;
                const url = `/api/servers/${serverId}/log/download?name=` + encodeURIComponent(selectedLog);
                window.location = url;
            });
        }
        if (btnLogClear) {
            btnLogClear.addEventListener('click', function(){
                if (!selectedLog || btnLogClear.disabled) return;
                btnLogClear.disabled = true;
                const body = new URLSearchParams();
                body.set('name', selectedLog);
                fetch(`/api/servers/${serverId}/log/clear`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded', 'Accept': 'application/json' },
                    credentials: 'same-origin',
                    body: body.toString()
                }).then((res) => {
                    // On success, reset viewer and re-tail
                    logTailOffset = -1;
                    if (logViewer) logViewer.textContent = '';
                    fetchLogTail();
                    try {
                        if (typeof window.showToast === 'function') {
                            const type = res.headers.get('X-Toast-Type');
                            const title = res.headers.get('X-Toast-Title');
                            const msg = res.headers.get('X-Toast-Message');
                            if (msg) window.showToast({ type: type || (res.ok ? 'warning' : 'error'), title: title || (res.ok ? 'Log Cleared' : 'Log Error'), message: msg });
                        }
                    } catch(_) {}
                }).catch(()=>{
                    // ignore
                }).finally(()=>{
                    btnLogClear.disabled = false;
                });
            });
        }
        updateLogButtonsState();
    })();
</script>