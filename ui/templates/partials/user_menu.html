{{ define "user_menu" }}
<div class="user-menu" data-user-menu>
  <button class="avatar-btn" aria-haspopup="true" aria-expanded="false" title="Account" data-user-menu-trigger>
    <span class="avatar-initials">{{ if .username }}{{ initials (printf "%v" .username) }}{{ else }}?{{ end }}</span>
    <span class="role-badge" title="Role">?</span>
  </button>
  <div class="user-dropdown dropdown-panel dropdown-fixed" role="menu">
    <a href="/profile" class="dropdown-item" role="menuitem">
      {{ template "icon_user" . }}
      <span>Update Profile</span>
    </a>
    <a href="/logout" class="dropdown-item" role="menuitem">
      {{ template "icon_logout" . }}
      <span>Logout</span>
    </a>
  </div>
</div>
<script>
  (function(){
    function setupUserMenu(root){
      if(!root) return;
      const trigger = root.querySelector('[data-user-menu-trigger]');
      const menu = root.querySelector('.user-dropdown');
      const badge = root.querySelector('.role-badge');
      if(!trigger || !menu) return;
      if(root.dataset.bound === 'true') return;
      root.dataset.bound = 'true';
      function closeMenu(opts){
        const options = opts || {};
        const wasOpen = menu.classList.contains('active');
        menu.classList.remove('active');
        trigger.setAttribute('aria-expanded','false');
        // Only restore focus when explicitly requested (e.g., Escape or trigger toggle)
        if (options.restoreFocus && wasOpen) {
          try { trigger.focus({ preventScroll: true }); } catch(_) { try { trigger.focus(); } catch(_) {} }
        }
      }
      function openMenu(){
        // Temporarily show to measure size
        menu.style.visibility = 'hidden';
        menu.style.display = 'block';
        // Compute position near trigger, aligned to right edge
        const rect = trigger.getBoundingClientRect();
        const menuWidth = menu.offsetWidth;
        const padding = 6; // small gap below button
        let left = Math.round(rect.right - menuWidth);
        let top = Math.round(rect.bottom + padding);
        // Keep within viewport
        const vw = window.innerWidth, vh = window.innerHeight;
        if (left < 8) left = 8;
        if (left + menuWidth > vw - 8) left = Math.max(8, vw - menuWidth - 8);
        if (top > vh - 8) top = Math.max(8, rect.top - menu.offsetHeight - padding);
        menu.style.left = left + 'px';
        menu.style.top = top + 'px';
        menu.style.visibility = '';
        menu.classList.add('active');
        trigger.setAttribute('aria-expanded','true');
        // Focus first item for keyboard navigation
        const items = Array.from(menu.querySelectorAll('.dropdown-item'));
        if (items.length) { try { items[0].focus(); } catch(_) {} }
      }
      trigger.addEventListener('click', function(e){
        e.stopPropagation();
        if (menu.classList.contains('active')) { closeMenu({ restoreFocus: true }); }
        else { openMenu(); }
      });
      document.addEventListener('click', function(e){
        // Close only when open, and do not restore focus on outside clicks to avoid scroll jumps
        if(menu.classList.contains('active') && !root.contains(e.target)) closeMenu({ restoreFocus: false });
      });
      window.addEventListener('keydown', function(e){ if(e.key === 'Escape') closeMenu({ restoreFocus: true }); });
      // Keyboard support: open with Arrow keys/Enter/Space, navigate items with arrows/Home/End
      function focusItemAt(idx){
        const items = Array.from(menu.querySelectorAll('.dropdown-item'));
        if (!items.length) return;
        const clamped = ((idx % items.length) + items.length) % items.length;
        try { items[clamped].focus(); } catch(_) {}
      }
      trigger.addEventListener('keydown', function(e){
        if (e.key === 'ArrowDown' || e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          if (!menu.classList.contains('active')) openMenu();
          focusItemAt(0);
        } else if (e.key === 'ArrowUp') {
          e.preventDefault();
          if (!menu.classList.contains('active')) openMenu();
          const items = Array.from(menu.querySelectorAll('.dropdown-item'));
          focusItemAt(items.length - 1);
        }
      });
      menu.addEventListener('keydown', function(e){
        const items = Array.from(menu.querySelectorAll('.dropdown-item'));
        if (!items.length) return;
        const current = document.activeElement;
        let idx = items.indexOf(current);
        if (e.key === 'ArrowDown') { e.preventDefault(); focusItemAt((idx < 0 ? 0 : idx + 1)); }
        else if (e.key === 'ArrowUp') { e.preventDefault(); focusItemAt((idx < 0 ? items.length - 1 : idx - 1)); }
        else if (e.key === 'Home') { e.preventDefault(); focusItemAt(0); }
        else if (e.key === 'End') { e.preventDefault(); focusItemAt(items.length - 1); }
        else if (e.key === 'Escape') { e.preventDefault(); closeMenu({ restoreFocus: true }); }
      });
      // Keep dropdown aligned on resize/scroll if open
      function maybeReposition(){ if(menu.classList.contains('active')) { openMenu(); } }
      window.addEventListener('resize', maybeReposition, { passive: true });
      window.addEventListener('scroll', maybeReposition, { passive: true });
      // Fetch role for badge
      try {
        fetch('/whoami', { credentials: 'same-origin', cache: 'no-store' })
          .then(r => r.ok ? r.json() : null)
          .then(data => {
            if(!data || !badge) return;
            const role = (data.role || '').toLowerCase();
            if(role === 'admin') { badge.textContent = 'A'; badge.style.background = 'var(--danger-600)'; badge.title = 'Admin'; }
            else { badge.textContent = 'O'; badge.style.background = 'var(--warning-500)'; badge.title = 'Operator'; }
          })
          .catch(() => {});
      } catch(_) {}
    }
    document.addEventListener('DOMContentLoaded', function(){
      document.querySelectorAll('[data-user-menu]').forEach(setupUserMenu);
    });
  })();
</script>
{{ end }}
