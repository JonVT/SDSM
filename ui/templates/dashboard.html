<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Stationeers Server Dashboard - Monitor and manage your servers">
    <title>Dashboard - Stationeers Server Manager</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/static/ui-theme.css?v={{buildTime}}">
    <link rel="icon" href="/sdsm.png" type="image/png">
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
</head>
<body class="page-shell">
    <div id="connection-banner" class="connection-banner" role="status" aria-live="polite">
        <span id="connection-banner-text">Connection lost. Attempting to reconnect...</span>
        <button type="button" id="connection-banner-action">Reload</button>
    </div>

    <div class="container">
        <header class="hero-card">
            <div class="hero-main">
                <img src="/sdsm.png" alt="SDSM logo" class="hero-logo" width="72" height="72">
                <div class="hero-heading">
                    <h1 class="hero-title">Server Dashboard</h1>
                    <p class="hero-subtitle">Monitor and manage your Stationeers servers in real time.</p>
                </div>
            </div>
            <div class="hero-meta">
                <div class="hero-meta-title">Fleet Overview</div>
                <p class="hero-meta-text">
                    <span id="header-total-servers">--</span> server<span id="header-total-servers-suffix">s</span> tracked â€¢
                    <span id="header-active-servers">--</span> active â€¢
                    <span id="header-total-players">--</span> players
                </p>
                <span class="pill">Last refresh: <span id="last-refresh">just now</span></span>
            </div>
            <div class="hero-actions" style="flex-direction: column; align-items: flex-end;">
                <div style="display: flex; align-items: center; gap: var(--space-2);">
                <button class="theme-toggle" onclick="toggleTheme()" aria-label="Toggle theme">
                    <span id="theme-icon">ðŸŒ™</span>
                </button>
                <button
                    class="btn btn-primary"
                    hx-get="/api/refresh"
                    hx-trigger="click"
                    hx-indicator="#refresh-indicator"
                    hx-swap="none"
                >
                    <svg class="icon-inline" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                        <polyline points="23 4 23 10 17 10"></polyline>
                        <polyline points="1 20 1 14 7 14"></polyline>
                        <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10"></path>
                        <path d="M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
                    </svg>
                    <span id="refresh-indicator" class="hidden">âŸ³</span>
                    Refresh
                </button>
                <a href="/manager" class="btn btn-primary">
                    {{ template "icon_manager" . }}
                    Manager
                </a>
                {{ template "user_menu" . }}
                </div>
                <span style="font-size: 0.7rem; color: var(--text-muted, #888); margin-top: 4px;">{{buildTime}}</span>
            </div>
        </header>
    </div>

    <main class="container dashboard-content">
           <section class="stats-grid"
               hx-get="/api/stats"
               hx-trigger="load, every 30s, refresh"
               hx-headers='{"Accept":"text/html"}'
               hx-swap="innerHTML">
            <span class="htmx-indicator pill" aria-hidden="true">Refreshingâ€¦</span>
            <div class="stat-card">
                <div class="stat-value" id="total-servers">{{ len .servers }}</div>
                <div class="stat-label">Total Servers</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="active-servers">
                    {{ $active := 0 }}
                    {{ range .servers }}
                        {{ if .IsRunning }}{{ $active = add $active 1 }}{{ end }}
                    {{ end }}
                    {{ $active }}
                </div>
                <div class="stat-label">Active Servers</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="total-players">
                    {{ $players := 0 }}
                    {{ range .servers }}
                        {{ $players = add $players .ClientCount }}
                    {{ end }}
                    {{ $players }}
                </div>
                <div class="stat-label">Connected Players</div>
            </div>
            <div class="stat-card">
                <div class="stat-value">100%</div>
                <div class="stat-label">System Health</div>
            </div>
        </section>

        <section id="server-grid"
                 class="grid-split"
                 hx-get="/api/servers"
                 hx-trigger="load, every 10s, refresh"
                 hx-headers='{"Accept":"text/html"}'
                 hx-swap="innerHTML">
            <span class="htmx-indicator pill" aria-hidden="true">Refreshingâ€¦</span>
            {{ template "server_cards.html" . }}
        </section>
    </main>

    {{ if .servers }}
    <button class="floating-action" onclick="createNewServer()" aria-label="Add new server">+</button>
    {{ end }}

    <script>
        let ws;

        function getStoredTheme() {
            return localStorage.getItem('theme') || 'dark';
        }

        function setTheme(theme) {
            const html = document.documentElement;
            html.setAttribute('data-theme', theme);
            localStorage.setItem('theme', theme);
            const icon = document.getElementById('theme-icon');
            if (icon) {
                icon.textContent = theme === 'dark' ? 'â˜€ï¸' : 'ðŸŒ™';
            }
        }

        function toggleTheme() {
            const current = document.documentElement.getAttribute('data-theme') || getStoredTheme();
            const next = current === 'dark' ? 'light' : 'dark';
            setTheme(next);
        }

        setTheme(getStoredTheme());

        function bindServerCardNavigation(root) {
            const cards = (root || document).querySelectorAll('.server-card');
            cards.forEach(card => {
                if (card.dataset.navigationBound === 'true') {
                    return;
                }
                card.dataset.navigationBound = 'true';
                card.addEventListener('click', event => {
                    if (event.target.closest('[data-stop-navigation="true"]')) {
                        return;
                    }
                    const url = card.getAttribute('data-target-url');
                    if (url) {
                        window.location.href = url;
                    }
                });
            });
        }

        bindServerCardNavigation();

        document.addEventListener('htmx:afterSwap', event => {
            if (event.target && event.target.closest('#server-grid')) {
                bindServerCardNavigation(event.target.closest('#server-grid'));
            }
        });

        const HEALTH_ENDPOINT = '/healthz';
        const HEALTH_TIMEOUT = 4000;
        const HEALTH_INTERVAL_OK = 15000;
        const HEALTH_INTERVAL_LOST = 5000;
        let healthTimer = null;
        let healthLost = false;

        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws`;
            ws = new WebSocket(wsUrl);

            ws.onopen = () => console.log('WebSocket connected');
            ws.onmessage = event => handleRealtimeUpdate(JSON.parse(event.data));
            ws.onclose = () => setTimeout(connectWebSocket, 3000);
            ws.onerror = error => console.error('WebSocket error:', error);
        }

        function setDashboardConnectionBanner(active, text) {
            // If rendered inside the main frame, delegate to top-level banner
            if (window.top && window.top !== window && typeof window.top.setConnectionBanner === 'function') {
                window.top.setConnectionBanner(!!active, text || '');
                return;
            }
            const banner = document.getElementById('connection-banner');
            const bannerText = document.getElementById('connection-banner-text');
            if (!banner) {
                return;
            }
            if (active) {
                banner.classList.add('active');
                if (bannerText && text) {
                    bannerText.textContent = text;
                }
                document.body.style.paddingTop = '3.5rem';
            } else {
                banner.classList.remove('active');
                document.body.style.paddingTop = '';
            }
        }

        function scheduleHealthCheck(delay) {
            if (healthTimer) {
                clearTimeout(healthTimer);
            }
            healthTimer = setTimeout(runHealthCheck, delay);
        }

        function runHealthCheck() {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), HEALTH_TIMEOUT);
            fetch(HEALTH_ENDPOINT, {
                cache: 'no-store',
                credentials: 'same-origin',
                signal: controller.signal
            })
                .then(response => {
                    clearTimeout(timeoutId);
                    if (!response.ok) {
                        throw new Error('Health check failed');
                    }
                    if (healthLost) {
                        healthLost = false;
                        setDashboardConnectionBanner(true, 'Connection restored. Reloading...');
                        setTimeout(() => {
                            setDashboardConnectionBanner(false);
                            window.location.reload();
                        }, 1200);
                        return;
                    }
                    setDashboardConnectionBanner(false);
                })
                .catch(() => {
                    clearTimeout(timeoutId);
                    if (!healthLost) {
                        healthLost = true;
                        setDashboardConnectionBanner(true, 'Connection lost. Attempting to reconnect...');
                    }
                })
                .finally(() => {
                    scheduleHealthCheck(healthLost ? HEALTH_INTERVAL_LOST : HEALTH_INTERVAL_OK);
                });
        }

        function startHealthMonitor() {
            const reloadBtn = document.getElementById('connection-banner-action');
            if (reloadBtn) {
                reloadBtn.addEventListener('click', () => window.location.reload());
            }
            runHealthCheck();
        }

        function handleRealtimeUpdate(data) {
            switch (data.type) {
                case 'server_status':
                    updateServerStatus(data.serverId, data.status);
                    break;
                case 'server_update':
                    updateServerStatus(data.serverId, data.status);
                    break;
                case 'servers_changed':
                    // Immediately refresh server grid and stats
                    try { htmx.trigger('#server-grid', 'refresh'); } catch (e) {}
                    try { htmx.trigger('.stats-grid', 'refresh'); } catch (e) {}
                    break;
                case 'stats_update':
                    updateStats(data.stats);
                    break;
                default:
                    console.log('Unknown update type:', data.type);
            }
        }

        function updateServerStatus(serverId, status) {
            const serverCard = document.querySelector(`[data-server-id="${serverId}"]`);
            if (!serverCard) {
                return;
            }
            const statusBadge = serverCard.querySelector('[data-status]');
            const stormBadge = serverCard.querySelector('[data-storm]');
            if (statusBadge) {
                const isRunning = !!status.running;
                const isStarting = !!status.starting && isRunning;
                const isPaused = !!status.paused && isRunning && !isStarting;

                // Normalize pill variant classes (running, paused, stopped)
                statusBadge.classList.remove('status-running', 'status-idle', 'is-running', 'is-stopped', 'is-paused', 'is-starting');
                statusBadge.classList.toggle('is-starting', isStarting);
                statusBadge.classList.toggle('is-running', isRunning && !isPaused && !isStarting);
                statusBadge.classList.toggle('is-paused', isRunning && isPaused);
                statusBadge.classList.toggle('is-stopped', !isRunning);

                // For cards, render as a dot only. Provide an accessible label.
                const desiredLabel = isStarting ? 'Starting' : (!isRunning ? 'Stopped' : (isPaused ? 'Paused' : 'Running'));
                statusBadge.setAttribute('aria-label', `Status: ${desiredLabel}`);
                statusBadge.setAttribute('title', desiredLabel);
            }
            // Update storm badge
            if (stormBadge) {
                const isRunning = !!status.running;
                const isStorming = !!status.storming && isRunning;
                if (isRunning && isStorming) {
                    stormBadge.style.display = '';
                    stormBadge.classList.remove('is-storm', 'is-clear');
                    stormBadge.classList.add('is-storm');
                    stormBadge.setAttribute('aria-label', 'Storm');
                    stormBadge.setAttribute('title', 'Storm');
                    // Ensure no visible text for dot-only UI
                    stormBadge.textContent = '';
                } else {
                    stormBadge.style.display = 'none';
                }
            }
            // Update server name if provided
            if (status.name !== undefined) {
                const nameEl = serverCard.querySelector('[data-server-name]');
                if (nameEl) {
                    nameEl.textContent = status.name;
                }
            }
            // Update port if provided
            if (status.port !== undefined) {
                const portEl = serverCard.querySelector('[data-port-value]');
                if (portEl) {
                    portEl.textContent = String(status.port);
                }
            }
            if (status.playerCount !== undefined) {
                const playerInfo = serverCard.querySelector('[data-player-count]');
                if (playerInfo) {
                    playerInfo.textContent = `${status.playerCount}/${status.maxPlayers || '?'}`;
                }
            }
            // Update world if provided
            if (status.world !== undefined) {
                const worldEl = serverCard.querySelector('[data-world-value]');
                if (worldEl) {
                    worldEl.textContent = status.world;
                }
            }
        }

        function updateStats(stats) {
            if (stats.totalServers !== undefined) {
                const total = document.getElementById('total-servers');
                if (total) total.textContent = stats.totalServers;
                const hTotal = document.getElementById('header-total-servers');
                if (hTotal) hTotal.textContent = stats.totalServers;
                const hSuffix = document.getElementById('header-total-servers-suffix');
                if (hSuffix) hSuffix.textContent = stats.totalServers === 1 ? '' : 's';
            }
            if (stats.activeServers !== undefined) {
                const active = document.getElementById('active-servers');
                if (active) active.textContent = stats.activeServers;
                const hActive = document.getElementById('header-active-servers');
                if (hActive) hActive.textContent = stats.activeServers;
            }
            if (stats.totalPlayers !== undefined) {
                const players = document.getElementById('total-players');
                if (players) players.textContent = stats.totalPlayers;
                const hPlayers = document.getElementById('header-total-players');
                if (hPlayers) hPlayers.textContent = stats.totalPlayers;
            }
            const refresh = document.getElementById('last-refresh');
            if (refresh) {
                const now = new Date();
                refresh.textContent = now.toLocaleTimeString();
            }
        }

        // Lightweight header poll to ensure header stats stay in sync even without websocket
        function pollHeaderStats() {
            fetch('/api/stats', { headers: { 'Accept': 'application/json' }, credentials: 'same-origin', cache: 'no-store' })
                .then(r => r.ok ? r.json() : null)
                .then(data => { if (data) updateStats(data); })
                .catch(() => {});
        }

        function createNewServer() {
            window.location.href = '/server/new';
        }

        document.addEventListener('DOMContentLoaded', () => {
            connectWebSocket();
            startHealthMonitor();
            // Initial header stats + interval
            pollHeaderStats();
            setInterval(pollHeaderStats, 30000);

            document.body.addEventListener('htmx:beforeRequest', event => {
                if (event.detail.elt?.getAttribute('hx-indicator') === '#refresh-indicator') {
                    document.getElementById('refresh-indicator')?.classList.remove('hidden');
                }
            });

            document.body.addEventListener('htmx:afterRequest', event => {
                if (event.detail.elt?.getAttribute('hx-indicator') === '#refresh-indicator') {
                    document.getElementById('refresh-indicator')?.classList.add('hidden');
                }
            });

            setInterval(() => {
                htmx.trigger('#server-grid', 'refresh');
                htmx.trigger('.stats-grid', 'refresh');
            }, 30000);
        });

        document.addEventListener('keydown', event => {
            if (event.ctrlKey && event.shiftKey && event.key === 'T') {
                event.preventDefault();
                toggleTheme();
            }
            if (event.ctrlKey && event.key === 'r') {
                event.preventDefault();
                htmx.trigger('#server-grid', 'refresh');
            }
        });

        window.addEventListener('beforeunload', () => {
            if (ws) {
                ws.close();
            }
        });
    </script>
    
    {{ template "toast.html" . }}
</body>
</html>